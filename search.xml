<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DrawCall</title>
    <url>/2022/07/29/DrawCall/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>在整个渲染工作的执行过程中主要的计算部件有两个：<code>CPU</code>和<code>GPU</code>。<code>CPU</code>的性能影响着<code>Application</code>、<code>Runtime</code>和<code>Driver</code>的执行效率。<code>GPU</code>的性能主要影响着<code>Vertex</code>处理、<code>Shader</code>计算和一堆<code>Frame Buffer</code>相关的像素操作（如：<code>Blend</code>和<code>Multisample anti-aliasing</code>等）的执行效率。<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/CPU%E4%B8%8EGPU.png?raw=true"></li>
<li><code>GPU</code>：</li>
</ul>
<ol>
<li>填充率：指<code>GPU</code>每秒能够渲染的屏幕像素数量，它是引起<code>GPU</code>的性能问题的最常见因素，尤其是在移动设备上。下面列出一些与填充率相关的优化手段：1）优化片元着色器（<code>Fragment Shader</code>）；2）减少重绘（<code>Overdraw</code>）；3）减少图像特效（<code>Image Efficts</code>）</li>
<li>显存带宽（也称内存带宽，<code>Memory Bandwidth</code>）：指<code>GPU</code>对其专用的内存的读写速率。如果游戏出现带宽受限，通常是因为使用了太大的纹理（<code>Texture</code>），优化手段：1）纹理压缩；2）<code>Mipmap</code></li>
</ol>
<ul>
<li>区分<code>Batch</code> 、 <code>Drawcall</code> 、 <code>Set Pass Call</code></li>
</ul>
<ol>
<li><code>Set Pass Call</code>指一次渲染状态切换，材质不一致的时候出现一次</li>
<li>两个相邻执行的<code>Batch</code>之间，如果使用不同材质球或者使用同材质球不同<code>pass</code>，则会执行一次<code>Set Pass Call</code></li>
<li><code>CPU</code>调用一次<code>GPU</code>绘制函数称为一次<code>Draw call</code>，多个<code>Draw call</code>在<code>unity</code>中可以合并为一个<code>Batch</code>提交</li>
<li>不同<code>mesh</code>不同材质会分别进行渲染设置并调用<code>Draw call</code></li>
<li>不同<code>mesh</code>同材质在满足条件的情况下被顶点数据合并一次性提交给<code>GPU</code>，减少<code>batch</code>不降低<code>Draw call</code></li>
<li>多<code>pass</code>的<code>mesh</code>每个<code>pass</code>会执行一个<code>Batch</code>，无法合批<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/Set%20pass%20call%20%E3%80%81Batch%E3%80%81draw%20call.png?raw=true"></li>
</ol>
<h1 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a><code>DrawCall</code></h1><ul>
<li><p>定义：<code>CPU</code>调用图像编程接口，如<code>OpenGL</code>中的<code>glDrawElements</code>命令或者<code>DirectX</code>中的<code>DrawlndexedPrimitive</code>命令，以命令<code>GPU</code>进行渲染的操作</p>
</li>
<li><p><code>DrawCall</code>命令存放在命令缓冲区（<code>Command Buffer</code>）。<code>Runtime</code>会将所有的<code>API</code>调用先转换为设备无关的“命令”（之所以是设备无关的，主要是因为这样我们写的程序就可以运行在任何特性兼容的硬件上了。运行时库使不同的硬件架构相对我们变的透明）</p>
</li>
<li><p><strong>命令缓冲区的作用：1）提升渲染效率；2）让<code>CPU</code>和<code>GPU</code>能够并行工作</strong></p>
</li>
<li><p><strong><code>Draw Call</code>性能消耗原因是命令从<code>Runtime</code>到<code>Driver</code>的过程中，<code>CPU</code>要发生从用户模式到内核模式的切换。</strong> 模式切换对于<code>CPU</code>来说是一件非常耗时的工作，所以如果所有的<code>API</code>调用<code>Runtime</code>都直接发送渲染命令给<code>Driver</code>，那就会导致每次<code>API</code>调用都发生<code>CPU</code>模式切换，这个性能消耗是非常大的。<code>Runtime</code>中的<code>Command Buffer</code>可以将一些没有必要马上发送给<code>Driver</code>的命令缓冲起来，在适当的时机一起发送给<code>Driver</code>，进而在显卡执行。以这样的方式来寻求最少的<code>CPU</code>模式切换，提升效率</p>
</li>
<li><p>每次<code>Draw Call</code>，<code>CPU</code>要执行下列操作：</p>
</li>
</ul>
<ol>
<li><code>CPU</code>可能会向GPU发送 <code>Set Pass Call</code> 指令来修改一些被统称为 <code>Render State</code> 的变量。每个<code>Set Pass Call</code>都会告知<code>GPU</code>在下次渲染<code>Mesh</code>时要使用哪个配置。只有在下次需要渲染的<code>Mesh</code>的<code>Render State</code>与当前的<code>Render State</code>不同时，才会有<code>Set Pass Call</code></li>
<li><code>CPU</code>向<code>GPU</code>发送<code>Draw Call</code>指令。<code>Draw Call</code>指令告知<code>GPU</code>使用最近一次的<code>Set Pass Call</code>的配置对指定的<code>Mesh</code>进行渲染</li>
<li>在某些情况下，一个<code>Batch</code>可能需要不止一个 <code>Pass</code>。<code>Pass</code>是一段<code>Shader</code>代码，新的<code>Pass</code>会改变<code>Render State</code>。<code>CPU</code>必须为<code>Batch</code>中的每个<code>Pass</code>发送新的<code>Set Pass Call</code>并再次发送<code>Draw Call</code></li>
</ol>
<ul>
<li>与此同时，<code>GPU</code>进行着如下的工作：</li>
</ul>
<ol>
<li><code>GPU</code>根据<code>CPU</code>的指令执行任务，执行顺序与指令发送顺序相同</li>
<li>如果当前的任务是一个<code>Set Pass Call</code>，则<code>GPU</code>更新<code>Render State</code></li>
<li>如果当前的任务是一个<code>Draw Call</code>，则<code>GPU</code>渲染<code>Mesh</code></li>
<li>重复上述过程直到<code>GPU</code>将来自<code>CPU</code>的指令全部处理完</li>
</ol>
<ul>
<li><p><code>Draw call</code>之间切换<code>Texture</code>、<code>Shader</code>或者<code>Material</code>参数会导致<code>CPU</code>至少两方面的时间消耗：1）把<code>Draw call</code>及渲染状态切换的API调用转换成设备无关命令耗费的时间（其中还包括命令检查等操作）；2）刷新<code>Command Buffer</code>导致<code>CPU</code>由用户模式切换到内核模式带来的时间消耗。第一点的时间消耗其实并不大。关键的时间消耗在于第二点。所以一般情况下我们希望<code>Command Buffer</code>缓存尽可能多的命令，然后一次全部提交给<code>GPU</code>执行</p>
</li>
<li><p>问题</p>
</li>
</ul>
<ol>
<li>为什么<code>DrawCall</code>多了会影响性能？</li>
</ol>
<ul>
<li>在每次调用<code>Draw Call</code> 之前， <code>CPU</code>需要向<code>GPU</code>发送很多内容，包括数据、状态和命令等。在这一阶段，<code>CPU</code> 需要完成很多工作，例如检查渲染状态等。而一旦<code>CPU</code> 完成了这些准备工作，<code>GPU</code> 就可以开始本次的渲染。<code>GPU</code> 的渲染能力是很强的，渲染<code>200</code> 个还是<code>2000</code> 个三角网格通常没有什么区别，因此渲染速度往往快于<code>CPU</code> 提交命令的速度。如果<code>Draw Call</code> 的数量太多，<code>CPU</code> 就会把大量时间花费在提交<code>Draw Call</code> 上，造成<code>CPU</code>的过载。总结：1）<strong>把<code>Draw call</code>及渲染状态切换的<code>API</code>调用转换成设备无关命令耗费的时间（其中还包括命令检查等操作）</strong>。2）<strong>命令从<code>Runtime</code>到<code>Driver</code>的过程中导致<code>CPU</code>由用户模式切换到内核模式带来的时间消耗</strong>。<strong>所以，有一个常见的误区是<code>Draw Call</code>中造成性能问题的元凶是<code>GPU</code>，认为<code>GPU</code>上的状态切换是耗时的，其实真正拖后腿是<code>CPU</code></strong><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA.jpg?raw=true"></li>
</ul>
<ol>
<li>优化方法</li>
</ol>
<ul>
<li>最常见的优化方法是批处理</li>
</ul>
<ol start="3">
<li><code>DrawCall</code>越小越好？</li>
</ol>
<ul>
<li>不一定。影响渲染模块性能的除了<code>Draw Call</code>之外，还有<strong>用于传输渲染数据的总线带宽</strong>。当使用<code>Draw Call Batching</code>将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（<code>Texture</code>、<code>VB</code>&#x2F;<code>IB</code>等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，<code>GPU</code>只能等待，从而反倒降低了游戏的运行帧率<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E6%80%BB%E7%BA%BF%E5%B8%A6%E5%AE%BD.png?raw=true"></li>
</ul>
<h1 id="Batch（批次）"><a href="#Batch（批次）" class="headerlink" title="Batch（批次）"></a><code>Batch</code>（批次）</h1><ul>
<li>定义：调用一次<code>API</code>的绘制接口向<code>GPU</code>提交相同渲染状态的一定数量的三角形的行为，此行为称为一个渲染批次。</li>
<li>每一次<code>Batch</code>的提交就是一次<code>Draw call</code>调用，可以包含多个<code>Draw call</code>。一般用引擎每帧提交的批次数量来作为衡量渲染压力的指标。</li>
<li>特点：</li>
</ul>
<ol>
<li><code>CPU</code>的性能决定提交<code>Batch</code>的效率，在不给<code>GPU</code>造成渲染压力的前提下，<code>Batch</code>越大越好</li>
<li>在每个<code>Batch</code>提交的三角形较少时，虽然<code>GPU</code>性能不同，每秒能够渲染的三角形数量基本保持一致。但每个<code>Batch</code>提交的三角形超过一定数量时，高性能<code>CPU</code>每秒钟能够渲染的三角形数量继续线性增长，但是配置低性能<code>GPU</code>的环境处理能力明显降低。可得，每个<code>Batch</code>提交的三角形较少时，性能或者处理效率在<code>CPU</code>（每个<code>Batch</code>提交的三角形），<code>GPU</code>有足够的时间来处理提交的三角形；而每个<code>Batch</code>提交的三角形较多时，性能或者处理效率在<code>GPU</code></li>
</ol>
<ul>
<li><code>API</code>调用的角度来看，<code>Batch</code>和<code>Draw call</code>是等价的，但是在游戏引擎中他们的实际意义是不一样的：<code>Batch</code>一般指代经过打包之后的<code>Draw call</code></li>
</ul>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><ul>
<li>定义：对某对象进行批量的处理</li>
<li>静态合批的效率比动态合批的效率更高，因为静态合批不在<code>CPU</code>上变换顶点</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E5%B8%B8%E8%A7%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"></p>
<h1 id="离线合批"><a href="#离线合批" class="headerlink" title="离线合批"></a>离线合批</h1><ul>
<li><p>离线合批就是在游戏运行前，先用工具把相关资源做合批处理，以减轻引擎实时合批的负担。</p>
</li>
<li><p>适合离线合批的是静态模型和场景物件。如场景地表装饰面：石头&#x2F;砖块等等。</p>
</li>
<li><p>离线合批方式有：</p>
</li>
</ul>
<ol>
<li><p>美术利用专业建模工具合批。如3D Max&#x2F;Maya等。</p>
</li>
<li><p>利用引擎插件或工具。如Unity的插件MeshBaker和DrawCallMinimizer，可以将静态物体进行合批。</p>
</li>
<li><p>自制离线合批工具。如果第三方插件无法满足项目需求，就要程序专门实现离线合批工具。</p>
</li>
</ol>
<h1 id="静态合批"><a href="#静态合批" class="headerlink" title="静态合批"></a>静态合批</h1><ul>
<li>要求</li>
</ul>
<ol>
<li>使用相同的材质</li>
<li>运行时不能移动，旋转或缩放</li>
</ol>
<ul>
<li>原理：</li>
</ul>
<ol>
<li>在<code>Build</code>的时候<code>Unity</code>会自动地提取这些相同材质的静态模型的<code>Vertex buffer</code>（一个顶点缓存是一个包含顶点数据的连续内存空间）和<code>Index buffer</code>（索引缓存，保存了构成物体的顶点在顶点缓存的索引值，通过索引查找对应的顶点，以完成图形的绘制）</li>
<li>根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下<br>，重新构建并存储在大的<code>Vertex buffer</code>和<code>Index buffer</code>中，并记录每一个子模型的<code>Index buffer</code>数据在构建的大<code>Index buffer</code>中的起始及结束位置</li>
<li>在后续的绘制过程中，一次性提交整个合并模型的顶点数据。根据引擎的场景管理系统判断各个子模型的可见性。然后<strong>设置一次渲染状态，调用多次<code>Draw call</code>分别绘制每一个子模型</strong><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9%E5%8E%9F%E7%90%861.png?raw=true"></li>
</ol>
<ul>
<li>索引缓存的好处</li>
</ul>
<ol>
<li>减少了顶点缓存的顶点个数（不需重复顶点）</li>
<li>灵活修改图形形状（通过修改索引序列而不是顶点序列）</li>
<li>提高渲染效率，<code>runtime</code>将多次用到的顶点数据放置在相近的地方<code>Cache</code>中（<code>local reference</code>）</li>
</ol>
<ul>
<li><p>推荐使用场景：场景中不会修改的静态建筑与植被</p>
</li>
<li><p>不适合的使用场景：大量重复出现的物体，如树</p>
</li>
<li><p><strong>静态合批并不减少<code>Draw call</code>的数量</strong>，但是由于预先把所有的子模型的顶点变换到了世界空间下，并且这些子模型共享材质，所以在<strong>多次<code>Draw call</code>调用之间并没有渲染状态的切换</strong>，渲染<code>API</code>会缓存绘制命令，起到了渲染优化的目的。即将多个符合条件的<code>Draw Call</code>合批，减少<code>Batch</code>，但不会减少<code>Draw call</code>的数量</p>
</li>
<li><p>静态合批采用了以空间换时间的策略来提升渲染效率</p>
</li>
<li><p>补充：</p>
</li>
</ul>
<ol>
<li>上述静态合批是按材质。在内置渲染管线中不支持静态合批（按着色器），在通用渲染管线中支持静态合批（按着色器）</li>
</ol>
<ul>
<li><p>静态合批需要<strong>手动</strong>设置哪些物体合批</p>
</li>
<li><p>与常规渲染的区别</p>
</li>
</ul>
<ol>
<li><p>在很多不同的<code>GameObject</code>引用同一模型的情况下，如果不开启<code>Static batching</code>，<code>GameObject</code>共享的模型会在应用程序包内或者内存中只存在一份，绘制的时候提交模型顶点信息，然后设置每一个<code>GameObject</code>的材质信息，分别调用渲染<code>API</code>绘制</p>
</li>
<li><p>开启<code>Static batching</code>，在<code>Unity</code>执行<code>Build</code>的时候，场景中所有引用相同模型的<code>GameObject</code>都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的<code>Vertex buffer</code>中。这就导致了打包的体积及运行时内存的占用增大</p>
</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"></p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>减少渲染状态的切换，提高性能</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>使用静态批处理需要额外的 <code>CPU</code> 内存来存储组合的几何体</li>
<li>打包之后体积增大，应用运行时所占用的内存体积也会增大</li>
<li>静态批处理可以包含的顶点数存在限制。每个静态批最多可以包含 <code>64000</code> 个顶点。如果有更多，<code>Unity</code> 会创建另一个批处理</li>
<li>如果多个<code>GameObject</code>在静态批处理之前共享相同的几何体，则会在编辑器或运行时为每个<code>GameObject</code>创建几何体的副本，这会增大内存的开销</li>
</ol>
<h1 id="动态合批"><a href="#动态合批" class="headerlink" title="动态合批"></a>动态合批</h1><ul>
<li>要求</li>
</ul>
<ol>
<li><code>Unity</code>无法将动态批处理应用于包含 <code>900</code> 个以上顶点属性和 <code>225</code> 个顶点的网格。这是因为网格的动态批处理每个顶点都有开销</li>
<li>如果游戏对象使用不同的材质实例，<code>Unity</code>无法将它们批量组合在一起，即使它们本质上是相同的。唯一的例外是阴影投射器渲染</li>
<li>具有光照贴图的游戏对象具有其他渲染器参数。这意味着，如果要批处理光照贴图游戏对象，它们必须指向相同的光照贴图位置</li>
<li><code>Unity</code>无法将动态批处理完全应用于使用多通道着色器的游戏对象</li>
</ol>
<ul>
<li>动态批处理是运行时生成的，即动态产生</li>
<li>原理</li>
</ul>
<ol>
<li>在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中</li>
<li>然后通过<strong>一次<code>Draw call</code>绘制多个模型</strong>，达到合批的目的</li>
</ol>
<ul>
<li><p>如果我们开启了<code>Dynamic batching</code>，<code>Unity</code>会<strong>自动</strong>地将所有共享同一材质的动态<code>GameObject</code>在一个<code>Draw call</code>内绘制，动态合批会减少<code>Draw call</code>数量</p>
</li>
<li><p>推荐使用场景：细碎的面数较少的多个动态对象</p>
</li>
<li><p><code>Unity</code>始终对动态几何体（如粒子系统）使用动态批处理</p>
</li>
<li><p>模型顶点变换的操作是由<code>CPU</code>完成的，每帧都会在<code>CPU</code>中将模型的顶点转换到世界坐标系，所以这会带来一些<code>CPU</code>的性能消耗</p>
</li>
<li><p>优点</p>
</li>
</ul>
<ol>
<li>可以对动态对象进行合批</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>对合批对象拥有较多的要求</li>
</ol>
<ul>
<li>动态合批与静态合批的区别：</li>
</ul>
<ol>
<li>动态合批不会创建常驻内存的“合并后网格”，也就是说它不会在运行时造成内存的显著增长，也不会影响打包时的包体大小</li>
<li>动态合批在绘制前会先将顶点转换到世界坐标系下，然后再填充进顶点、索引缓冲区；静态合批后子网格不接受任何变换操作，仅手动合批后的<code>Root</code>节点可被操作，因此静态合批的顶点、索引缓冲区中的信息不会被修改（<code>Root</code>的变换信息则会通过<code>Constant Buffer</code>传入）；</li>
<li>因为<code>2</code>的原因，动态合批的主要开销在于遍历顶点进行空间变换时的对<code>CPU</code>性能的开销；静态合批没有这个操作，所以也没有这个开销；</li>
<li>动态合批使用根据渲染器类型分配的公共缓冲区，而静态合批使用自己专用的缓冲区。</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E5%8A%A8%E6%80%81%E5%90%88%E6%89%B9%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"></p>
<h1 id="GPU-instancing"><a href="#GPU-instancing" class="headerlink" title="GPU instancing"></a>GPU instancing</h1><ul>
<li>要求</li>
</ul>
<ol>
<li>用于共享相同网格和材质的游戏对象</li>
<li>材料的着色必须支持 <code>GPU</code> 实例化</li>
<li>网格必须来自以下源之一，并按行为分组：1）<code>MeshRenderer</code> 组件或 <code>Graphics.RenderMesh</code> 调用；2）<code>Graphics.RenderMeshInstanced</code> 或 <code>Graphics.RenderMeshIndirect</code> 调用</li>
</ol>
<ul>
<li>原理：<strong>只提交一个<code>mesh</code>和材质，但是提交多个实例的差异化信息，对同一个<code>mesh</code>在<code>GPU</code>进行变换绘制</strong></li>
<li>推荐使用场景：草地</li>
<li>使用<code>GPU Instancing</code>可以一次渲染相同网格的多个副本。每次<code>draw call</code>，<code>GPU Instancing</code>只渲染相同的网格，但是每个实例可以有不同的参数(例如，<code>color</code>或<code>scale</code>)，以增加变化，减少重复的出现</li>
<li>单次最大处理数量：<code>1023</code>个对象</li>
<li><code>GPU instancing</code>渲染出来的对象在<code>Unity</code>中无法选择，因为它们并不是<code>GameObject</code>，通过<code>GPU Instancing</code> 批量渲染出来的实例在<code>Unity</code>场景中不会以<code>GameObject</code>的形式出现，它们存在在显存中，显示在屏幕上 </li>
<li>流程如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/GPU%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"></li>
</ul>
<h1 id="SRP-Batch（仅Unity-SRP管线）"><a href="#SRP-Batch（仅Unity-SRP管线）" class="headerlink" title="SRP Batch（仅Unity SRP管线）"></a>SRP Batch（仅Unity SRP管线）</h1><ul>
<li>原理：将数据<code>Buffer</code>拆分，通过降低对不需要更新的<code>Buffer</code>的更新频次来<strong>降低<code>Set Pass Call</code>的数量开销</strong>（即减少绘制调用之间的呈现状态更改），以进行加速，<strong>不会降低<code>Draw Call</code></strong></li>
<li>单次最大处理数量：无上限</li>
<li>推荐使用场景：所有着色器尽可能支持</li>
<li>不便性：</li>
</ul>
<ol>
<li>会影响<code>FrameDebugger</code>的查看</li>
<li>实际优化效果因使用环境差异导致效果并不一定明显</li>
<li><code>Buffer</code>不允许存在变体，参数数量上的灵活性降低</li>
</ol>
<ul>
<li><p><code>SRP Batch</code>流程图如下<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/SRPBatch%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E6%A0%87%E5%87%86%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8CSRP%20Batch%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94.jpg?raw=true"></p>
</li>
<li><p><code>SRP</code>批处理器是一个低级渲染循环，它使材质数据保留在 <code>GPU</code> 内存中。如果材质内容未更改，则 <code>SRP</code> 批处理程序不会进行任何呈现状态更改。相反，<code>SRP</code> 批处理程序使用专用代码路径来更新大型 <code>GPU</code> 缓冲区中的 <code>Unity</code> 引擎属性，如下图所示<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/SRP%20Batch%E5%85%A8%E5%9B%BE.jpg?raw=true"></p>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>各种批处理对比<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/DrawCall/%E5%90%84%E7%A7%8D%E6%89%B9%E5%A4%84%E7%90%86%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94.png?raw=true"></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://gameinstitute.qq.com/community/detail/114323">图形渲染及优化—Unity合批技术实践</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/113040">图形渲染及优化—Batch</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/124856">Unity性能优化-图形渲染优化</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/100750">[Unity3D]图形渲染优化、渲染管线优化、图形性能优化</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/352715430">Unity基础：DrawCall从入门到精通</a></li>
<li><a href="http://imgtec.eetrend.com/blog/2019/100045691.html">什么是Draw Call？为什么Draw Call 多了会影响帧率？</a></li>
<li><a href="https://blog.uwa4d.com/archives/allinone.html">Unity性能优化大合集，All In One !（更新至8.18）</a></li>
<li><a href="https://blog.csdn.net/sinat_25970377/article/details/113938133">Unity 性能优化，DrawCall、渲染顺序、打包图集、特效清理、代码优化</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/356211912#:~:text=%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9%E6%98%AF%E5%8B%BE%E9%80%89S,%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%82">【Unity游戏开发】静态、动态合批与GPU Instancing</a></li>
<li><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/DrawCallBatching.html">Unity手册 - Draw call batching</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/350207301">【Unity】批次合并理解和对比</a></li>
<li><a href="https://www.bilibili.com/video/BV1ae4y1X76V?p=2&spm_id_from=pageDriver&vd_source=d2d44d4ce8893453aa70df7d2d5f6651">【百人计划】图形 5.8 合批原理讲解</a></li>
<li><a href="https://docs.unity.cn/2021.3/Documentation/Manual/GPUInstancing.html">Unity手册 - GPU instancing</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/70123645">GPU instancing</a></li>
<li><a href="https://docs.unity.cn/2021.3/Documentation/Manual/SRPBatcher.html">Unity手册 - SRPBatcher</a></li>
<li><a href="https://www.cnblogs.com/cancantrbl/p/16048341.html">合批是什么？为什么可以减少Drawcall？有什么合批方法？</a></li>
<li><a href="https://cirnoo.github.io/2019/07/22/CreateVertexBuffer/">顶点缓存与索引缓存</a></li>
<li><a href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-builtin-feature-comparison.html">Unity 手册 - URP与内置渲染管线的功能比较</a></li>
</ul>
]]></content>
      <categories>
        <category>渲染</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 内存管理及GC</title>
    <url>/2022/07/29/Unity%20-%20GC/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>在游戏运行的时候，数据主要存储在内存中，当游戏的数据在不需要的时候，存储当前数据的内存就可以被回收以再次使用。内存垃圾是指当前废弃数据所占用的内存。垃圾回收（<code>GC</code>）是指将废弃的内存（内存垃圾）重新回收再次使用的过程</li>
<li><code>Unity</code>主要采用自动内存管理的机制，可以理解为以下几个部分</li>
</ul>
<ol>
<li><p><code>Unity</code>内部有两个内存管理池：堆内存和栈内存。栈内存(<code>stack</code>)主要用来存储较小的和短暂的数据，堆内存(<code>heap</code>)主要用来存储较大的和存储时间较长的数据</p>
</li>
<li><p><code>Unity</code>中的变量只会在栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。(值类型分配在栈上，引用内存分配在堆上）</p>
</li>
<li><p>只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态</p>
</li>
<li><p>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收极其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态</p>
</li>
<li><p>垃圾回收主要是指堆上的内存分配和回收，<code>Unity</code>中会定时对堆内存进行<code>GC</code>操作</p>
</li>
</ol>
<ul>
<li>堆和栈中主要放置了四种类型的数据</li>
</ul>
<ol>
<li>值类型（<code>Value Type</code>）。例如：<code>bool</code>、<code>byte</code>、<code>char</code>、<code>decimal</code>、<code>double</code>、<code>enum</code>、<code>float</code>、<code>int</code>、<code>long</code>、<code>sbyte</code>、<code>struct</code>、<code>unit</code>、<code>ulong</code>、<code>ushort</code>等</li>
<li>引用类型（<code>Reference Type</code>）。例如：<code>class</code>、<code>interface</code>、<code>delegate</code>、<code>object</code>、<code>string</code>、<code>StringBuilder</code>等</li>
<li>指针（<code>Pointer</code>）</li>
<li>指令（<code>Instruction</code>）</li>
</ol>
<h1 id="Unity-内存管理层"><a href="#Unity-内存管理层" class="headerlink" title="Unity 内存管理层"></a>Unity 内存管理层</h1><ul>
<li><code>Unity</code> 使用三个内存管理层来处理应用程序中的内存</li>
</ul>
<ol>
<li><strong>托管内存</strong>（<code>Managed memory</code>）：使用托管堆和垃圾回收器自动分配内存的受控内存层</li>
<li><strong><code>C#</code> 非托管内存</strong>（<code>C# unmanaged memory</code>）：可以与 <code>Unity Collections</code> 命名空间和包一起使用的内存管理层。这种内存类型被称为“非托管”，因为它不使用垃圾回收器来管理未使用的内存部分</li>
<li><strong>本机内存</strong>（<code>Native memory</code>）：<code>Unity</code> 用于运行引擎的<code>C++</code> 内存。在大多数情况下，<code>Unity</code> 用户无法访问此内存，但如果想微调应用程序性能的某些方面，了解它会很有用</li>
</ol>
<ul>
<li>托管内存<br><code>Mono</code> 和 <code>IL2CPP</code> 的脚本虚拟机 (<code>VM</code>) 实现托管内存系统，有时也称为脚本内存系统。 这些 <code>VM</code> 提供受控的内存环境，分为以下不同类型：</li>
</ul>
<ol>
<li>托管堆：<code>VM</code> 使用垃圾收集器 (<code>GC</code>) 自动控制的内存部分。 因此，在托管堆上分配的内存称为 <code>GC</code> 分配。 <code>Profiler</code> 将此类分配的任何发生记录为 <code>GC.Alloc</code> 样本</li>
<li>脚本堆栈：当您的应用程序进入和退出任何代码范围时，它会被构建和展开</li>
<li>本机 <code>VM</code> 内存：包含与 <code>Unity</code> 脚本层相关的内存。大多数情况下，您不需要操作本机 <code>VM</code> 内存，但知道它包含与您的代码生成的可执行代码相关的内存很有用，特别是在使用泛型时，类型元数据反射使用 ，以及运行 <code>VM</code> 所需的内存</li>
</ol>
<ul>
<li><code>C#</code> 非托管内存</li>
</ul>
<ol>
<li><code>C#</code>非托管内存层允许您访问本机内存层以微调内存分配，并方便编写 <code>C#</code> 代码</li>
</ol>
<ul>
<li>本机内存</li>
</ul>
<ol>
<li><code>Unity</code> 引擎的内部 <code>C/C++</code> 内核有自己的内存管理系统，称为本机内存。 在大多数情况下，不能直接访问或修改此内存类型</li>
</ol>
<h1 id="Unity-动态加载资源方式"><a href="#Unity-动态加载资源方式" class="headerlink" title="Unity 动态加载资源方式"></a>Unity 动态加载资源方式</h1><ul>
<li><code>Unity</code> 里有两种动态加载机制：一个是<code>Resources.Load</code>，另外一个通过<code>AssetBundle</code>,其实两者区别不大。<code>Resources.Load</code>就是从一个缺省打进程序包里的<code>AssetBundle</code>里加载资源，而一般<code>AssetBundle</code>文件需要你自己创建，运行时动态加载，可以指定路径和来源的</li>
<li><code>AssetBundle</code>运行时加载：<code>AssetBundle.LoadFromFile</code>或<code>AssetBundle.LoadFromFileAsync</code></li>
<li><code>Asset</code>加载：<code>Asset</code>加载会从<code>AssetBundle</code>的内存镜像里读取并创建一个<code>Asset</code>对象并分配相应内存用于存放（反序列化）。使用<code>AssetBundle.LoadAsset</code>或<code>AssetBundle.LoadAssetAsync</code></li>
<li><code>AssetBundle</code>的释放</li>
</ul>
<ol>
<li><code>AssetBundle.Unload(flase)</code>是只释放 <code>AssetBundle</code> 文件的内存镜像，不包含<code>Load</code>创建的<code>Asset</code>内存对象</li>
<li><code>AssetBundle.Unload(true)</code>是释放某个<code>AssetBundle</code> 文件内存镜像并销毁所有用<code>Load</code>创建的<code>Asset</code>内存对象</li>
</ol>
<ul>
<li>总结各种加载和初始化</li>
</ul>
<ol>
<li><code>AssetBundle.LoadFrom...</code>：创建一个<code>AssetBundle</code>内存镜像，注意同一个<code>AssetBundle</code>文件在没有<code>Unload</code>之前不能再次被使用</li>
<li><code>AssetBundle.Load...</code>：从<code>AssetBundle</code>读取一个<code>Asset</code>并生成<code>Asset</code>内存对象</li>
<li><code>Resources.Load</code>：同上,只是从默认的位置加载</li>
<li><code>Instantiate</code>：<code>Clone</code>一个<code>object</code>的完整结构，包括其所有<code>Component</code>和子物体，浅<code>Copy</code>，并不复制所有引用类型</li>
</ol>
<ul>
<li>总结各种释放</li>
</ul>
<ol>
<li><code>Destroy</code>：主要用于销毁克隆对象，也可以用于场景内的静态物体，不会自动释放该对象的所有引用。虽然也可以用于<code>Asset</code>,但是概念不一样要小心，如果用于销毁从文件加载的<code>Asset</code>对象会销毁相应的资源文件！但是如果销毁的<code>Asset</code>是<code>Copy</code>的或者用脚本动态生成的，只会销毁内存对象</li>
<li><code>AssetBundle.Unload(false)</code>：释放<code>AssetBundle</code>文件内存镜像</li>
<li><code>AssetBundle.Unload(true)</code>：释放<code>AssetBundle</code>文件内存镜像同时销毁所有已经<code>Load</code>的<code>Assets</code>内存对象</li>
<li><code>Reources.UnloadAsset(Object)</code>：显式的释放已加载的<code>Asset</code>对象，只能卸载磁盘文件加载的<code>Asset</code>对象</li>
<li><code>Resources.UnloadUnusedAssets()</code>：用于释放所有没有引用的<code>Asset</code>对象</li>
<li><code>GC.Collect()</code>：强制垃圾收集器立即释放内存<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/Untiy%20-%20GC/Asset%E5%86%85%E5%AD%98%E5%9B%BE.jpg?raw=true"></li>
</ol>
<h1 id="垃圾回收器模式"><a href="#垃圾回收器模式" class="headerlink" title="垃圾回收器模式"></a>垃圾回收器模式</h1><ul>
<li><code>Unity</code> 使用垃圾回收器<code>（Garbage collector）</code>从您的应用程序和 <code>Unity</code> 不再使用的对象中回收内存</li>
<li>垃圾收集器是非压缩的，这意味着 <code>Unity</code> 不会重新分配内存中的任何对象以缩小对象之间的间隙</li>
<li>在 <code>Unity</code> 中，垃圾回收器具有以下模式</li>
</ul>
<ol>
<li>增量垃圾回收：默认情况下启用，此模式将垃圾回收过程分散到多个帧上。<code>WebGL</code>平台不支持增量垃圾回收</li>
<li>已禁用增量垃圾回收：如果禁用增量 <code>GC</code> 播放器设置，垃圾回收器将停止运行应用程序（停止主 <code>CPU</code> 线程）以检查和处理堆上的对象，它只有在处理完托管堆上的所有对象后才会恢复执行，这可能会导致 <code>GC</code> 峰值影响应用程序的性能</li>
<li>禁用自动垃圾回收：使用 <code>GarbageCollector.GCMode API</code> 完全控制 <code>Unity</code> 何时应运行垃圾回收器</li>
</ol>
<h1 id="栈内存分配和回收机制"><a href="#栈内存分配和回收机制" class="headerlink" title="栈内存分配和回收机制"></a>栈内存分配和回收机制</h1><ul>
<li><p>栈上的内存分配和回收十分快捷简单，因为栈上只会存储短暂的或者较小的变量。内存分配和回收都会以一种顺序和大小可控制的形式进行</p>
</li>
<li><p>栈的运行方式就像<code>stack</code>: 其本质只是一个数据的集合，数据的进出都以一种固定的方式运行。正是这种简洁性和固定性使得栈的操作十分快捷。当数据被存储在栈上的时候，只需要简单地在其后进行扩展。当数据失效的时候，只需要将其从栈上移除</p>
</li>
</ul>
<h1 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h1><ul>
<li>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</li>
<li>堆上的变量在存储的时候，主要分为以下几步</li>
</ul>
<ol>
<li><p>首先，<code>Unity</code>检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应大小的内存单元；</p>
</li>
<li><p>如果没有足够的存储单元，<code>Unity</code>会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够大小的内存单元，则进行内存分配。</p>
</li>
<li><p>如果垃圾回收后并没有足够的内存单元，则<code>Unity</code>会扩展堆内存的大小，这步操作会很缓慢，然后分配对应大小的内存单元给变量。</p>
</li>
</ol>
<ul>
<li>堆内存的分配有可能会变得十分缓慢，特别是在需要垃圾回收和堆内存需要扩展的情况下，通常需要减少这样的操作次数。</li>
</ul>
<h1 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h1><ul>
<li><p>当堆内存上一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在<code>GC</code>的时候才会被回收。</p>
</li>
<li><p>每次运行<code>GC</code>的时候，主要进行下面的操作：</p>
</li>
</ul>
<ol>
<li><p><code>GC</code>会检查堆内存上的每个存储变量；</p>
</li>
<li><p>对每个变量会检测其引用是否处于激活状态；</p>
</li>
<li><p>如果变量的引用不再处于激活状态，则会被标记为可回收；</p>
</li>
<li><p>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</p>
</li>
</ol>
<ul>
<li><code>GC</code>操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</li>
</ul>
<h1 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h1><ul>
<li>主要有三个操作会触发垃圾回收：</li>
</ul>
<ol>
<li><p>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</p>
</li>
<li><p><code>GC</code>会自动的触发，不同平台运行频率不一样</p>
</li>
<li><p><code>GC</code>可以被强制执行</p>
</li>
</ol>
<ul>
<li>特别是在堆内存上进行内存分配时内存单元不足够的时候，<code>GC</code>会被频繁触发，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的<code>GC</code>操作</li>
</ul>
<h1 id="GC操作带来的问题"><a href="#GC操作带来的问题" class="headerlink" title="GC操作带来的问题"></a><code>GC</code>操作带来的问题</h1><ul>
<li><p>最明显的问题是<code>GC</code>操作会<strong>需要大量的时间来运行</strong>。如果堆内存上有大量的变量或者引用需要检查，则检查的操作会十分缓慢，这就会使得游戏运行缓慢。其次<code>GC</code>可能会在关键时候运行，例如在<code>CPU</code>处于游戏的性能运行关键时刻，此时任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降</p>
</li>
<li><p>另外一个<code>GC</code>带来的问题是<strong>堆内存的碎片化</strong>。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存被分割成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是单独的内存单元较小，在下次内存分配的时候不能找到合适大小的存储单元，这也会触发<code>GC</code>操作或者堆内存扩展操作</p>
</li>
<li><p>堆内存碎片会造成两个结果，一个是游戏占用的内存会越来越大，一个是<code>GC</code>会更加频繁地被触发</p>
</li>
</ul>
<h1 id="分析堆内存的分配"><a href="#分析堆内存的分配" class="headerlink" title="分析堆内存的分配"></a>分析堆内存的分配</h1><ul>
<li><p>下面的代码可以用来理解值类型的分配和释放,其对应的变量在函数调用完后会立即回收</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> localInt = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应的引用类型的参考代码如下，其对应的变量在<code>GC</code>的时候才回收</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List localList = <span class="keyword">new</span> List();</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>profiler</code>来检测堆内存分配：我们可以在<code>profier</code>中检查堆内存的分配操作：在<code>CPU usage</code>分析窗口中，我们可以检测任何一帧<code>cpu</code>的内存分配情况。其中一个选项是<code>GC Alloc</code>，通过分析其来定位是什么函数造成大量的堆内存分配操作。一旦定位该函数，我们就可以分析解决其造成问题的原因从而减少内存垃圾的产生</p>
</li>
</ul>
<h1 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a>降低<code>GC</code>的影响的方法</h1><ul>
<li>大体上来说，可以通过三种方法来降低<code>GC</code>的影响：</li>
</ul>
<ol>
<li><p>减少<code>GC</code>的运行次数</p>
</li>
<li><p>减少单次<code>GC</code>的运行时间</p>
</li>
<li><p>将<code>GC</code>的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用<code>GC</code></p>
</li>
</ol>
<ul>
<li>基于此，我们可以采用三种策略</li>
</ul>
<ol>
<li><p>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少<code>GC</code>操作中的检测个数从而提高<code>GC</code>的运行效率</p>
</li>
<li><p>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发<code>GC</code>操作，同时也降低堆内存的碎片化</p>
</li>
<li><p>我们可以试着测量<code>GC</code>和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低<code>GC</code>的影响</p>
</li>
</ol>
<h1 id="减少内存垃圾的数量"><a href="#减少内存垃圾的数量" class="headerlink" title="减少内存垃圾的数量"></a>减少内存垃圾的数量</h1><ul>
<li>减少内存垃圾主要可以通过一些方法来减少：</li>
</ul>
<ol>
<li>缓存</li>
</ol>
<p>如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存</p>
<ol start="2">
<li>不要在频繁调用的函数中反复进行堆内存分配</li>
</ol>
<p>在<code>MonoBehaviour</code>中，如果我们需要进行堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如<code>Update()</code>和<code>LateUpdate()</code>函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们可以考虑在<code>Start()</code>或者<code>Awake()</code>函数中进行内存分配，这样可以减少内存垃圾</p>
<ol start="3">
<li>清除链表</li>
</ol>
<p>在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的<code>clear</code>函数来清空链表从而替代反复多次的创建分配链表</p>
<ol start="4">
<li>对象池</li>
</ol>
<p>即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁依然会造成<code>GC</code>。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹这种会频繁生成和销毁的对象</p>
<h1 id="造成不必要的堆内存分配的因素"><a href="#造成不必要的堆内存分配的因素" class="headerlink" title="造成不必要的堆内存分配的因素"></a>造成不必要的堆内存分配的因素</h1><ol>
<li>字符串</li>
</ol>
<p><strong>在<code>C#</code>中，字符串是引用类型变量</strong>而不是值类型变量，即使看起来它是存储字符串的值的。这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。</p>
<p><code>C#</code>中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），<code>Unity</code>会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。</p>
<p>我们可以采用以下的一些方法来最小化字符串的影响：减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p>
<ul>
<li><p>减少不必要的字符串操作，例如如果在<code>Text</code>组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件，对于不变的部分就设置为类似常量字符串即可，见下面的例子。</p>
</li>
<li><p>如果我们需要实时的创建字符串，我们可以采用<code>StringBuilderClass</code>来代替，<code>StringBuilder</code>专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p>
</li>
<li><p>移除游戏中的<code>Debug.Log()</code>函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p>
</li>
</ul>
<ol start="2">
<li><code>Unity</code>函数调用</li>
</ol>
<p>在代码编程中，当我们调用不是我们自己编写的代码，无论是<code>Unity</code>自带的还是插件中的，我们都可能会产生内存垃圾。<code>Unity</code>的某些函数调用会产生内存垃圾，我们在使用的时候需要注意它的使用。</p>
<p>这儿没有明确的列表指出哪些函数需要注意，每个函数在不同的情况下有不同的使用，所以最好仔细地分析游戏，定位内存垃圾的产生原因以及如何解决问题。有时候缓存是一种有效的办法，有时候尽量降低函数的调用频率是一种办法，有时候用其他函数来重构代码是一种办法。</p>
<ol start="3">
<li>装箱操作</li>
</ol>
<p><strong>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程</strong>，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如<code>String.Format()</code>函数需要传入字符串和对象类型参数，如果传入字符串和<code>int</code>类型数据，就会触发装箱操作。</p>
<p>在<code>Unity</code>的装箱操作中，对于值类型会在堆内存上分配一个<code>System.Object</code>类型的引用来封装该值类型变量，其对应的缓存就会产生内存垃圾。装箱操作是非常普遍的一种产生内存垃圾的行为，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。</p>
<ol start="4">
<li>协程</li>
</ol>
<p>调用 <code>StartCoroutine()</code>会产生少量的内存垃圾，因为<code>Unity</code>会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用。基于此，任何在游戏关键时刻调用的协程都需要特别的注意，特别是包含延迟回调的协程。</p>
<p>如果游戏中的协程产生了内存垃圾，我们可以考虑用其他的方式来替代协程。重构代码对于游戏而言十分复杂，但是对于协程而言我们也可以注意一些常见的操作，比如如果用协程来管理时间，最好在<code>update</code>函数中保持对时间的记录。如果用协程来控制游戏中事件的发生顺序，最好对于不同事件之间有一定的信息通信的方式。对于协程而言没有适合各种情况的方法，只有根据具体的代码来选择最好的解决办法。</p>
<ol start="5">
<li>函数引用</li>
</ol>
<p>函数的引用，无论是指向匿名函数还是显式函数，在<code>Unity</code>中都是引用类型变量，这都会在堆内存上进行分配。匿名函数的调用完成后都会增加内存的使用和堆内存的分配。具体函数的引用和终止都取决于操作平台和编译器设置，但是如果想减少<code>GC</code>最好减少函数的引用。</p>
<ol start="6">
<li><code>LINQ</code>和常量表达式</li>
</ol>
<p>由于<code>LINQ</code>和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试。</p>
<h1 id="重构代码来减小GC的影响"><a href="#重构代码来减小GC的影响" class="headerlink" title="重构代码来减小GC的影响"></a>重构代码来减小<code>GC</code>的影响</h1><ul>
<li>即使我们减小了代码在堆内存上的分配操作，代码也会增加<code>GC</code>的工作量。最常见的增加<code>GC</code>工作量的方式是让其检查它不必检查的对象。<code>struct</code>是值类型的变量，但是如果<code>struct</code>中包含有引用类型的变量，那么<code>GC</code>就必须检测整个<code>struct</code>。如果这样的操作很多，那么<code>GC</code>的工作量就大大增加</li>
</ul>
<h1 id="定时执行GC操作"><a href="#定时执行GC操作" class="headerlink" title="定时执行GC操作"></a>定时执行<code>GC</code>操作</h1><ul>
<li>主动调用GC操作</li>
</ul>
<p>如果我们知道堆内存在被分配后并没有被使用，我们希望可以主动地调用<code>GC</code>操作，或者在<code>GC</code>操作并不影响游戏体验的时候（例如场景切换的时候），我们可以主动的调用<code>GC</code>操作：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.GC.Collect();</span><br></pre></td></tr></table></figure>

<p>通过主动的调用，我们可以主动驱使<code>GC</code>操作来回收堆内存</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/cc64c7f8e171">Unity3D中的GC回收机制</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/125199">Unity GC优化学习（一）：认识堆(heap)&amp;栈(stack)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/336004123">关于Unity内存管理资源卸载加载之最详细解说没有之一</a></li>
<li><a href="https://www.bilibili.com/video/BV1aJ411t7N6?vd_source=d2d44d4ce8893453aa70df7d2d5f6651">[Unity 活动]-浅谈Unity内存管理</a></li>
<li><a href="https://learn.unity.com/tutorial/memory-management-in-unity?tab=overview&uv=2018.1#">Memory Management in Unity</a></li>
<li><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/performance-memory-overview.html">Unity手册 - Memory in Unity</a></li>
<li><a href="https://blog.csdn.net/wangjiangrong/article/details/108539554">Unity内存管理</a></li>
<li><a href="https://huailiang.github.io/blog/2019/asset/">Unity资源管理机制</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/370467923">Unity游戏内存分布概览</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/381859536">【笔记】Unity内存分配和回收的底层原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/362941227">Unity的内存管理与性能优化</a></li>
<li><a href="https://www.bilibili.com/read/cv3260881">Unity2019新特性增量式垃圾回收[译文]</a></li>
<li><a href="https://www.notion.so/Unity-f79bb1d4ccfc483fbd8f8eb859ae55fe">浅谈 Unity 内存管理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41398507">解读MONO内存管理：BOEHM GC原理及总结</a></li>
<li><a href="https://www.jianshu.com/p/ceb5e9fd607e">C#中的变量存储</a></li>
<li><a href="https://learn.unity.com/tutorial/fixing-performance-problems-2019-3#604587c4edbc2a3080149544">Unity课堂 - 修复性能问题 - 2019.3</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135192859">【Unity游戏开发】AB学习(三)加载和实例化的内存变化</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Lua</title>
    <url>/2022/11/07/Lua/</url>
    <content><![CDATA[<h1 id="全局函数和局部函数的区别"><a href="#全局函数和局部函数的区别" class="headerlink" title="全局函数和局部函数的区别"></a>全局函数和局部函数的区别</h1><ol>
<li>使用<code>function</code>声明的函数为全局函数，在被引用时可以不会因为声明的顺序而找不到</li>
<li>使用<code>local function</code>声明的函数为局部函数，在引用的时候必须要在声明的函数后面</li>
</ol>
<h1 id="Lua查找一个表元素的规则可以归纳为如下几个步骤："><a href="#Lua查找一个表元素的规则可以归纳为如下几个步骤：" class="headerlink" title="Lua查找一个表元素的规则可以归纳为如下几个步骤："></a>Lua查找一个表元素的规则可以归纳为如下几个步骤：</h1><ol>
<li>在表自身中查找，如果找到了就返回该元素，如果没找到则执行Step2；</li>
<li>判断该表是否有元表（操作指南），如果没有元表，则直接返回nil，如果有元表则继续执行Step3；</li>
<li>判断元表是否设置了有关索引失败的指南（__index元方法），如果没有(__index为nil)，则直接返回nil；如果有__index方法是一张表，则重复执行Step1-&gt;Step2-&gt;Step3；如果__index方法是一个函数，则返回该函数的返回值</li>
</ol>
<h1 id="self"><a href="#self" class="headerlink" title="self"></a>self</h1><p>有以下两种情况</p>
<ul>
<li>在冒号定义函数中<code>self</code>作为第一个参数，并指向函数所属表对象</li>
<li>自定义参数名为<code>self</code></li>
</ul>
<h1 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h1><ul>
<li>冒号定义函数：<strong>会将函数中的<code>self</code>指向函数所属表对象，并将<code>self</code>作为第一个形参</strong></li>
<li>点定义的函数：<strong>不会定义<code>self</code>，不会做任何事情</strong>，不像冒号定义函数那样可以<code>self</code>指向函数所属对象</li>
<li>点调用冒号定义函数：点调用冒号定义函数，第一个参数传递给<code>self</code>，调用无参时，<code>self=nil</code>。<strong>需要自已传参给冒号定义函数中的第一个参数<code>self</code>，否则<code>self=nil</code></strong></li>
<li>冒号调用点定义函数：冒号调用点定义函数，调用者对象表传递给点定义函数的第一个参数，点定义函数内部<code>self=nil</code>。<strong>需要让点定义函数至少有一个参数(名字不只限定<code>self</code>)用来接受冒号调用时默认将自已作为第一个参数的容器</strong></li>
</ul>
<h1 id="ipairs和pairs的异同"><a href="#ipairs和pairs的异同" class="headerlink" title="ipairs和pairs的异同"></a>ipairs和pairs的异同</h1><ul>
<li>相同点</li>
</ul>
<ol>
<li>都是能遍历集合（表、数组）</li>
</ol>
<ul>
<li>不同点</li>
</ul>
<ol>
<li><strong><code>ipairs</code>仅仅遍历值，按照索引升序遍历，索引中断停止遍历</strong>。即<strong>不能返回<code>nil</code><strong>，索引从<code>1</code>开始，只能返回数字<code>0</code>，</strong>如果遇到<code>nil</code>则退出</strong>。它只能遍历到集合中出现的第一个不是整数的<code>key</code></li>
<li><strong><code>pairs</code>能遍历集合的所有元素</strong>。即<code>pairs</code>可以遍历集合中所有的 <code>key</code>，并且除了迭代器本身以及遍历表本身还<strong>可以返回<code>nil</code></strong></li>
</ol>
<h1 id="index、-newindex"><a href="#index、-newindex" class="headerlink" title="__index、__newindex"></a>__index、__newindex</h1><ul>
<li>__index是针对访问值的操作</li>
<li>__newindex是针对设置值的操作，对表中不存在的值进行赋值的话，<strong>不会对本表进行新建值</strong>，有两种情况：</li>
</ul>
<ol>
<li>如果指向一个表，则在那个表中添加这个值</li>
<li>如果指向一个函数，则在那个函数所属的表中添加这个值的同时，执行这个函数</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Person=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;asd&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Man=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(Man,Person)</span><br><span class="line">Person.<span class="built_in">__newindex</span> = Person:test()</span><br><span class="line">Man.a=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--asd</span></span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(Man.a)</span><br><span class="line"><span class="comment">--nil</span></span><br><span class="line"><span class="built_in">print</span>(Person.a)</span><br></pre></td></tr></table></figure>

<h1 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h1><ul>
<li>Lua 中有 8 个基本类型分别为：</li>
</ul>
<ol>
<li>nil。只有值nil属于该类，表示一个无效值</li>
<li>boolean。包含两个值：false和true</li>
<li>number。表示双精度类型的实浮点数</li>
<li>string。字符串由一对双引号或单引号来表示</li>
<li>userdata。表示任意存储在变量中的C数据结构</li>
<li>function。由 C 或 Lua 编写的函数</li>
<li>thread。表示执行的独立线路，用于执行协同程序</li>
<li>table。Lua中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。</li>
</ol>
<h1 id="Lua元方法"><a href="#Lua元方法" class="headerlink" title="Lua元方法"></a>Lua元方法</h1><ul>
<li>Lua 提供了元表(Metatable)，允许我们改变 table 的行为，每个行为关联了对应的元方法</li>
<li>有如下：</li>
</ul>
<ol>
<li>__index</li>
<li>__newindex</li>
<li>__tostring。用于修改表的输出行为</li>
<li>__call。在 Lua 调用一个值时调用</li>
</ol>
<h1 id="Lua怎么实现面向对象"><a href="#Lua怎么实现面向对象" class="headerlink" title="Lua怎么实现面向对象"></a>Lua怎么实现面向对象</h1><ul>
<li><p>面对对象是基于**元表<code>metatable</code><strong>，</strong>元方法<code>__index</code>**来实现的。如果访问了<code>lua</code>表中不存在的元素时，就会触发<code>lua</code>的一套查找机制，也是凭借这个机制，才能够实现面向对象的</p>
</li>
<li><p>元表（<code>metatable</code>）：<strong>允许我们改变<code>table</code>的行为，每个行为关联了对应的元方法</strong>。例如，当<code>Lua</code>试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫<code>__add</code>的字段，若找到，则调用对应的值</p>
</li>
<li><p>元方法（<code>__index</code>）：当通过键来访问<code>table</code>的时候，<strong>如果这个键没有值，那么<code>Lua</code>就会寻找该<code>table</code>的<code>metatable</code>（假定有<code>metatable</code>）中的<code>__index</code>键</strong>。如果<code>__index</code>包含一个表格，<code>Lua</code>会在表格中查找相应的键</p>
</li>
</ul>
<h1 id="Lua面向对象之封装"><a href="#Lua面向对象之封装" class="headerlink" title="Lua面向对象之封装"></a>Lua面向对象之封装</h1><ul>
<li>在<code>Lua</code>中的类，其实都是<code>table</code>，因为<code>table</code> **既可以存储普通变量又可以存储函数或者另一个<code>table</code>**，利用这个特性，我们实现了面向对象的类中的方法、属性（字段）和构造方法</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Class.lua</span></span><br><span class="line">Class = &#123;x=<span class="number">0</span>,y=<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">Class.<span class="built_in">__index</span> = Class</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class:new</span><span class="params">(x,y)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(t,Class)</span><br><span class="line">    t.x = x</span><br><span class="line">    t.y = y</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="Lua面向对象之继承"><a href="#Lua面向对象之继承" class="headerlink" title="Lua面向对象之继承"></a>Lua面向对象之继承</h1><ul>
<li><strong>利用元表和<code>__index</code>模拟继承关系</strong>。设子表的元表为父类，父类的<code>__index</code>为父类自已，当子类查找不上属性和方法时，会查找元表中的<code>__index</code>中的内容，通过这种方式来模拟继承</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&#x27;Class&#x27;</span></span><br><span class="line"></span><br><span class="line">SubClass = &#123;z = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(SubClass, Class)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass:new</span><span class="params">(x,y,z)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">    t = Class:new(x,y)</span><br><span class="line">    <span class="built_in">setmetatable</span>(t,SubClass)</span><br><span class="line">    t.z = z</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h1 id="Lua面向对象之多态"><a href="#Lua面向对象之多态" class="headerlink" title="Lua面向对象之多态"></a>Lua面向对象之多态</h1><ul>
<li>由于<code>__index</code>的查找特性，<strong>实例会在自己的<code>__index</code>中查找属性和方法，找到即可调用，不会再继续去父类中查找，即实现了函数覆盖</strong>（<code>C++</code>覆盖定义：总与多态绑定在一起，覆盖发生在派生类与基类之间，两个函数必须完全相同，且都是虚函数）功能，即多态</li>
<li>子类自已实现带<code>:</code>的同名方法</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Lua闭包"><a href="#Lua闭包" class="headerlink" title="Lua闭包"></a>Lua闭包</h1><ul>
<li>词法定界：当一个函数内嵌套另一个函数的时候，内函数可以访问外部函数的局部变量，这种特征叫做词法定界</li>
<li><code>upvalue</code>：内嵌函数可以访问外部函数已经创建的局部变量，而这些局部变量则称为该内嵌函数的外部局部变量（即<code>upvalue</code>）</li>
<li><strong><code>Lua</code>闭包：调用访问外函数中的局部变量的内函数，导致该局部变量的生命周期发生改变（延长）</strong></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        a = a + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">make = test()   <span class="comment">--0</span></span><br><span class="line">make()  <span class="comment">--1</span></span><br><span class="line">make()  <span class="comment">--2</span></span><br><span class="line">make()  <span class="comment">--3</span></span><br><span class="line">test()  <span class="comment">--0</span></span><br></pre></td></tr></table></figure>

<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul>
<li>关键字：<code>collectgarbage</code></li>
<li>命令</li>
</ul>
<ol>
<li><code>count</code>：获取内存数</li>
<li><code>collect</code>：进行一次完整的垃圾回收<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 垃圾回收关键字</span></span><br><span class="line"><span class="comment">-- collectgarbage</span></span><br><span class="line"><span class="comment">-- 获取当前lua占用内存数k字节用返回值*1024，就可以得到具体的内存占用内存</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>)) <span class="comment">--21.0078125</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--垃圾回收</span></span><br><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>)) <span class="comment">--20.9453125</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua中有自动进行GC的方法</span></span><br><span class="line"><span class="comment">-- Unity中热更新性能开发，尽量不要去用自动垃圾回收</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--三种多行注释</span></span><br><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> </span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>简单变量类型：<code>nil</code>、<code>number</code>、<code>string</code>、<code>boolean</code></li>
<li>复杂变量类型：函数<code>function</code>、表<code>table</code>、数据结构<code>userdata</code>、协同程序<code>thread</code>（线程）</li>
<li><code>lua</code>所有的变量声明都不需要声明变量类型，会自动识别类型</li>
<li>通过<code>type</code>函数可以获取变量的类型</li>
<li><code>lua</code>使用没声明过的变量不会报错，默认值是<code>nil</code></li>
</ul>
<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取字符串长度</span></span><br><span class="line">s =<span class="string">&quot;a我&quot;</span></span><br><span class="line"><span class="comment">-- 一个英文字符占1个长度</span></span><br><span class="line"><span class="comment">-- 一个汉字占3个长度</span></span><br><span class="line"><span class="built_in">print</span>(#s) <span class="comment">--4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转移字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123\n123&quot;</span>) <span class="comment">--123 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 支持多行输出</span></span><br><span class="line">s = <span class="string">[[我</span></span><br><span class="line"><span class="string">是</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="comment">--[[输出：</span></span><br><span class="line"><span class="comment">我</span></span><br><span class="line"><span class="comment">是</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串拼接 ..和string.format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span> .. <span class="string">&quot;123&quot;</span>) <span class="comment">--123123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;我%d&quot;</span>,<span class="number">18</span>)) <span class="comment">-- 我18</span></span><br><span class="line"><span class="comment">--%d：与数字拼接 %a：与任何字符拼接 %s：与字符拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他类型转字符串</span></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(a)) <span class="comment">--true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串提供的公共方法</span></span><br><span class="line">str = <span class="string">&quot;aB&quot;</span></span><br><span class="line"><span class="comment">-- 小写转大写。不会改变原字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(str)) <span class="comment">--AB</span></span><br><span class="line"><span class="comment">-- 大写转小写。不会改变原字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(str)) <span class="comment">--ab</span></span><br><span class="line"><span class="comment">-- 翻转字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">reverse</span>(str)) <span class="comment">--Ba</span></span><br><span class="line"><span class="comment">-- 字符串索引查找。lua的索引从1开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;B&quot;</span>)) <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;aB&quot;</span>)) <span class="comment">--1   2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="number">1</span>)) <span class="comment">--aB</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">--aB</span></span><br><span class="line"><span class="comment">-- 字符串转ASCII码</span></span><br><span class="line">a = <span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--76</span></span><br><span class="line"><span class="comment">-- ASCII码转字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(a)) <span class="comment">--L</span></span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>字符串可以进行算数运算符操作，会自动转成<code>number</code><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 有 + - * / %</span></span><br><span class="line"><span class="comment">-- 没有自增自减 -- ++ </span></span><br><span class="line"><span class="comment">-- 没有复合运算符 += -= /= *= %=</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.4&quot;</span> + <span class="number">1</span>) <span class="comment">--124.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 条件运算符</span></span><br><span class="line"><span class="comment">-- 有 &gt; &lt; &gt;= &lt;= == ~=(不等于)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符</span></span><br><span class="line"><span class="comment">-- 逻辑与: and  逻辑或: or  逻辑非: not</span></span><br><span class="line"><span class="comment">-- 分别对应C#中的 &amp;&amp; || !</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">false</span>) <span class="comment">--false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span>) <span class="comment">--true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>) <span class="comment">--true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="literal">false</span>) <span class="comment">--false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">true</span>) <span class="comment">--false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)) <span class="comment">--nil 123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)) <span class="comment">-- </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &amp; | 不支持位运算符，需要自已实现</span></span><br><span class="line"><span class="comment">-- ? : 不支持三目运算符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- if 条件 then ... end</span></span><br><span class="line">a = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">3</span> <span class="keyword">and</span> a &lt;= <span class="number">9</span> <span class="keyword">then</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 双分支</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;321&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多分支</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment">-- lua中elseif要连着写，不然会报错</span></span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">6</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">7</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">8</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;8&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">9</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;9&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua中没有switch语句，需要自已实现</span></span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--while。while 条件 do end</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--do while。repeat ...... until 条件</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span> </span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> num &gt; <span class="number">5</span> <span class="comment">--满足条件跳出（结束条件）。C#是进入条件</span></span><br><span class="line"><span class="comment">--0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- for。默认递增，</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果要自定义增量，直接逗号后面写</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 1 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自定义减量</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--5 4 3 2 1</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>两种函数声明方式</li>
</ul>
<ol>
<li><code>function</code>后面取名字</li>
<li>用一个变量来存储</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不能在函数声明前调用！！！</span></span><br><span class="line"><span class="comment">-- function 函数()</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 无参无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F1函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F2 = <span class="function"><span class="keyword">function</span> <span class="title">F2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F2函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有参数。如果传入参数与函数参数个数不匹配，不会报错，只会补空nil或则丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;参数:&quot;</span>..a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F3(<span class="number">1</span>)       <span class="comment">--参数:1</span></span><br><span class="line">F3(<span class="string">&quot;123&quot;</span>)   <span class="comment">--参数:123</span></span><br><span class="line">F3()        <span class="comment">--nil</span></span><br><span class="line">F3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">--1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有返回值。多返回值时，在前面声明多个变量来接取，如果变量不够，不会报错；如果变量多了，直接赋nil</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F4</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp = F4(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp) <span class="comment">--1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F4</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> a,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp,temp2,temp3  = F4(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp) <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(temp2) <span class="comment">--123</span></span><br><span class="line"><span class="built_in">print</span>(temp3) <span class="comment">--true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数类型。恒为function</span></span><br><span class="line">F5 = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(F5)) <span class="comment">--function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数不支持重载。默认调用最后一个同名的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F6() <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变长参数。用一个表存起来再用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F7</span><span class="params">( ... )</span></span></span><br><span class="line">    <span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,#<span class="built_in">arg</span>, <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">arg</span>[i])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F7(<span class="number">1</span>,<span class="string">&quot;123,&quot;</span><span class="literal">true</span>) <span class="comment">--1 123 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F8</span><span class="params">()</span></span></span><br><span class="line">    F9 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--[[return function()</span></span><br><span class="line"><span class="comment">        print(123)</span></span><br><span class="line"><span class="comment">    end]]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f9 = F8()</span><br><span class="line">f9() <span class="comment">--123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 闭包。嵌套函数（内部函数）改变外部函数的函数的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F9</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">--改变传入参数的生命周期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(y)</span></span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f10 = F9(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(f10(<span class="number">5</span>)) <span class="comment">--15</span></span><br></pre></td></tr></table></figure>

<h1 id="table实现数组（重点）"><a href="#table实现数组（重点）" class="headerlink" title="table实现数组（重点）"></a>table实现数组（重点）</h1><ul>
<li>所有复杂类型都是<code>table</code>（类）</li>
<li><code>lua</code>中索引从<code>1</code>开始</li>
<li><code>#</code>是通用获取长度的关键字，不计算<code>nil</code>。（打印长度时，空<code>nil</code>被忽略，如果中间遍历到的是<code>nil</code>，后面直接忽略，影响结果）<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 复杂数据结构 table</span></span><br><span class="line"><span class="comment">-- 数组</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>]) <span class="comment">--nil。lua`中索引从`1`开始</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>]) <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(#a)   <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数组的遍历</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 二维数组</span></span><br><span class="line">a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>][<span class="number">1</span>])  <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>][<span class="number">3</span>])  <span class="comment">--3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>][<span class="number">1</span>])  <span class="comment">--4</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>][<span class="number">2</span>])  <span class="comment">--5</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>][<span class="number">3</span>])  <span class="comment">--6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 二维数组的遍历</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line">    b=a[i]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,#b <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(b[j]) <span class="comment">--1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自定义索引</span></span><br><span class="line">aa = &#123;[<span class="number">0</span>] = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">-1</span>] = <span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aa[<span class="number">0</span>])    <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(aa[<span class="number">-1</span>])   <span class="comment">--4</span></span><br><span class="line"><span class="built_in">print</span>(aa[<span class="number">1</span>])    <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(aa[<span class="number">2</span>])    <span class="comment">--3</span></span><br><span class="line"><span class="built_in">print</span>(aa[<span class="number">3</span>])    <span class="comment">--5</span></span><br><span class="line"><span class="built_in">print</span>(#aa)      <span class="comment">--3。不能索引到负数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自定义索引的坑</span></span><br><span class="line">aa = &#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">4</span>, [<span class="number">5</span>] = <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#aa) <span class="comment">--5</span></span><br><span class="line"></span><br><span class="line">aa = &#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, [<span class="number">5</span>] = <span class="number">4</span>, [<span class="number">6</span>] = <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#aa) <span class="comment">--6</span></span><br><span class="line"></span><br><span class="line">aa = &#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">4</span>, [<span class="number">6</span>] = <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#aa) <span class="comment">--6</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#aa <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(aa[i]) <span class="comment">--1 2 nil 4 nil 6</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="迭代器遍历（重点）（ipairs和pairs的区别-考点）"><a href="#迭代器遍历（重点）（ipairs和pairs的区别-考点）" class="headerlink" title="迭代器遍历（重点）（ipairs和pairs的区别:考点）"></a>迭代器遍历（重点）（ipairs和pairs的区别:考点）</h1><ul>
<li>迭代器遍历主要用来遍历表的。一般不用<code>#</code>遍历表，因为不准确</li>
<li>区别</li>
</ul>
<ol>
<li><code>ipairs</code>不能找到<code>0</code>和<code>0</code>以下的自定义索引的内容</li>
<li><code>ipairs</code>如果从<code>1</code>开始索引顺序断了，后面的内容也找不到</li>
<li>建议用<code>pairs</code>遍历各种不规则的表。因为它可以得到所有信息</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;[<span class="number">0</span>] = <span class="number">1</span>,<span class="number">2</span>, [<span class="number">-1</span>] = <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, [<span class="number">5</span>] = <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">-- ipairs</span></span><br><span class="line"><span class="comment">-- ipairs遍历还是从1开始往后遍历，小于等于0的值得不到</span></span><br><span class="line"><span class="comment">-- 只能找到连续索引的键，如果中间断序了，它也无法遍历出后面的内容</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i..<span class="string">&quot;_&quot;</span>..k) <span class="comment">--1_2 2_4 3_5</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pair。它可以获取所有的键，通过键获取值</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i..<span class="string">&quot;_&quot;</span>..k) <span class="comment">--1_2 2_4 3_5 0_1 -1_3 5_6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">--1 2 3 0 -1 5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="table实现字典"><a href="#table实现字典" class="headerlink" title="table实现字典"></a>table实现字典</h1><ul>
<li>字典的本质也是表<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 字典</span></span><br><span class="line"><span class="comment">-- 字典的声明。字典由键值对组成</span></span><br><span class="line"><span class="comment">-- 访问单个变量用中括号填键来访问</span></span><br><span class="line"><span class="comment">-- 还可以用.成员变量的形式得到值。但这种方法不能使用数字</span></span><br><span class="line">a = &#123;[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;我&quot;</span>, [<span class="string">&quot;age&quot;</span>] = <span class="number">14</span>, [<span class="string">&quot;1&quot;</span>] = <span class="number">5</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])    <span class="comment">--我</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;age&quot;</span>])     <span class="comment">--14</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;1&quot;</span>])       <span class="comment">--5</span></span><br><span class="line"><span class="built_in">print</span>(a.name)       <span class="comment">--我</span></span><br><span class="line"><span class="built_in">print</span>(a<span class="number">.1</span>)          <span class="comment">--错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;TLS&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[name])       <span class="comment">--TLS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--新增</span></span><br><span class="line">a[<span class="string">&quot;sex&quot;</span>] = <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(a.sex)        <span class="comment">--false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line">a[<span class="string">&quot;sex&quot;</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(a.sex)        <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字典的遍历。如果模拟字典遍历，一定要用pairs</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--可以传多个参数，一样可以打印出来</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)  </span><br><span class="line"><span class="comment">--1   5</span></span><br><span class="line"><span class="comment">--age 14</span></span><br><span class="line"><span class="comment">--name TLS</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line">    <span class="built_in">print</span>(a[k]) <span class="comment">--1 age name</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="table实现类（重点）（点和冒号的区别，self）"><a href="#table实现类（重点）（点和冒号的区别，self）" class="headerlink" title="table实现类（重点）（点和冒号的区别，self）"></a>table实现类（重点）（点和冒号的区别，self）</h1><ul>
<li><code>lua</code>中没有面向对象的，需要自已实现</li>
<li>点和冒号的区别</li>
</ul>
<ol>
<li>冒号调用会默认将自已作为调用者，作为第一个参数传入</li>
</ol>
<ul>
<li><code>lua</code>中有个一关键字<code>self</code>表示默认传入的第一个参数<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 成员变量 成员函数</span></span><br><span class="line">Student = &#123;</span><br><span class="line">    age = <span class="number">1</span>,</span><br><span class="line">    sex = <span class="literal">true</span>,</span><br><span class="line">    Up = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- 这样写age和这个表中age没有任何关系，它是一个全局变量</span></span><br><span class="line">        <span class="comment">-- print(age)</span></span><br><span class="line">        <span class="comment">-- 想要在表内部函数中，调用表中本身的属性或方法</span></span><br><span class="line">        <span class="comment">-- 一定要指定是谁的，所以要用 表名.属性 或 表名.方法</span></span><br><span class="line">        <span class="comment">-- print(Student.age)</span></span><br><span class="line">        <span class="comment">-- 第二种方法，将自已作为一个参数传进来在内部访问</span></span><br><span class="line">        <span class="comment">-- x = function(me)</span></span><br><span class="line">        <span class="comment">--      print(me.age)</span></span><br><span class="line">        <span class="comment">-- end</span></span><br><span class="line">        <span class="comment">-- Student.x(Student)</span></span><br><span class="line">        <span class="comment">-- 或者 Student:x()</span></span><br><span class="line">        <span class="comment">-- 由第二种写法引申出以下在类外函数声明方法</span></span><br><span class="line">        <span class="comment">-- function Student:y()</span></span><br><span class="line">        <span class="comment">--      print(self.name) </span></span><br><span class="line">        <span class="comment">-- end</span></span><br><span class="line">        <span class="comment">-- Student:y()  --我</span></span><br><span class="line">        <span class="comment">-- Student.y(Student)   --我。这种调用方法也可</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- C#要使用类，实例化对象，或者静态</span></span><br><span class="line"><span class="comment">-- lua类的表现更像是一个类中有很多静态变量和静态函数</span></span><br><span class="line"><span class="built_in">print</span>(Student.age)  <span class="comment">--1</span></span><br><span class="line">Student.Up()        <span class="comment">--我</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明表后，在表外去声明表有的变量和方法</span></span><br><span class="line">Student.name = <span class="string">&quot;它&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Student.name) <span class="comment">--它</span></span><br><span class="line"></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;说话&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Student.Speak() <span class="comment">--说话</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Speak2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;说话2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">Student.Speak2() <span class="comment">--说话2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="table的公共操作"><a href="#table的公共操作" class="headerlink" title="table的公共操作"></a>table的公共操作</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t1 = &#123;&#123;age = <span class="number">1</span>, name = <span class="string">&quot;123&quot;</span>&#125;,&#123;age = <span class="number">2</span>, name = <span class="string">&quot;345&quot;</span>&#125;&#125;</span><br><span class="line">t2 = &#123;name = <span class="string">&quot;我&quot;</span>, sex = <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入。table.remove</span></span><br><span class="line"><span class="built_in">print</span>(#t1)  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(t1,t2)</span><br><span class="line"><span class="built_in">print</span>(#t1)  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">2</span>])    </span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>])    </span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>].sex)    <span class="comment">--sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除指定元素</span></span><br><span class="line"><span class="comment">--table.remove方法。传表进去，会移除最后一个索引的内容</span></span><br><span class="line"><span class="comment">-- table.remove方法。传两个参数，第一个参数是需要移除内容的表，第二个是移除内容的索引</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(#t1)          <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>].name)   <span class="comment">--123</span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">2</span>].name)   <span class="comment">--345</span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>])        <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1,<span class="number">1</span>) </span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>].name)   <span class="comment">--345</span></span><br><span class="line"><span class="built_in">print</span>(#t1)          <span class="comment">--1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排序。第一个是排序的表，第二个是排序规则函数</span></span><br><span class="line"><span class="comment">-- 升序</span></span><br><span class="line">t2 = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(t2)</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t2) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(v)    <span class="comment">--2 5 5 7 9</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(t2,<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(v)    <span class="comment">-- 9 7 5 5 2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接。用于拼接表中元素，返回值是一个字符串。极少用，了解即可</span></span><br><span class="line">ta = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>,<span class="string">&quot;10101&quot;</span>&#125;</span><br><span class="line">str = <span class="built_in">table</span>.<span class="built_in">concat</span>(tb,<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str)  <span class="comment">---123,456,789,10101</span></span><br></pre></td></tr></table></figure>

<h1 id="多脚本执行（重点）（require，package，-G）"><a href="#多脚本执行（重点）（require，package，-G）" class="headerlink" title="多脚本执行（重点）（require，package，_G）"></a>多脚本执行（重点）（require，package，_G）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全局变量和局部变量</span></span><br><span class="line"><span class="comment">-- 全局变量</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">    c = <span class="string">&quot;我&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--我</span></span><br><span class="line"><span class="comment">--本地（局部）变量关键字 local</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> c = <span class="string">&quot;我&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(c)    <span class="comment">--我</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--nil</span></span><br><span class="line">fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> tt = <span class="string">&quot;123123123&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(tt)   <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tt2 = <span class="string">&quot;555&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tt2)  <span class="comment">--555</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多脚本执行</span></span><br><span class="line"><span class="comment">-- 关键字 require(&quot;脚本名&quot;) require(&#x27;脚本名&#x27;)</span></span><br><span class="line"><span class="comment">-- Test1.lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Test1测试&quot;</span>)</span><br><span class="line">tsetA = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">local</span> testLocalA = <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Test2.lua</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;Test1&quot;</span>)    <span class="comment">--Test1测试</span></span><br><span class="line"><span class="built_in">print</span>(tsetA)        <span class="comment">--123</span></span><br><span class="line"><span class="built_in">print</span>(testLocalA)   <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 脚本卸载</span></span><br><span class="line"><span class="comment">-- package.loaded[&quot;脚本名&quot;]，返回值是boolean，判断脚本是否被执行</span></span><br><span class="line"><span class="comment">-- 如果是require加载执行的脚本，加载过一次过后，不会再被执行</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;Test1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;Test1&quot;</span>])  <span class="comment">--true</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;Test1&quot;</span>] = <span class="literal">nil</span>   <span class="comment">--卸载已经执行过的脚本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;Test1&quot;</span>])  <span class="comment">--false</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;Test1&quot;</span>)                <span class="comment">--Test1测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 大G表</span></span><br><span class="line"><span class="comment">-- _G表是一个总表(table)，它将声明的所有全局变量都存储在其中</span></span><br><span class="line"><span class="comment">-- local变量是不会存在大G表中</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)  <span class="comment">--</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="特殊用法（重点）（多变量赋值，三目运算符）"><a href="#特殊用法（重点）（多变量赋值，三目运算符）" class="headerlink" title="特殊用法（重点）（多变量赋值，三目运算符）"></a>特殊用法（重点）（多变量赋值，三目运算符）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 多变量赋值</span></span><br><span class="line"><span class="comment">-- 如果后面的值不够，自动补空</span></span><br><span class="line"><span class="comment">-- 如果后面的值多了，自动省略</span></span><br><span class="line"><span class="keyword">local</span> a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--123</span></span><br><span class="line"></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多返回值。用几个变量接，就几个值，规则和多变量赋值一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line">    retur <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a,b,c = Test()</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">--10</span></span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">--20</span></span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">--30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- and or</span></span><br><span class="line"><span class="comment">-- 逻辑与 逻辑或</span></span><br><span class="line"><span class="comment">-- and or 可以连接任何东西</span></span><br><span class="line"><span class="comment">-- 在lua中，只有nil和false才认为是假</span></span><br><span class="line"><span class="comment">-- 第一个满足条件则停止运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>)  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span>)  <span class="comment">--0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">and</span> <span class="number">1</span>)  <span class="comment">--nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="number">1</span>)  <span class="comment">--false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="number">3</span>)  <span class="comment">--3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="number">1</span>)    <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="number">1</span>)   <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">or</span> <span class="number">2</span>)     <span class="comment">--2</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="comment">-- ? :</span></span><br><span class="line"><span class="keyword">local</span> res = (x&gt;y) <span class="keyword">and</span> x <span class="keyword">or</span> y</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment">--3</span></span><br></pre></td></tr></table></figure>


<h1 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 协程的创建</span></span><br><span class="line"><span class="comment">-- 常用方法</span></span><br><span class="line"><span class="comment">-- coroutine.create()</span></span><br><span class="line">fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun)</span><br><span class="line"><span class="comment">-- 协程的本质是一个线程对象</span></span><br><span class="line"><span class="built_in">print</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co)) <span class="comment">--thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- function.wrap()</span></span><br><span class="line">co2 = function.<span class="built_in">wrap</span>(fun)</span><br><span class="line"><span class="built_in">print</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co2)) <span class="comment">--function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协程的运行</span></span><br><span class="line"><span class="comment">-- 第一种方法是要通过create创建的协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)    <span class="comment">--123</span></span><br><span class="line"><span class="comment">-- 第二种方法</span></span><br><span class="line">co2()   <span class="comment">--123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协程的挂起</span></span><br><span class="line">fun2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">co3 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun2)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)   <span class="comment">--123</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)   <span class="comment">--123</span></span><br><span class="line"></span><br><span class="line">co4 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(co4)</span><br><span class="line">co4()   <span class="comment">--123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第一种方法默认第一个返回值是协程是否启动成功，yield的返回值</span></span><br><span class="line"><span class="comment">-- 第二种方法默认没有第一个返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协程的状态</span></span><br><span class="line"><span class="comment">-- coroutine.status(协程对象)</span></span><br><span class="line"><span class="comment">-- dead 结束</span></span><br><span class="line"><span class="comment">-- suspended 暂停</span></span><br><span class="line"><span class="comment">-- running 进行中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co3))    <span class="comment">--suspended</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))     <span class="comment">--dead</span></span><br></pre></td></tr></table></figure>

<h1 id="元表（重点）（-index，tostring，-newindex）"><a href="#元表（重点）（-index，tostring，-newindex）" class="headerlink" title="元表（重点）（__index，tostring，__newindex）"></a>元表（重点）（__index，tostring，__newindex）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 元表概念</span></span><br><span class="line"><span class="comment">-- 任何表变量都可以作为另外一个表变量的元表</span></span><br><span class="line"><span class="comment">-- 当我们子表进行一些特定操作时</span></span><br><span class="line"><span class="comment">-- 会执行元表中的内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置元表</span></span><br><span class="line">meta = &#123;&#125;</span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="comment">-- 设置元表函数</span></span><br><span class="line"><span class="comment">-- 第一个参数 子表</span></span><br><span class="line"><span class="comment">-- 第二个参数 元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特定操作</span></span><br><span class="line">meta2 = &#123;</span><br><span class="line">    <span class="comment">-- 当子表当作字符串时，会默认调用元表中的tostring方法</span></span><br><span class="line">    <span class="comment">-- 两条下划线</span></span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 当子表当成一个函数来使用时，会默认调用__call中的内容</span></span><br><span class="line">    <span class="comment">-- 当希望传参数时，一定要记住默认第一个参数是调用者自已</span></span><br><span class="line">    <span class="built_in">__call</span> = fun <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable2 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2,meta2)</span><br><span class="line"><span class="built_in">print</span>(myTable2) <span class="comment">--我</span></span><br><span class="line">myTable2()      <span class="comment">--aaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特定操作-运算符重载</span></span><br><span class="line">meta4 = &#123;</span><br><span class="line">    <span class="comment">-- 运算符+</span></span><br><span class="line">    <span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line">        <span class="keyword">return</span> t1.age+t2.age</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 运算符 -</span></span><br><span class="line">    <span class="built_in">__sub</span> =<span class="function"><span class="keyword">function</span> <span class="params">(t1,t2)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 运算符*</span></span><br><span class="line">    <span class="built_in">__mul</span> <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 运算符/</span></span><br><span class="line">    <span class="built_in">__div</span> <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--.........</span></span><br><span class="line">&#125;</span><br><span class="line">myTable4 = &#123;age = <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable4,meta4)</span><br><span class="line">myTable5 = &#123;age = <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(myTable4 + myTable5)    <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特定操作-__index和__newindex</span></span><br><span class="line">meta6 = &#123;</span><br><span class="line">    age = <span class="number">1</span></span><br><span class="line">    <span class="comment">--__index = &#123;age = 2&#125;</span></span><br><span class="line">    <span class="comment">-- __index建议在表外部初始化</span></span><br><span class="line">&#125;</span><br><span class="line">meta6.<span class="built_in">__index</span> = meta6</span><br><span class="line"><span class="comment">--meta6.__index = &#123;age = 2&#125;</span></span><br><span class="line">myTable6 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mtTable6,meta6)</span><br><span class="line"><span class="comment">-- _index当子表中找不到某个属性时</span></span><br><span class="line"><span class="comment">-- 会到元表中__index执行的表去索引</span></span><br><span class="line"><span class="built_in">print</span>(myTable6.age) <span class="comment">--1</span></span><br><span class="line"><span class="comment">-- rawget 当我们使用它时，会去找自已身上有没有这个变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable6,<span class="string">&quot;name&quot;</span>))    <span class="comment">--nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- newindex 当赋值时，如果赋值一个不存在的索引</span></span><br><span class="line"><span class="comment">-- 那么会把这个值赋值到newindex所指的表中，不会修改自已</span></span><br><span class="line">meta7 = &#123;&#125;</span><br><span class="line">meta7.<span class="built_in">__newindex</span> = &#123;&#125;</span><br><span class="line">myTable7 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable7,meta7)</span><br><span class="line">myTable7.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable7.age) <span class="comment">--nil</span></span><br><span class="line"><span class="built_in">print</span>(meta7.age)    <span class="comment">--nil</span></span><br><span class="line"><span class="built_in">print</span>(meta7.<span class="built_in">__newindex</span>.age) <span class="comment">--1</span></span><br><span class="line"><span class="comment">-- rawget当我们使用它时，会绕开newindex</span></span><br></pre></td></tr></table></figure>

<h1 id="Lua面向对象之封装（重点）"><a href="#Lua面向对象之封装（重点）" class="headerlink" title="Lua面向对象之封装（重点）"></a>Lua面向对象之封装（重点）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 类基于table来实现</span></span><br><span class="line">Object = &#123;&#125;</span><br><span class="line">Object.id = <span class="number">1</span></span><br><span class="line"><span class="comment">--冒号是会自动将调用这个函数的对象，作为第一个参数传入的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">--self 代表的是，默认传入的第一个参数</span></span><br><span class="line">    <span class="comment">--对象就是变量，返回一个新的变量</span></span><br><span class="line">    <span class="comment">---返回出去的内容，本质上是表对象</span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">--元表知识 __index 当找自已变量找不到时，就会去元表中__index指向的内容</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:Test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> myObj = Object:new()</span><br><span class="line"><span class="built_in">print</span>(myObj.id)    <span class="comment">--1</span></span><br><span class="line">myObj:Test()    <span class="comment">--1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--对空表中，声明一个属性，叫做id</span></span><br><span class="line">myObj.id = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Object.id)    <span class="comment">--1</span></span><br><span class="line">myObj:Test()        <span class="comment">--2</span></span><br></pre></td></tr></table></figure>

<h1 id="Lua面向对象之继承（重点）"><a href="#Lua面向对象之继承（重点）" class="headerlink" title="Lua面向对象之继承（重点）"></a>Lua面向对象之继承（重点）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--_G[&quot;a&quot;] = 1</span></span><br><span class="line"><span class="comment">-- print(a) --1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="comment">--_G是总表，记录所有的全局变量，都以键值对的形式存在其中</span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="comment">--写相关继承的规则</span></span><br><span class="line">    <span class="comment">--用到元表</span></span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line">    <span class="comment">--子类定义一个base属性，表示父类</span></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Object:subClass(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Person.id)    <span class="comment">--1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p1 = Person:new()</span><br><span class="line"><span class="built_in">print</span>(p1.id)    <span class="comment">--1</span></span><br></pre></td></tr></table></figure>

<h1 id="Lua面向对象之多态（重点）"><a href="#Lua面向对象之多态（重点）" class="headerlink" title="Lua面向对象之多态（重点）"></a>Lua面向对象之多态（重点）</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 相同行为不用表现</span></span><br><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line">GameObject.posX = <span class="number">0</span></span><br><span class="line">GameObject.posY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.posX = <span class="built_in">self</span>.posX + <span class="number">1</span></span><br><span class="line">    <span class="built_in">self</span>.posY = <span class="built_in">self</span>.posY + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posY)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- base 指的是 GameObject表（类）</span></span><br><span class="line">    <span class="comment">-- 相当于把基类表作为第一个参数传入方法中</span></span><br><span class="line">    <span class="comment">-- 避免把基类表传入方法中</span></span><br><span class="line">    <span class="built_in">self</span>.base:Move()</span><br><span class="line">    <span class="comment">-- 如果执行父类逻辑，不要使用冒号调用</span></span><br><span class="line">    <span class="comment">-- 要通过.调用，然后自已传入第一个参数</span></span><br><span class="line">    <span class="built_in">self</span>.base.Move(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> p1 = Player:new()</span><br><span class="line">p1:Move()</span><br><span class="line"><span class="comment">--目前这种写法错误，不同对象使用的成员变量是相同的</span></span><br></pre></td></tr></table></figure>

<h1 id="Lua面向对象总结"><a href="#Lua面向对象总结" class="headerlink" title="Lua面向对象总结"></a>Lua面向对象总结</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--面向对象实现</span></span><br><span class="line"><span class="comment">--所有对象的基类Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--继承</span></span><br><span class="line">Object = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">--给空对象设置元表及__index</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="comment">--根据名字生成一个表（类）</span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line">    <span class="comment">--为了实现多态，设置自已的元表（父类）</span></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line">    <span class="comment">--给子类设置元表及__index</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--声明一个新的类</span></span><br><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line"><span class="comment">--成员变量</span></span><br><span class="line">GameObject.posX = <span class="number">0</span></span><br><span class="line">GameObject.posY = <span class="number">0</span></span><br><span class="line"><span class="comment">--成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.posX = <span class="built_in">self</span>.posX + <span class="number">1</span></span><br><span class="line">    <span class="built_in">self</span>.posY = <span class="built_in">self</span>.posY + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--实例化对象使用</span></span><br><span class="line"><span class="keyword">local</span> obj = GameObject:new()</span><br><span class="line"><span class="built_in">print</span>(obj.posX)</span><br><span class="line">obj:Move()</span><br><span class="line"><span class="built_in">print</span>(obj.posX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj2 = GameObject:new()</span><br><span class="line"><span class="built_in">print</span>(obj2.posX)</span><br><span class="line">obj2:Move()</span><br><span class="line"><span class="built_in">print</span>(obj2.posX)</span><br><span class="line"></span><br><span class="line"><span class="comment">--声明一个新的类Player，继承GameObject</span></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="comment">--多态重写了GameObject中的Move方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">--base调用父类方法不能用冒号调用，用.自已传一个参数</span></span><br><span class="line">    <span class="built_in">self</span>.base.Move(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--实例化Player类</span></span><br><span class="line"><span class="keyword">local</span> p1 = Player:new()</span><br><span class="line"><span class="built_in">print</span>(p1.posX)</span><br><span class="line">p1:Move()</span><br><span class="line"><span class="built_in">print</span>(p1.posX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p2 = Player:new()</span><br><span class="line"><span class="built_in">print</span>(p2.posX)</span><br><span class="line">p2:Move()</span><br><span class="line"><span class="built_in">print</span>(p2.posX)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/lua/lua-tables.html">Lua - 菜鸟教程</a></li>
<li><a href="https://www.cnblogs.com/robinunix/p/7872561.html">Lua local function与function区别</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1600886">Lua函数的冒号调用和点调用</a></li>
<li><a href="https://www.runoob.com/note/11315">Lua pairs 和 ipairs 的区别</a></li>
<li><a href="https://www.cnblogs.com/cancantrbl/p/13854919.html">Lua 面经</a></li>
<li><a href="https://www.cnblogs.com/slysky/p/7919114.html">[整理]Unity3D游戏开发之Lua</a></li>
<li><a href="https://www.cnblogs.com/msxh/p/7745553.html">【游戏开发】小白学Lua——从Lua查找表元素的过程看元表、元方法</a></li>
<li><a href="https://www.cnblogs.com/msxh/p/8469340.html">【游戏开发】在Lua中实现面向对象特性——模拟类、继承、多态</a></li>
<li><a href="https://www.cnblogs.com/msxh/p/8283865.html">Unity游戏开发】浅谈Lua和C#中的闭包</a></li>
</ul>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 异步</title>
    <url>/2022/10/21/Unity%20%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>Task</code>类表示一个异步操作</li>
<li><ul>
<li>优点</li>
</ul>
</li>
</ul>
<ol>
<li>可以获取返回值</li>
<li>可以使用<code>try-catch</code></li>
</ol>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><ul>
<li><code>async</code>关键字和<code>await</code>是配套使用的异步方法语法糖，配合<code>Task</code>类可以使多线程变得有序</li>
<li><strong>使用async修饰符可将方法、lambda 表达式或匿名方法指定为异步。如果对方法或表达式使用此修饰符，则其称为异步方法</strong></li>
<li>工作流程：异步方法同步运行，直至到达其第一个 await 表达式，此时会将方法挂起，直到等待的任务完成</li>
<li>async 关键字是上下文关键字，原因在于只有当它修饰方法、lambda 表达式或匿名方法时，它才是关键字。 在所有其他上下文中，都会将其解释为标识符。</li>
</ul>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><ul>
<li><strong>await运算符暂停对其所属的async方法的求值，直到其操作数表示的异步操作完成</strong>。异步操作完成后，await 运算符将返回操作的结果（如果有）。 当 await 运算符应用到表示已完成操作的操作数时，它将立即返回操作的结果，而不会暂停其所属的方法。 await 运算符不会阻止计算异步方法的线程。 当 await 运算符暂停其所属的异步方法时，控件将返回到方法的调用方。</li>
<li>在异步编程的规范中，<code>async</code>修饰的方法，仅仅表示这个方法在内部<strong>有可能</strong>采用异步的方式执行，<code>CPU</code>在执行这个方法时，会放到一个新的线程中执行。<strong>那这个方法，最终是否采用异步执行，不决定于是否用<code>await</code>方式调用这个方法，而决定于这个方法内部，是否有<code>await</code>方式的调用</strong></li>
</ul>
<h2 id="asnyc-void"><a href="#asnyc-void" class="headerlink" title="asnyc void"></a>asnyc void</h2><ul>
<li><p><code>void</code>代表无返回值，即不想等待异步行为完成</p>
</li>
<li><p>以下两段代码等价。先输出<code>Waiting 1 second...</code>，然后等待<code>1</code>秒，再输出<code>Done!</code></p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Waiting 1 second...&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span><br><span class="line">    Debug.Log(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Waiting 1 second...&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="asnyc-Task"><a href="#asnyc-Task" class="headerlink" title="asnyc Task"></a>asnyc Task</h2><ul>
<li><code>Task</code>（对于执行操作但不返回任何值的异步方法）</li>
<li><code>Task&lt;TResult&gt;</code>（对于返回值的异步方法）</li>
<li>如果不等待一个异步函数，它将返回任务对象，而不是任务的结果值</li>
<li><code>Task</code>：以下的异步函数意为依次执行<code>DoSomething1</code>、<code>DoSomething2</code>、<code>DoSomething3</code>。两段函数等价</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething1</span>()</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething2</span>()</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething3</span>()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> asnyc Task <span class="title">DoSomething</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    DoSomething1();</span><br><span class="line">    <span class="keyword">await</span> Task.Yield();</span><br><span class="line">    DoSomething2();</span><br><span class="line">    <span class="keyword">await</span> Task.Yield();</span><br><span class="line">    DoSomething3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> asnyc <span class="keyword">void</span> <span class="title">fun1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> DoSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="keyword">void</span> <span class="title">DoSomething1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IEnumerator <span class="keyword">void</span> <span class="title">DoSomething2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IEnumerator <span class="keyword">void</span> <span class="title">DoSomething3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DoSomething1(</span>))</span>;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DoSomething2(</span>))</span>;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DoSomething3(</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    StartCoroutine(DoSomething());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><code>Task&lt;TResult&gt;</code>：以下的异步函数意为生成一个<code>100~300</code>的随机数，等待该数的毫秒，然后返回该数<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetRandomNumber</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回100~300的随机数</span></span><br><span class="line">    <span class="built_in">int</span> randomNumber = UnityEngine.Random.Range(<span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="comment">//等待randomNumber毫秒</span></span><br><span class="line">    <span class="keyword">await</span> Task.Delay(randomNumber);</span><br><span class="line">    <span class="keyword">return</span> randomNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">fun1</span>()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//不等待异步函数</span></span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; randonNumberObject = GetRandomNumber();</span><br><span class="line">    <span class="comment">//等待异步函数</span></span><br><span class="line">    <span class="built_in">int</span> randonNumber = <span class="keyword">await</span> GetRandomNumber();</span><br><span class="line">    Debug.Log(randonNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待异步函数</span></span><br><span class="line">    <span class="built_in">int</span> randonNumber = GetRandomNumber().GetAwaiter().GetResult();</span><br><span class="line">    Debug.Log(randonNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="UniTask"><a href="#UniTask" class="headerlink" title="UniTask"></a>UniTask</h1><ul>
<li>UniTask为Unity提供一个高性能，0GC的async&#x2F;await异步方案</li>
<li></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/7fe5ed0f426e">Unity异步等待</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/async">异步编程 - C#|Microsoft Learn</a></li>
<li><a href="https://www.youtube.com/watch?v=WY-mk-ZGAq8">Unity async &#x2F; await: Coroutine’s Hot Sister [C# &amp; Unity]</a></li>
<li><a href="https://www.cnblogs.com/tiger-wang/p/13357981.html">一文说通C#中的异步编程 </a></li>
<li><a href="https://www.cnblogs.com/zhaoshujie/p/11082753.html">C# Task详解</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task?view=net-7.0">Task 类</a></li>
<li><a href="https://github.com/Cysharp/UniTask">Github - UniTask</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await">await 运算符 - 异步等待任务完成</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async">async（C# 参考）</a></li>
<li><a href="https://www.bilibili.com/video/BV1NG411s7hN/?spm_id_from=333.337.search-card.all.click">精选Unity-Github开源库分享 最完美的异步操作解决方案 UniTask</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity Json</title>
    <url>/2023/02/01/Unity%20-%20Json/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><code>JSON</code>: <code>JavaScript Object Notation</code>(<code>JavaScript</code> 对象表示法)</li>
<li>JSON 文件的文件类型是 <code>.json</code></li>
<li>JSON 是存储和交换文本信息的语法，类似 XML</li>
<li>JSON 比 XML 更小、更快，更易解析</li>
<li>C、Python、C++、Java、PHP、Go等编程语言都支持 JSON</li>
<li>语法</li>
</ul>
<ol>
<li>数据在名称<code>/</code>值对中</li>
<li>数据由逗号 <code>,</code> 分隔</li>
<li>使用斜杆 <code>\</code>来转义字符</li>
<li>大括号 <code>&#123;&#125;</code> 保存对象</li>
<li>中括号 <code>[]</code> 保存数组，数组可以包含多个对象</li>
</ol>
<ul>
<li>JSON 的两种结构：</li>
</ul>
<ol>
<li>对象：大括号 <code>&#123;&#125;</code> 保存的对象是一个无序的名称&#x2F;值对集合。一个对象以左括号 <code>&#123;</code> 开始， 右括号 <code>&#125;</code> 结束。每个”键”后跟一个冒号 <code>:</code>，名称&#x2F;值对使用逗号 <code>,</code> 分隔</li>
<li>数组：中括号 <code>[]</code> 保存的数组是值（<code>value</code>）的有序集合。一个数组以左中括号 <code>[</code> 开始， 右中括号 <code>]</code> 结束，值之间使用逗号 <code>,</code> 分隔</li>
</ol>
<ul>
<li>JSON 数据的书写格式是：<code>key : value</code>，如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;age&quot;:30 &#125;</span><br></pre></td></tr></table></figure></li>
<li>key必须为字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）</li>
</ul>
<h1 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h1><ul>
<li>JSON 对象：JSON 对象在大括号 {} 中书写格式：<code>&#123;key1 : value1, key2 : value2, ... keyN : valueN &#125;</code>。如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myObj = &#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;</span><br></pre></td></tr></table></figure></li>
<li>注意</li>
</ul>
<ol>
<li>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）</li>
</ol>
<h1 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h1><ul>
<li>JSON对象的属性值可以是一个JSON数组，JSON数组的元素也可以是对象</li>
<li>JSON 数组：JSON 数组在中括号 [] 中书写格式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; key1 : value1<span class="number">-1</span> , key2:value1<span class="number">-2</span> &#125;, </span><br><span class="line">    &#123; key1 : value2<span class="number">-1</span> , key2:value2<span class="number">-2</span> &#125;, </span><br><span class="line">    &#123; key1 : value3<span class="number">-1</span> , key2:value3<span class="number">-2</span> &#125;, </span><br><span class="line">    ...</span><br><span class="line">    &#123; key1 : valueN<span class="number">-1</span> , key2:valueN<span class="number">-2</span> &#125;, </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>数组可包含多个对象：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;sites&quot;</span>: </span><br><span class="line">    [</span><br><span class="line">        &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;菜鸟教程&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.runoob.com&quot;</span> &#125;, </span><br><span class="line">        &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span> &#125;, </span><br><span class="line">        &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;微博&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.weibo.com&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JsonUtility是Unity自带的用于解析Json的公共类</li>
<li>作用</li>
</ul>
<ol>
<li>将内存中对象序列化为Json格式的字符串</li>
<li>将Json字符串反序列化为类对象</li>
</ol>
<ul>
<li>注意</li>
</ul>
<ol>
<li>JsonUtlity无法直接读取数据集合</li>
<li>文本编码格式需要时UTF-8，不然无法加载</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul>
<li>序列化：把内存中的数据存储到硬盘上。JsonUtility.ToJson(对象)</li>
<li>注意：</li>
</ul>
<ol>
<li>自定义类需要加上序列化特性[System.Serializable]，仅在自定义类中包含自定义类中使用即可</li>
<li>想要序列化保护和私有变量，需要加上特性[SerializeField]</li>
<li>JsonUtility不支持字典</li>
<li>JsonUtlity存储null对象不会是null 而是默认值的数据</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; list;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> protectedInt = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> privateInt = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> testNUllInt; <span class="comment">//默认值为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.age = <span class="number">10</span>;</span><br><span class="line">        t.name = <span class="string">&quot;me&quot;</span>;</span><br><span class="line">        t.list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="comment">// &#123;&quot;age&quot;:10,&quot;name&quot;:&quot;me&quot;,&quot;list&quot;:[1,2,3],&quot;protectedInt&quot;:100,&quot;privateInt&quot;:200,&quot;testNUllInt&quot;:0&#125;</span></span><br><span class="line">        <span class="built_in">string</span> str = JsonUtility.ToJson(t);</span><br><span class="line">        <span class="comment">// File.WriteAllText 创建一个新文件，向其中写入内容，然后关闭文件。 如果目标文件已存在，则覆盖该文件</span></span><br><span class="line">        File.WriteAllText(Application.dataPath + <span class="string">&quot;/test.json&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><ul>
<li>反序列化：把硬盘上的数据读取到内存中。JsonUtility.FromJson(字符串)</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取.json文件，转换成字符串</span></span><br><span class="line"><span class="built_in">string</span> str1 = File.ReadAllText(Application.dataPath + <span class="string">&quot;/test.json&quot;</span>);</span><br><span class="line"><span class="comment">//通过json表示形式创建对象</span></span><br><span class="line">Test t1 = JsonUtility.FromJson&lt;Test&gt;(str1);</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line">Debug.Log(t1.age);</span><br><span class="line"><span class="comment">//me</span></span><br><span class="line">Debug.Log(t1.name);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<ol>
<li>JsonUtlity无法直接读取数据集合</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不能读取</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">&quot;hp&quot;</span>:<span class="number">1</span>,<span class="string">&quot;atk&quot;</span>:<span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;hp&quot;</span>:<span class="number">10</span>,<span class="string">&quot;atk&quot;</span>:<span class="number">100</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>需要如下格式。<code>test1.json</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;list&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>:<span class="number">10</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = File.ReadAllText(Application.dataPath + <span class="string">&quot;/test1.json&quot;</span>);</span><br><span class="line">        Debug.Log(str);</span><br><span class="line">        PersonData p = JsonUtility.FromJson&lt;PersonData&gt;(str);</span><br><span class="line">        <span class="keyword">foreach</span>(Person tmp <span class="keyword">in</span> p.list)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(tmp.age);</span><br><span class="line">            Debug.Log(tmp.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>json文本编码格式需要时UTF-8 不然无法加载</li>
</ol>
<h1 id="LitJson"><a href="#LitJson" class="headerlink" title="LitJson"></a>LitJson</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul>
<li>LitJson是一个第三方库，用于处理Json的序列化和反序列化</li>
<li>LitJson是C#编写的，体积小、速度快、易于使用</li>
<li>注意</li>
</ul>
<ol>
<li>LitJson可以直接读取数据集合</li>
<li>文本编码格式需要是UTF-8 不然无法加载</li>
</ol>
<h2 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h2><ul>
<li>方法：JsonMapper.ToJson(对象)</li>
<li>注意：</li>
</ul>
<ol>
<li>相对JsonUtlity，LitJsond对自定义类不需要加特性</li>
<li>LitJson不能序列化保护、私有变量</li>
<li>LitJson支持字典类型,字典的键 建议都是字符串，因为Json的特点：Json中的键会加上双引号</li>
<li>LitJson需要引用LitJson命名空间</li>
<li>LitJson可以准确的保存null类型</li>
<li>LitJson不支持float类型的解析，只支持double类型的解析</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] arr;</span><br><span class="line">    <span class="comment">//字典的key的类型必须为string，不然反序列化时会报错</span></span><br><span class="line">    <span class="comment">//public Dictionary&lt;int, string&gt; dic;</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> protectedInt = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> privateInt = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.age = <span class="number">10</span>;</span><br><span class="line">        t.name = <span class="string">&quot;me&quot;</span>;</span><br><span class="line">        t.arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="comment">//t.dic = new Dictionary&lt;int, string&gt;() &#123; &#123; 1, &quot;one&quot; &#125;, &#123; 2, &quot;two&quot; &#125; &#125;;</span></span><br><span class="line">        t.p = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;&quot;age&quot;:10,&quot;name&quot;:&quot;me&quot;,&quot;arr&quot;:[1,2,3],&quot;p&quot;:null&#125;</span></span><br><span class="line">        <span class="built_in">string</span> str = JsonMapper.ToJson(t);</span><br><span class="line">        File.WriteAllText(Application.dataPath + <span class="string">&quot;/test3.json&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h2><ul>
<li>方法：JsonMapper.ToObject(字符串)</li>
<li>JsonData是LitJson提供的类对象 可以用键值对的形式去访问其中的内容</li>
<li>注意：</li>
</ul>
<ol>
<li>类结构需要无参构造函数，否则反序列化时报错</li>
<li>字典虽然支持 但是键在使用为数值时会有问题 需要使用字符串类型</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&quot;age&quot;:10,&quot;name&quot;:&quot;me&quot;,&quot;arr&quot;:[1,2,3],&quot;p&quot;:null&#125;</span></span><br><span class="line"><span class="built_in">string</span> str1 = File.ReadAllText(Application.dataPath + <span class="string">&quot;/test3.json&quot;</span>);</span><br><span class="line">JsonData jsonData = JsonMapper.ToObject(str1);</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line">Debug.Log(jsonData[<span class="string">&quot;age&quot;</span>]);</span><br><span class="line"><span class="comment">//me</span></span><br><span class="line">Debug.Log(jsonData[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"></span><br><span class="line">Test t1 = JsonMapper.ToObject&lt;Test&gt;(str1);</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line">Debug.Log(t1.age);</span><br><span class="line"><span class="comment">//me</span></span><br><span class="line">Debug.Log(t1.name);</span><br></pre></td></tr></table></figure>


<h2 id="读取数据集合"><a href="#读取数据集合" class="headerlink" title="读取数据集合"></a>读取数据集合</h2><ul>
<li>test4.json<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">&quot;hp&quot;</span>:<span class="number">1</span>,<span class="string">&quot;atk&quot;</span>:<span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;hp&quot;</span>:<span class="number">10</span>,<span class="string">&quot;atk&quot;</span>:<span class="number">100</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> atk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = File.ReadAllText(Application.dataPath + <span class="string">&quot;/test4.json&quot;</span>);</span><br><span class="line">        <span class="comment">//[&#123;&quot;hp&quot;:1,&quot;atk&quot;:&quot;10&quot;&#125;,&#123;&quot;hp&quot;:10,&quot;atk&quot;:&quot;100&quot;&#125;]</span></span><br><span class="line">        Debug.Log(str);</span><br><span class="line">        List&lt;Player&gt; list = JsonMapper.ToObject&lt;List&lt;Player&gt;&gt;(str);</span><br><span class="line">        <span class="keyword">foreach</span>(Player p <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(p.hp);</span><br><span class="line">            Debug.Log(p.atk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>LitJson提供的序列化反序列化方法 JsonMapper.ToJson和ToObject&lt;&gt;</li>
<li>LitJson对自定义类不需要加特性</li>
<li>LitJson不支持私有变量</li>
<li>LitJson支持字典序列化反序列化</li>
<li>LitJson可以直接将数据反序列化为数据集合</li>
<li>LitJson反序列化时 自定义类型需要无参构造</li>
<li>Json文档编码格式必须是UTF-8</li>
</ol>
<h1 id="JsonUtlity与LitJson"><a href="#JsonUtlity与LitJson" class="headerlink" title="JsonUtlity与LitJson"></a>JsonUtlity与LitJson</h1><ul>
<li>相同点</li>
</ul>
<ol>
<li>他们都是用于Json的序列化反序列化</li>
<li>Json文档编码格式必须是UTF-8</li>
<li>都是通过静态类进行方法调用</li>
</ol>
<ul>
<li>不同点</li>
</ul>
<ol>
<li>JsonUtlity是Unity自带，LitJson是第三方需要引用命名空间</li>
<li>JsonUtlity使用时自定义类需要加特性,LitJson不需要</li>
<li>JsonUtlity支持私有变量(加特性),LitJson不支持</li>
<li>JsonUtlity不支持字典,LitJson支持(但是键只能是字符串)</li>
<li>JsonUtlity不能直接将数据反序列化为数据集合(数组字典),LitJson可以</li>
<li>JsonUtlity对自定义类不要求有无参构造，LitJson需要</li>
<li>JsonUtlity存储空对象时会存储默认值而不是null，LitJson会存null</li>
</ol>
<ul>
<li>选择</li>
</ul>
<ol>
<li>考虑类中保护和私有变量的序列化和反序列化</li>
<li>考虑是否需要序列化字典</li>
<li>考虑是否支持直接反序列化为数据集合</li>
<li>考虑是否存储null，而不是存储默认值</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.io.file.writealltext?view=net-7.0">MSDN - File.WriteAllText 方法</a></li>
<li><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/JsonUtility.html">Unity手册 - JsonUtility</a></li>
<li><a href="http://www.json.org/json-zh.html">Json 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 事件系统</title>
    <url>/2023/01/11/Unity%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="字典的写法"><a href="#字典的写法" class="headerlink" title="字典的写法"></a>字典的写法</h1><ul>
<li>参考于<code>Unity</code>的<code>FPS</code>模板</li>
<li>一个字典用于检查该事件是否已经注册，另一个字典用于存储事件</li>
<li>事件的定义<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameEvent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NullGameEvent</span> : <span class="title">GameEvent</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> win;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NullGameEvent nullGameEvent = <span class="keyword">new</span> NullGameEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EventManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;Type, Action&lt;GameEvent&gt;&gt; s_Events = <span class="keyword">new</span> Dictionary&lt;Type, Action&lt;GameEvent&gt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;Delegate, Action&lt;GameEvent&gt;&gt; s_EventLookups = <span class="keyword">new</span> Dictionary&lt;Delegate, Action&lt;GameEvent&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; evt</span>) <span class="keyword">where</span> T : GameEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果s_EventLookups字典没有该事件。防止重复添加</span></span><br><span class="line">        <span class="keyword">if</span> (!s_EventLookups.ContainsKey(evt))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不是逆变，是里氏替换原则。作用1：作为参数，作用2：子类装父类，</span></span><br><span class="line">            <span class="comment">//将该事件添加到s_EventLookups字典中</span></span><br><span class="line">            Action&lt;GameEvent&gt; newAction = e =&gt; evt(e <span class="keyword">as</span> T);</span><br><span class="line">            s_EventLookups[evt] = newAction;</span><br><span class="line">            <span class="comment">//如果s_Events字典中有该事件的委托对应的值，则添加，否则，等于</span></span><br><span class="line">            <span class="keyword">if</span> (s_Events.TryGetValue(<span class="keyword">typeof</span>(T), <span class="keyword">out</span> Action&lt;GameEvent&gt; internalAction))</span><br><span class="line">                s_Events[<span class="keyword">typeof</span>(T)] = internalAction += newAction;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s_Events[<span class="keyword">typeof</span>(T)] = newAction;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; evt</span>) <span class="keyword">where</span> T : GameEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果s_EventLookups字典有该事件。防止无效删除</span></span><br><span class="line">        <span class="keyword">if</span> (s_EventLookups.TryGetValue(evt, <span class="keyword">out</span> <span class="keyword">var</span> action))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果s_Events字典中有该事件的委托对应的值，则移除该委托</span></span><br><span class="line">            <span class="keyword">if</span> (s_Events.TryGetValue(<span class="keyword">typeof</span>(T), <span class="keyword">out</span> <span class="keyword">var</span> tempAction))</span><br><span class="line">            &#123;</span><br><span class="line">                tempAction -= action;</span><br><span class="line">                <span class="comment">//如果该委托没有事件委托了，就从s_Events字典中移除，否则，再等于</span></span><br><span class="line">                <span class="keyword">if</span> (tempAction == <span class="literal">null</span>)</span><br><span class="line">                    s_Events.Remove(<span class="keyword">typeof</span>(T));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s_Events[<span class="keyword">typeof</span>(T)] = tempAction;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从s_EventLookups字典移除该事件</span></span><br><span class="line">            s_EventLookups.Remove(evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>(<span class="params">GameEvent evt</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果s_Events字典中有该事件，则调用该委托</span></span><br><span class="line">        <span class="keyword">if</span> (s_Events.TryGetValue(evt.GetType(), <span class="keyword">out</span> <span class="keyword">var</span> action))</span><br><span class="line">            action.Invoke(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_Events.Clear();</span><br><span class="line">        s_EventLookups.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        evtSo.RegisterListener&lt;nullGameEvent&gt;(Play);</span><br><span class="line">        Events.nullGameEvent.win = <span class="literal">true</span>;</span><br><span class="line">        evtSo.Broadcast(Events.nullGameEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Play</span>(<span class="params">nullGameEvent gameEvent</span>)</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ScriptableObject的第一种写法"><a href="#ScriptableObject的第一种写法" class="headerlink" title="ScriptableObject的第一种写法"></a>ScriptableObject的第一种写法</h1><ul>
<li>每个事件都单独用一个<code>ScriptableObject</code>来存储，<code>ScriptableObject</code>内封装一个<code>UnityEvent</code></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> UnityEvent&lt;GameEvent&gt; listeners = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Raise</span>(<span class="params">GameEvent gv</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners?.Invoke(gv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">UnityAction&lt;T&gt; evt</span>) <span class="keyword">where</span> T : GameEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.AddListener((GameEvent gv) =&gt; evt(gv <span class="keyword">as</span> T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">UnityAction&lt;T&gt; evt</span>) <span class="keyword">where</span> T : GameEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.RemoveListener((GameEvent gv) =&gt; evt(gv <span class="keyword">as</span> T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.RemoveAllListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EventSO evtSo;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        evtSo.RegisterListener&lt;nullGameEvent&gt;(Play);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Play</span>(<span class="params">nullGameEvent gameEvent</span>)</span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EventSO evtSo;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            Events.nullGameEvent.win = <span class="literal">true</span>;</span><br><span class="line">            evtSo.Raise(Events.nullGameEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ScriptableObject的第二种写法（依赖注入）"><a href="#ScriptableObject的第二种写法（依赖注入）" class="headerlink" title="ScriptableObject的第二种写法（依赖注入）"></a>ScriptableObject的第二种写法（依赖注入）</h1><ul>
<li>每个事件都单独用一个<code>ScriptableObject</code>来存储，<code>ScriptableObject</code>内封装一个<code>List</code>，用来存储要触发的脚本</li>
<li>如果需要传递参数，需要自已获取</li>
<li>缺点：</li>
</ul>
<ol>
<li>一个接口只可以用于一个事件，即接口不能复用<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEventRaised</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IEvent&gt; listeners = <span class="keyword">new</span> List&lt;IEvent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Raise</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = listeners.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            listeners[i].OnEventRaised();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterListener</span>(<span class="params">IEvent evt</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.Add(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterListener</span>(<span class="params">IEvent evt</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.Remove(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        listeners.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span>, <span class="title">IEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EventSO evtSo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        evtSo.RegisterListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEventRaised</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;事件触发&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EventSO evtSo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            evtSo.Raise();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 资源路径</title>
    <url>/2022/07/30/Unity%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><strong>只读</strong></li>
<li>打包时会将里面所有的资源压缩处理</li>
<li>加载方法是<code>Resources.Load&lt;T&gt;(文件名)</code>，文件名不包含拓展名</li>
<li>补充：</li>
</ul>
<ol>
<li><code>Resources</code>文件夹中的资源数量越多，对游戏启动时间影响越大（从点击应用到首次出现应用画面的加载时间）。在游戏启动时，<code>Unity</code>引擎会为<code>Resources</code>文件夹下的资源建立一个红黑树来存放与其对应的索引，便于后续资源的加载。一般来说，<code>Resouces</code>文件夹下资源数量越多，其构建时间越长，应用的启动也就越慢</li>
<li>游戏启动时间不仅和<code>Resources</code>文件夹中的资源数量有关，还和首场景有关。首场景的资源加载和相关代码的初始化工作。如果首场景的资源量较多，其脚本初始化的任务较重，则应用的启动时间也会越慢。</li>
</ol>
<h1 id="Application-dataPath（数据路径）"><a href="#Application-dataPath（数据路径）" class="headerlink" title="Application.dataPath（数据路径）"></a>Application.dataPath（数据路径）</h1><ul>
<li>包含目标设备上的游戏数据文件夹路径（<strong>只读</strong>），例如在<code>Editor</code>中就是<code>Assets</code></li>
<li>相对路径，该值取决于运行时所基于的平台</li>
</ul>
<ol>
<li><p><code>Unity Editor：&lt;path to project folder&gt;/Assets</code></p>
</li>
<li><p><code>Android</code>：通常直接指向<code>APK</code>。如果在运行拆分的二进制编译版本，则改为指向<code>OBB</code></p>
</li>
<li><p><code>Windows</code> 应用商店应用程序：播放器数据文件夹的绝对路径（这是一个只读文件夹，使用 <code>Application.persistentDataPath</code> 来保存数据）</p>
</li>
</ol>
<h1 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h1><ul>
<li>通过<code>Application.streamingAssetsPath</code>获取路径，该目录中的文件将会原封不动的被拷贝到不同的平台上，每个平台对应的目录不一致，即不会进行压缩，但是都可以通过上述方法获得。它会根据平台返回正确的路径，如下：</li>
</ul>
<ol>
<li><p><code>Mac OS or Windows：path = Application.dataPath + &quot;/StreamingAssets&quot;;</code></p>
</li>
<li><p><code>IOS：path = Application.dataPath + &quot;/Raw&quot;;</code></p>
</li>
<li><p><code>Android：path = &quot;jar:file://&quot; + Application.dataPath + &quot;!/assets/&quot;; </code></p>
</li>
<li><p>一般用来存放视频等资源文件。<strong>打包后，在Win&#x2F;Linux&#x2F;Mc平台上，可读可写，在Android&#x2F;WebGL平台上，只能读不能写</strong>。一般会把初始的<code>AssetBundle</code>资源放在该文件夹下，并且通过<code>UnityWebRequest</code>或<code>AssetBundle.LoadFromFile</code>加载使用</p>
</li>
<li><p>无法访问 <code>WebGL</code> 和 <code>Android</code> 平台上的 <code>StreamingAssets</code> 文件夹。在 <code>WebGL</code> 上没有文件访问权。<code>Android</code> 使用压缩的 <code>.apk</code> 文件。这些平台返回 <code>URL</code>。请使用 <code>UnityWebRequest</code> 类来访问资源，<code>UnityWebRequest</code>带有解压功能</p>
</li>
<li><p>位于 <code>StreamingAssets</code> 文件夹中的 <code>.dll</code> 和脚本文件不参与脚本编译</p>
</li>
</ol>
<h1 id="Application-persistentDataPath（沙盒目录）"><a href="#Application-persistentDataPath（沙盒目录）" class="headerlink" title="Application.persistentDataPath（沙盒目录）"></a>Application.persistentDataPath（沙盒目录）</h1><ul>
<li>此目录中可以存储每次运行要保留的数据。在 <code>iOS</code> 和 <code>Android</code> 上发布时，<code>persistentDataPath</code> 指向设备上的公共目录。应用程序更新不会擦除此位置中的文件。用户仍然可以直接擦除这些文件。<strong>可读可写</strong>。应用程序安装运行后才会出现</li>
</ul>
<h1 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h1><ul>
<li>返回一个临时数据缓存目录（<strong>只读</strong>）</li>
<li>在<code>IOS</code>上不能被<code>iCloud</code>自动备份</li>
</ul>
<h1 id="资源路径在不同平台的位置"><a href="#资源路径在不同平台的位置" class="headerlink" title="资源路径在不同平台的位置"></a>资源路径在不同平台的位置</h1><ul>
<li><p><code>Windows</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/Unity%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84/windows.png?raw=true"></p>
</li>
<li><p><code>Android</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/Unity%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84/Android.png?raw=true"></p>
</li>
<li><p><code>IOS</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/Unity%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84/IOS.png?raw=true"></p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://docs.unity.cn/cn/2021.3/ScriptReference/Application.html">Unity-手册 Application</a></li>
<li><a href="https://www.cnblogs.com/Fflyqaq/p/12915776.html#applicationdatapath">Unity—4个资源路径简单介绍</a></li>
<li><a href="https://blog.uwa4d.com/archives/910.html">UWA - 技术分享连载（二十七）</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 资源管理</title>
    <url>/2022/07/17/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Asset、Object"><a href="#Asset、Object" class="headerlink" title="Asset、Object"></a>Asset、Object</h1><ul>
<li>资源（<code>Asset</code>）：是硬盘中的文件，存储在<code>Unity</code>工程的<code>Assets</code>文件夹内。例如，纹理（<code>Texture</code>），材质（<code>Material</code>）和FBX文件等，它们都是资源。一些资源的数据格式是<code>Unity</code>原生支持的，例如材质。有些资源则需要转换为原生的数据格式后才能被<code>Unity</code>使用，例如<code>FBX</code>文件</li>
<li>对象（<code>Object</code>）：代表序列化数据的集合，表示某个资源的具体实例。它可以是<code>Unity</code>引擎使用的任何类型的资源，例如网格，<code>Sprite</code>，音频剪辑或动画剪辑。所有的对象都是<code>UnityEngine.Object</code>基类的子类</li>
<li>资源（<code>Asset</code>）与对象（<code>Object</code>）是一种一对多的关系，即一个资源文件可能会包括多个<code>Object</code></li>
</ul>
<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><ul>
<li><code>GUID</code>（<code>Globally Unique Identifier</code>）：也称<code>File ID</code>是资源的唯一标识符，用于记录资源之间的引用关系</li>
<li><code>GUID</code>存储于<code>.meta</code>文件中。<code>Unity</code>会为每一个加入到<code>Assets</code>文件夹中的文件，创建一个<strong>同级同名</strong>的<code>.meta</code>文件，虽然文件类型的不同会影响这个<code>.meta</code>的具体内容，但它们都包含一个<strong>用来标记文件身份的<code>GUID</code></strong></li>
<li>一个名为<code>Cube</code>预制体的<code>.meta</code>文件（<code>Cube.prefab.meta</code>）的文本如下<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">fileFormatVersion: <span class="number">2</span></span><br><span class="line">guid: <span class="number">8</span>ce36e014f775544781668b6c3c3985f  <span class="comment">//存储了该文件的guid</span></span><br><span class="line">PrefabImporter:</span><br><span class="line">  externalObjects: &#123;&#125;</span><br><span class="line">  userData: </span><br><span class="line">  assetBundleName: </span><br><span class="line">  assetBundleVariant: </span><br></pre></td></tr></table></figure></li>
<li>一个名为<code>CubeMaterial</code>材质的<code>.meta</code>文件（<code>CubeMaterial.mat.meta</code>）的文本如下<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">fileFormatVersion: <span class="number">2</span></span><br><span class="line">guid: <span class="number">85b</span>fbb63af5ee124ab56fba18dea4918  <span class="comment">//存储了该文件的guid</span></span><br><span class="line">NativeFormatImporter:</span><br><span class="line">  externalObjects: &#123;&#125;</span><br><span class="line">  mainObjectFileID: <span class="number">2100000</span> <span class="comment">//由于Material为非序列化文件，所以.meta文件中也存储了Local ID</span></span><br><span class="line">  userData: </span><br><span class="line">  assetBundleName: </span><br><span class="line">  assetBundleVariant: </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Local-ID"><a href="#Local-ID" class="headerlink" title="Local ID"></a>Local ID</h1><ul>
<li><code>Local ID</code>（本地<code>ID</code>）：每个文件自已存储所需要的<code>Local GUID</code>。文件内部各对象之间的关系，<strong>用于标识资源内部之间引用的资源</strong></li>
<li>前面有<code>&amp;</code>符号的数字就是<code>Local GUID</code></li>
<li>每一个<code>Local ID</code>也表示这它将来也会被实例化成一个对象</li>
<li>一个名为<code>CubeMaterial</code>材质的文件（<code>CubeMaterial.mat</code>）的文本如下<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">%YAML <span class="number">1.1</span></span><br><span class="line">%TAG !u! tag:unity3d.com,<span class="number">2011</span>:</span><br><span class="line">--- !u!<span class="number">21</span> &amp;<span class="number">2100000</span>  <span class="comment">//Local GUID</span></span><br><span class="line">Material:</span><br><span class="line">  serializedVersion: <span class="number">6</span></span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_Name: CubeMaterial</span><br><span class="line">  m_Shader: &#123;fileID: <span class="number">46</span>, guid: <span class="number">0000000000000000f</span>000000000000000, type: <span class="number">0</span>&#125;</span><br><span class="line">  m_ShaderKeywords: </span><br><span class="line">  m_LightmapFlags: <span class="number">4</span></span><br><span class="line">  m_EnableInstancingVariants: <span class="number">0</span></span><br><span class="line">  m_DoubleSidedGI: <span class="number">0</span></span><br><span class="line">  m_CustomRenderQueue: <span class="number">-1</span></span><br><span class="line">  stringTagMap: &#123;&#125;</span><br><span class="line">  disabledShaderPasses: []</span><br><span class="line">  m_SavedProperties:</span><br><span class="line">    serializedVersion: <span class="number">3</span></span><br><span class="line">    m_TexEnvs:</span><br><span class="line">    - _BumpMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _DetailAlbedoMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _DetailMask:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _DetailNormalMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _EmissionMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _MainTex:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _MetallicGlossMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _OcclusionMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    - _ParallaxMap:</span><br><span class="line">        m_Texture: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">        m_Scale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;</span><br><span class="line">        m_Offset: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span><br><span class="line">    m_Ints: []</span><br><span class="line">    m_Floats:</span><br><span class="line">    - _BumpScale: <span class="number">1</span></span><br><span class="line">    - _Cutoff: <span class="number">0.5</span></span><br><span class="line">    - _DetailNormalMapScale: <span class="number">1</span></span><br><span class="line">    - _DstBlend: <span class="number">0</span></span><br><span class="line">    - _GlossMapScale: <span class="number">1</span></span><br><span class="line">    - _Glossiness: <span class="number">0.5</span></span><br><span class="line">    - _GlossyReflections: <span class="number">1</span></span><br><span class="line">    - _Metallic: <span class="number">0</span></span><br><span class="line">    - _Mode: <span class="number">0</span></span><br><span class="line">    - _OcclusionStrength: <span class="number">1</span></span><br><span class="line">    - _Parallax: <span class="number">0.02</span></span><br><span class="line">    - _SmoothnessTextureChannel: <span class="number">0</span></span><br><span class="line">    - _SpecularHighlights: <span class="number">1</span></span><br><span class="line">    - _SrcBlend: <span class="number">1</span></span><br><span class="line">    - _UVSec: <span class="number">0</span></span><br><span class="line">    - _ZWrite: <span class="number">1</span></span><br><span class="line">    m_Colors:</span><br><span class="line">    - _Color: &#123;r: <span class="number">1</span>, g: <span class="number">1</span>, b: <span class="number">1</span>, a: <span class="number">1</span>&#125;</span><br><span class="line">    - _EmissionColor: &#123;r: <span class="number">0</span>, g: <span class="number">0</span>, b: <span class="number">0</span>, a: <span class="number">1</span>&#125;</span><br><span class="line">  m_BuildTextureStacks: []</span><br></pre></td></tr></table></figure></li>
<li>一个名为<code>Cube</code>预制体添加一个<code>CubeMaterial</code>材质的文件（<code>Cube.prefab</code>）的文本如下<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//说明：当一个prefab文件要实例化成一个GameObject时，它会自动尝试获取其内部Local ID所指的那个对象。如果这个所指的对象当前还没有被实例化出来，那么Unity会自动实例化这个对象，如此递归，直到所有涉及的对象都被实例化</span></span><br><span class="line">%YAML <span class="number">1.1</span></span><br><span class="line">%TAG !u! tag:unity3d.com,<span class="number">2011</span>:</span><br><span class="line">--- !u!<span class="number">1</span> &amp;<span class="number">925580494856103128</span>    <span class="comment">//Local GUID</span></span><br><span class="line">GameObject:</span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  serializedVersion: <span class="number">6</span></span><br><span class="line">  m_Component:</span><br><span class="line">  - component: &#123;fileID: <span class="number">2748689351619311468</span>&#125;    <span class="comment">//Transform组件的fileID</span></span><br><span class="line">  - component: &#123;fileID: <span class="number">4587065638300692396</span>&#125;    <span class="comment">//MeshFilter的fileID</span></span><br><span class="line">  - component: &#123;fileID: <span class="number">38850410793734356</span>&#125;      <span class="comment">//MeshRenderer的fileID</span></span><br><span class="line">  - component: &#123;fileID: <span class="number">6724204414190568704</span>&#125;    <span class="comment">//BoxCollider的fileID</span></span><br><span class="line">  m_Layer: <span class="number">0</span></span><br><span class="line">  m_Name: Cube</span><br><span class="line">  m_TagString: Untagged</span><br><span class="line">  m_Icon: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_NavMeshLayer: <span class="number">0</span></span><br><span class="line">  m_StaticEditorFlags: <span class="number">0</span></span><br><span class="line">  m_IsActive: <span class="number">1</span></span><br><span class="line">--- !u!<span class="number">4</span> &amp;<span class="number">2748689351619311468</span>   <span class="comment">//Local GUID</span></span><br><span class="line">Transform:</span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_GameObject: &#123;fileID: <span class="number">925580494856103128</span>&#125;</span><br><span class="line">  m_LocalRotation: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span>, w: <span class="number">1</span>&#125;</span><br><span class="line">  m_LocalPosition: &#123;x: <span class="number">41.22902</span>, y: <span class="number">54.217422</span>, z: <span class="number">313.52347</span>&#125;</span><br><span class="line">  m_LocalScale: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>, z: <span class="number">1</span>&#125;</span><br><span class="line">  m_ConstrainProportionsScale: <span class="number">0</span></span><br><span class="line">  m_Children: []</span><br><span class="line">  m_Father: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_RootOrder: <span class="number">0</span></span><br><span class="line">  m_LocalEulerAnglesHint: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span>&#125;</span><br><span class="line">--- !u!<span class="number">33</span> &amp;<span class="number">4587065638300692396</span>  <span class="comment">//Local GUID</span></span><br><span class="line">MeshFilter:</span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_GameObject: &#123;fileID: <span class="number">925580494856103128</span>&#125;</span><br><span class="line">  m_Mesh: &#123;fileID: <span class="number">10202</span>, guid: <span class="number">0000000000000000e000000000000000</span>, type: <span class="number">0</span>&#125;</span><br><span class="line">--- !u!<span class="number">23</span> &amp;<span class="number">38850410793734356</span>    <span class="comment">//Local GUID</span></span><br><span class="line">MeshRenderer:</span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_GameObject: &#123;fileID: <span class="number">925580494856103128</span>&#125;</span><br><span class="line">  m_Enabled: <span class="number">1</span></span><br><span class="line">  m_CastShadows: <span class="number">1</span></span><br><span class="line">  m_ReceiveShadows: <span class="number">1</span></span><br><span class="line">  m_DynamicOccludee: <span class="number">1</span></span><br><span class="line">  m_StaticShadowCaster: <span class="number">0</span></span><br><span class="line">  m_MotionVectors: <span class="number">1</span></span><br><span class="line">  m_LightProbeUsage: <span class="number">1</span></span><br><span class="line">  m_ReflectionProbeUsage: <span class="number">1</span></span><br><span class="line">  m_RayTracingMode: <span class="number">2</span></span><br><span class="line">  m_RayTraceProcedural: <span class="number">0</span></span><br><span class="line">  m_RenderingLayerMask: <span class="number">1</span></span><br><span class="line">  m_RendererPriority: <span class="number">0</span></span><br><span class="line">  m_Materials:  <span class="comment">//下面的guid为CubeMaterial.mat文件的guid，可在.meta文件查找到。fileID为Local ID。根据这两个可以找到CubeMaterial.mat文件下的Material。该材质的唯一标识符由guid和fileID共同决定</span></span><br><span class="line">                <span class="comment">//所以该材质的唯一标识符号是文件guid&quot;85bfbb63af5ee124ab56fba18dea4918&quot;和Local ID&quot;2100000&quot;的组合</span></span><br><span class="line">  - &#123;fileID: <span class="number">2100000</span>, guid: <span class="number">85b</span>fbb63af5ee124ab56fba18dea4918, type: <span class="number">2</span>&#125;</span><br><span class="line">  m_StaticBatchInfo:</span><br><span class="line">    firstSubMesh: <span class="number">0</span></span><br><span class="line">    subMeshCount: <span class="number">0</span></span><br><span class="line">  m_StaticBatchRoot: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_ProbeAnchor: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_LightProbeVolumeOverride: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_ScaleInLightmap: <span class="number">1</span></span><br><span class="line">  m_ReceiveGI: <span class="number">1</span></span><br><span class="line">  m_PreserveUVs: <span class="number">0</span></span><br><span class="line">  m_IgnoreNormalsForChartDetection: <span class="number">0</span></span><br><span class="line">  m_ImportantGI: <span class="number">0</span></span><br><span class="line">  m_StitchLightmapSeams: <span class="number">1</span></span><br><span class="line">  m_SelectedEditorRenderState: <span class="number">3</span></span><br><span class="line">  m_MinimumChartSize: <span class="number">4</span></span><br><span class="line">  m_AutoUVMaxDistance: <span class="number">0.5</span></span><br><span class="line">  m_AutoUVMaxAngle: <span class="number">89</span></span><br><span class="line">  m_LightmapParameters: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_SortingLayerID: <span class="number">0</span></span><br><span class="line">  m_SortingLayer: <span class="number">0</span></span><br><span class="line">  m_SortingOrder: <span class="number">0</span></span><br><span class="line">  m_AdditionalVertexStreams: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">--- !u!<span class="number">65</span> &amp;<span class="number">6724204414190568704</span>  <span class="comment">//Local GUID</span></span><br><span class="line">BoxCollider:</span><br><span class="line">  m_ObjectHideFlags: <span class="number">0</span></span><br><span class="line">  m_CorrespondingSourceObject: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabInstance: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_PrefabAsset: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_GameObject: &#123;fileID: <span class="number">925580494856103128</span>&#125;</span><br><span class="line">  m_Material: &#123;fileID: <span class="number">0</span>&#125;</span><br><span class="line">  m_IsTrigger: <span class="number">0</span></span><br><span class="line">  m_Enabled: <span class="number">1</span></span><br><span class="line">  serializedVersion: <span class="number">2</span></span><br><span class="line">  m_Size: &#123;x: <span class="number">1</span>, y: <span class="number">1</span>, z: <span class="number">1</span>&#125;</span><br><span class="line">  m_Center: &#123;x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Instance-ID"><a href="#Instance-ID" class="headerlink" title="Instance ID"></a>Instance ID</h1><ul>
<li><code>Instance ID</code>是资源的快捷访问<code>ID</code>，它只由数字组成，直接使用<code>Instance ID</code>去查找，减少查找开销。由<code>File GUID</code>和<code>Local ID</code>转换而成</li>
<li><code>Unity</code>编辑器会在项目启动后，创建并一直维护一张“映射表”，这张映射表记录的就是<code>File GUID</code>、<code>Local ID</code>以及由它们转换而成的<code>Instance ID</code>之间的关系</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>对于非序列化的文件，由于不会更改源文件，所以<code>GUID</code>和子文件的<code>Local ID</code>都存储在<code>.meta</code>文件中，如<code>FBX</code>文件、图集、<code>Material</code>等；对于序列化文件，<code>.meta</code>文件中只有自身的<code>GUID</code>，如<code>AnimatorController</code>、<code>prefab</code>等</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw">程序丨入门必看：Unity资源加载及管理</a></li>
<li><a href="https://www.cnblogs.com/zhaoqingqing/p/5823927.html">玩转Unity资源，对象和序列化(上) </a></li>
<li><a href="https://blog.uwa4d.com/archives/USparkle_inf_UnityEngine.html">Unity文件、文件引用、Meta详解</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity 协程</title>
    <url>/2022/06/16/unity%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>协程的官方定义：即协程是一个分部执行，遇到条件（<code>yield return</code>语句）会挂起，直到条件满足才会被唤醒继续执行后面的代码</li>
<li><code>Unity</code>的协程(<code>Coroutine</code>)是在主线程上开启的一段逻辑，运行在主线程上</li>
<li><code>Unity</code>协程分为两部分：</li>
</ul>
<ol>
<li>协程函数本体</li>
<li>协程调度器：对所有的迭代器函数进行统一管理</li>
</ol>
<ul>
<li>作用：控制代码在特定的时机执行</li>
<li>缺点</li>
</ul>
<ol>
<li>协程本质是迭代器（遍历容器的对象），是基于<code>Unity</code>的生命周期的，大量开启协程会引起<code>GC</code></li>
<li>协同程序无法返回数据</li>
<li>协同程序使错误处理变得困难。不能将<code>yield</code>放在<code>try-catch</code>中，因此无法处理异常</li>
<li>协程依赖于<code>MonoBehaviour</code>生命周期</li>
</ol>
<ul>
<li><code>Unity</code>中协程定义如下：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>协程的形式如下：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值为IEnumerator类型，名为fun的协程</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Fun</span>()</span>	</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1&quot;</span>);     <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;	<span class="comment">//暂停一帧后继续执行</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;2&quot;</span>);     <span class="comment">//输出2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;        <span class="comment">//退出协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> a</span>)	<span class="comment">//带参数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1&quot;</span>);     <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;	<span class="comment">//暂停一帧后继续执行</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;2&quot;</span>);     <span class="comment">//输出2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;        <span class="comment">//退出协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IL2CPP下的协程"><a href="#IL2CPP下的协程" class="headerlink" title="IL2CPP下的协程"></a>IL2CPP下的协程</h1></li>
<li>在<code>IL2CPP</code>转为<code>C++</code>代码，每个协程，生成一个对应的<code>struct</code>。（<code>IL2CPP</code>中没有<code>class</code>）</li>
<li>该<code>struct</code>保存两种信息：</li>
</ul>
<ol>
<li>协程的状态与相关信息</li>
<li>协程的局部变量</li>
</ol>
<ul>
<li><p>如下协程，生成的<code>struct</code>中会有三个成员变量，sum、a、s分别对应___sum_2、___U3CaU3E5__1_4、___U3CsU3E5__2_5</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> sum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">    Debug.Log(a);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    Debug.Log(sum);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        s += a.ToString();</span><br><span class="line">        Debug.Log(s);</span><br><span class="line">        ++a;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IL2CPP</span></span><br><span class="line"><span class="comment">// Test1/&lt;Fun&gt;d__2</span></span><br><span class="line"><span class="keyword">struct</span> U3CFunU3Ed__2_t57C421981E8A3776DD9D614C6CBF30E0D21BE675  : <span class="keyword">public</span> RuntimeObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// System.Int32 Test1/&lt;Fun&gt;d__2::&lt;&gt;1__state</span></span><br><span class="line">	int32_t ___U3CU3E1__state_0;</span><br><span class="line">	<span class="comment">// System.Object Test1/&lt;Fun&gt;d__2::&lt;&gt;2__current</span></span><br><span class="line">	RuntimeObject* ___U3CU3E2__current_1;</span><br><span class="line">	<span class="comment">// System.Int32 Test1/&lt;Fun&gt;d__2::sum</span></span><br><span class="line">	int32_t ___sum_2;</span><br><span class="line">	<span class="comment">// Test1 Test1/&lt;Fun&gt;d__2::&lt;&gt;4__this</span></span><br><span class="line">	Test1_t1205A85B8762380CF31423564330DFE2F393D995* ___U3CU3E4__this_3;</span><br><span class="line">	<span class="comment">// System.Int32 Test1/&lt;Fun&gt;d__2::&lt;a&gt;5__1</span></span><br><span class="line">	int32_t ___U3CaU3E5__1_4;</span><br><span class="line">	<span class="comment">// System.String Test1/&lt;Fun&gt;d__2::&lt;s&gt;5__2</span></span><br><span class="line">	String_t* ___U3CsU3E5__2_5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，协程如果一直运行，局部变量不会被释放，因为局部变量变为<code>struct</code>中的成员变量。所以要避免协程一直运行，导致性能降低</p>
</li>
</ul>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>同一时刻、一个脚本实例中可以有多个暂停的协程，但只有一个运行着的协程</li>
<li><code>IEnumerator</code>类型的方法不能带 <code>ref</code> 或者 <code>out</code> 型的参数</li>
<li>协程只能在普通方法开启，不能在静态方法开启。开启协程函数的本质是<code>Monobehaviour</code>的一个普通方法，而静态方法只能调用静态方法，不能调用普通方法</li>
<li>如果在协程里调用<code>Sleep</code>函数，会导致主线程运行停止。因为协程运行在主线程当中<h1 id="关键词-IEnumerator"><a href="#关键词-IEnumerator" class="headerlink" title="关键词 IEnumerator"></a>关键词 IEnumerator</h1></li>
<li>协程是通过迭代器来实现功能的。<code>IEnumerator</code>：是一个实现迭代器功能的接口，由一个属性和两个方法组成，定义如下：<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">    Object Current&#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>Current</code>属性可以获取集合中当前迭代位置的元素</strong></li>
<li><strong><code>MoveNext</code>方法将当前迭代位置推进到下一个位置，如果成功推进到下一个位置则返回<code>true</code>，否则已经推进到集合的末尾返回<code>false</code></strong></li>
<li><strong><code>Reset</code>方法可以将当前迭代位置设置为初始位置</strong>（该位置位于集合中第一个元素之前，所以当调用<code>Reset</code>方法后，再调用<code>MoveNext</code>方法，<code>Curren</code>值则为集合的第一个元素）</li>
<li>最开始，枚举数被定为在集合的第一个元素前面，<code>Reset</code>操作就是将枚举数返回到此位置。迭代器在执行迭代的时候，首先会执行一个 <code>MoveNext</code>， 如果返回<code>true</code>，说明下一个位置有对象，才可以访问<code>Current</code>，然后此时将<code>Current</code>设置为下一个对象，这时候的<code>Current</code>就指向了下一个对象。</li>
</ul>
<h1 id="关键词-yield"><a href="#关键词-yield" class="headerlink" title="关键词 yield"></a>关键词 yield</h1><ul>
<li><code>yield</code>是<code>C#</code>的关键字，是快速定义迭代器的语法糖</li>
<li>只要是<code>yield</code>出现在其中的方法就会被编译器自动编译成一个迭代器，对于这样的函数可以称之为迭代器函数。迭代器函数的返回值就是自动生成的迭代器类的一个对象。如果没有<code>yield</code>关键字，我们每定义一个迭代器，就要创建一个类，实现<code>IEnumerator</code>接口，接口包含的属性与方法都要正确的实现</li>
<li><code>yield return null;</code> 暂停协程等待下一帧继续执行</li>
<li><code>yield return 0或其他数字;</code> 暂停协程等待下一帧继续执行</li>
<li><code>yield return new WairForSeconds(1f);</code> 等待<code>1</code>秒后继续执行。会受到<code>Time.Scale</code>影响，当<code>Time.Scale</code>为<code>0</code>时，<code>WaitForSeconds</code>将失效</li>
<li><code>yield return new WaitForSecondsRealtime(1f)</code> 等待<code>1</code>秒后继续执行。不会受到<code>Time.Scale</code>影响</li>
<li><code>yield return StartCoroutine(Test1());</code> 开启协程<code>Test1()</code>，直至协程<code>Test1()</code>执行完毕，才继续执行</li>
<li><code>yield return new WaitForFixedUpdate();</code>	等待所有脚本的<code>FixUpdate</code>执行完毕后继续执行</li>
<li><code>yield return new WaitForEndOfFrame();</code> 在<code>ONGUI()</code>后执行，即等待渲染周期循环结束后执行</li>
<li><code>yield return WWW();</code> 等待<code>WWW</code>操作完成后再执行后续代码</li>
<li><code>yield break;</code> 终止迭代，即中止协程</li>
<li>协程结束的标志：如果最后一个<code>yield return</code>的<code>IEnumerator</code>已经迭代到最后一个时，<code>MoveNext</code>就会返回<code>false</code>。这时，<code>Unity</code>就会将这个<code>IEnumerator</code>从<code>coroutine list</code>中移除</li>
</ul>
<h1 id="开启协程"><a href="#开启协程" class="headerlink" title="开启协程"></a>开启协程</h1><ul>
<li>只能通过<code>StartCoroutine</code>来开启协程，有两种方式</li>
</ul>
<ol>
<li><code>StartCoroutine(FunctionName());</code> <code>FunctionName</code>为函数名字。使用<strong>传递函数</strong>的方式开启协程</li>
<li><code>StartCoroutine(&quot;FunctionName&quot;);</code>或<code>StartCoroutine(&quot;FunctionName&quot;,参数);</code>该写法的缺点是<strong>启动协程时的运行时开销更高</strong>，并且<strong>只能传递一个参数</strong>。使用<strong>传递字符串</strong>的形式开启协程</li>
</ol>
<h1 id="停止协程"><a href="#停止协程" class="headerlink" title="停止协程"></a>停止协程</h1><ul>
<li>停止协程有五种方式</li>
</ul>
<ol>
<li><code>StopCoroutine(&quot;FunctionName&quot;);</code> 使用传递字符串的方式停止协程,只能用于停止使用传递字符串的形式开启的协程</li>
<li><code>StopAllCoroutines();</code>  停止该类中所有的协程</li>
<li><code>gameObject.SetActive(false);</code>或 <code>Destroy(gameobject)</code>或<code>Destory(this);</code> 禁用&#x2F;销毁游戏对象,或者销毁脚本组件可以停止协程，当物体被再次激活时，协程不会继续执行。但是<code>this.enabled = false; </code>禁用脚本组件不能停止协程</li>
<li>在协程内部添加<code>yield break;</code> 来停止协程</li>
<li>获取返回值方式。不管使用哪种方式启动协程，都可以结束其返回值用以停止对应协程<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Coroutine stopCor_1;        </span><br><span class="line"><span class="keyword">private</span> Coroutine stopCor_2;        </span><br><span class="line"></span><br><span class="line">stopCor_1 = StartCoroutine(<span class="string">&quot;Cor_1&quot;</span>);</span><br><span class="line">stopCor_2 = StartCoroutine(Cor_2());</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止协程</span></span><br><span class="line">StopCoroutine(stopCor_1);</span><br><span class="line">StopCoroutine(stopCor_2); </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li><code>yield</code>在协程中不会分配堆内存，但是，如果<code>yield</code>带有参数返回，则会产生不必要的内存垃圾，例如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于需要返回<code>0</code>，引发装箱操作（返回类型是接口，接口是引用类型），所以会产生内存垃圾。这种情况下，为了避免内存垃圾，可以这样返回：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>另外一种对协程的错误使用是每次返回的时候都新建同一个变量，例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以采用缓存来避免产生这样的内存垃圾，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(<span class="number">1f</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>获取返回值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Surprise&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IEnumerator enumerator = Test();  <span class="comment">// 直接调用迭代器函数不会执行方法的主体，而是返回迭代器对象</span></span><br><span class="line"><span class="built_in">bool</span> ret = enumerator.MoveNext();</span><br><span class="line">Debug.Log(ret + <span class="string">&quot; &quot;</span> + enumerator.Current);  <span class="comment">// (1)打印：True 1</span></span><br><span class="line">ret = enumerator.MoveNext();</span><br><span class="line"><span class="comment">// (2)打印：Surprise</span></span><br><span class="line">Debug.Log(ret + <span class="string">&quot; &quot;</span> + enumerator.Current);  <span class="comment">// (3)打印：True 3</span></span><br><span class="line">ret = enumerator.MoveNext();</span><br><span class="line">Debug.Log(ret + <span class="string">&quot; &quot;</span> + enumerator.Current);  <span class="comment">// (4)打印：False 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)(<span class="number">3</span>)(<span class="number">4</span>)处的打印都没有问题，(<span class="number">1</span>)(<span class="number">3</span>)正确打印出了返回的值，(<span class="number">4</span>)是因为迭代被<span class="keyword">yield</span> <span class="keyword">break</span>终止了，所以MoveNext返回了<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">重点关注(<span class="number">2</span>)打印的位置，是在第二次调用MoveNext函数之后触发的，也就是说如果不调用第二次的MoveNext，(<span class="number">2</span>)打印将不会被触发，也意味着Debug.Log(<span class="string">&quot;Surprise&quot;</span>)这句代码不会被执行。表现上来看<span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>好像把代码“停住”了，当再次调用MoveNext方法后，代码又从“停住”的地方继续执行了</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件函数的执行顺序</p>
</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/unity%E5%8D%8F%E7%A8%8B/%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg?raw=true"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/zblade/p/9857808.html">Unity协程coroutine浅析</a></li>
<li><a href="https://docs.unity.cn/cn/2021.3/Manual/Coroutines.html">协程 - Unity 手册</a></li>
<li><a href="https://blog.sunweizhe.cn/2020/05/08/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Unity%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">深入剖析 Unity 协程的实现原理</a></li>
<li><a href="https://www.bilibili.com/video/BV1p14y1L7h5/?spm_id_from=333.999.0.0&vd_source=d2d44d4ce8893453aa70df7d2d5f6651">(bilibili)Untiy - 8月12日 —豆知识—匿名类</a></li>
<li>《Unity3D 高级编程：主程手记》</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2023/03/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>代理模式：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong></li>
<li>代理模式属于结构型模式</li>
<li>优点：</li>
</ul>
<ol>
<li>职责清晰</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理</li>
<li>当客户端对象需要访问远程主机中的对象时可以使用远程代理</li>
<li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象对象：<strong>它声明了真实对象和代理对象的共同接口</strong>，这样一来在任何使用真实对象的地方都可以使用代理对象，客户端通常需要针对抽象对象角色进行编程</li>
<li>代理对象：<strong>代理对象与真实对象实现相同的接口，所以它能够在任何时刻都能够代理真实对象</strong>。代理对象内部包含有对真实对象的引用，所以她可以操作真实对象，同时也可以附加其他的操作，相当于对真实对象进行封装</li>
<li>真实对象：它定义了所代表的真实对象，在真实对象角色中实现了真实的业务操作，客户端可以通过代理对象间接调用真实对象中定义的操作</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/proxy.gif?raw=true"></p>
<ul>
<li>注意事项：</li>
</ul>
<ol>
<li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </li>
<li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Request</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Proxy</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span>(<span class="params">RealSubject r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        realSubject = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        realSubject.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealSubject</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;获取请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(realSubject);</span><br><span class="line"></span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.runoob.com/design-pattern/proxy-pattern.html">代理模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511886">C#设计模式笔记之代理模式 (Proxy Pattern)</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Proxy%20Pattern">代理模式</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Unity UGUI</title>
    <url>/2022/11/29/Unity-UGUI/</url>
    <content><![CDATA[<h1 id="六大基础组件"><a href="#六大基础组件" class="headerlink" title="六大基础组件"></a>六大基础组件</h1><ul>
<li><code>Canvas</code>对象上依附的</li>
</ul>
<ol>
<li><code>Canvas</code>：画布组件，主要用于渲染<code>UI</code>控件</li>
<li><code>Canvas Scaler</code>：画布分辨率自适应组件，主要用于分辨率自适应</li>
<li><code>Graphic Raycaster</code>：射线事件交互组件，主要用于控制射线响应相关</li>
<li><code>RectTransform</code>：<code>UI</code>对象位置锚点控制组件，主要用于控制位置和对其方式</li>
</ol>
<ul>
<li><code>EventSystem</code>对象上依附的</li>
</ul>
<ol start="5">
<li><code>EventSystem</code>：玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作</li>
<li><code>Standalone Input Modul</code>：玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作</li>
</ol>
<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><ul>
<li><code>Canvas</code>主要作用：<strong>渲染和合并<code>UI</code>元素</strong></li>
<li><code>Canvas</code>的三种渲染方式</li>
</ul>
<ol>
<li><code>Screen Space - Overlay</code>：屏幕空间，覆盖模式，<code>UI</code>始终在前</li>
<li><code>Screen Space - Camera</code>：屏幕空间，摄像机模式，<code>3D</code>物体可以显示在<code>UI</code>之前</li>
<li><code>World Space</code>：世界空间，<code>3D</code>模式</li>
</ol>
<hr>
<ul>
<li><code>Screen Space - Overlay</code>：覆盖模式，<code>UI</code>始终显示在场景内容前方</li>
</ul>
<ol>
<li>**<code>Pixel Perfect</code>**：是否开启无锯齿精确渲染（性能换效果）</li>
<li>**<code>SortOrder</code>**：排序层编号（用于控制多个<code>Canvas</code>时的渲染先后顺序）</li>
<li><code>TargetDisplay</code>：目标设备（在哪个显示设备上显示）</li>
<li><code>Additional Shader Channels</code>：其他着色器通道，决定着色器可以读取哪些数据</li>
</ol>
<hr>
<ul>
<li><code>Screen Space - Camera</code>：摄像机模式，<code>3D</code>物体可以显示在<code>UI</code>之前</li>
</ul>
<ol>
<li>**<code>RenderCamera</code>**：用于渲染UI的摄像机（如果不设置将类似于覆盖模式）</li>
<li>**<code>Plane Distance</code>**：<code>UI</code>平面在摄像机前方的距离，类似整体<code>Z</code>轴的感觉</li>
<li>**<code>Sorting Layer</code>**：所在排序层</li>
<li>**<code>Order in Layer</code>**：排序层的序</li>
</ol>
<hr>
<ul>
<li><code>World Space</code>：世界空间，<code>3D</code>模式，可以把<code>UI</code>对象像<code>3D</code>物体一样处理，常用<code>VR</code>或者<code>AR</code></li>
</ul>
<ol>
<li><code>Event Camera</code>：用于处理UI事件的摄像机（如果不设置，不能正常注册<code>UI</code>事件）</li>
<li><code>Dynamic Pixels Per Unit</code>：<code>UI</code>中动态创建的位图（例如文本）中，单位像素数（类似密度）</li>
<li><code>Reference Pixels Per Unit</code>：单位参考像素，多少像素对应<code>Unity</code>中的一个单位（默认一个单位为<code>100</code>像素</li>
</ol>
<h1 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h1><ul>
<li><code>Canvas Scaler</code>意思是画布缩放控制器，它主要<strong>负责在不同分辨率下<code>UI</code>控件大小自适应，即可指定画布中元素的比例大小</strong>，提供了三种用于分辨率自适应的模式</li>
</ul>
<ol>
<li><code>Constant Pixel Size</code>（恒定像素模式）</li>
<li><code>Scale With Screen Size</code>（缩放模式）</li>
<li><code>Constant Physical Size</code>（恒定物理模式）</li>
</ol>
<ul>
<li>屏幕分辨率：当前设备的分辨率。会参与分辨率自适应的计算</li>
<li>画布大小和缩放系数：宽高*缩放系数 &#x3D; 屏幕分辨率</li>
<li><code>Reference Resolution</code>：参考分辨率。在缩放模式的宽高模式中出现的参数，参与分辨率自适应的计算</li>
<li>分辨率大小自适应——通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，<br>该结果会影响所有<code>UI</code>控件的缩放大小</li>
</ul>
<hr>
<ul>
<li><code>Constant Pixel Size</code>（恒定像素模式）：<strong>无论屏幕大小如何，<code>UI</code>始终保持相同像素大小</strong></li>
</ul>
<ol>
<li><code>Scale Factor</code>：缩放系数，按此系数缩放画布中的所有<code>UI</code>元素</li>
<li><code>Reference Pixels Per Unit</code>：单位参考像素，多少像素对应<code>Unity</code>中的一个单位（默认一个单位为<code>100</code>像素）。图片设置中的<code>Pixels Per Unit</code>设置，会和该参数一起参与计算</li>
<li>恒定像素模式计算公式：<code>UI</code>原始尺寸 &#x3D;<br>图片大小（像素）&#x2F; (<code>Pixels Per Unit</code> &#x2F; <code>Reference Pixels Per Unit</code>)</li>
</ol>
<hr>
<ul>
<li><code>Scale With Screen Size</code>（缩放模式）：根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小</li>
</ul>
<ol>
<li><code>Reference Resolution</code>：参考分辨率（出图的标准分辨率）<br>缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算</li>
<li><code>Screen Match Mode</code>：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式</li>
</ol>
<ul>
<li>缩放模式中的三种匹配方式：</li>
</ul>
<ol>
<li><code>Expand</code>：水平或垂直<strong>拓展画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能有黑边。即<strong>会将<code>Canvas</code>的画布大小设置得比参考分辨率<code>Reference Resolution</code>大。目的是完整地显示UI</strong></li>
</ol>
<p>将<code>Canvas Size</code>进行宽或高扩大，让它高于参考分辨率</p>
<p>计算公式：<br>缩放系数 &#x3D; <code>Mathf.Min</code>(屏幕宽&#x2F;参考分辨率宽，屏幕高&#x2F;参考分辨率高)</p>
<p>画布尺寸 &#x3D; 屏幕尺寸 &#x2F; 缩放系数</p>
<p>表现效果：最大程度的缩小<code>UI</code>元素，**完全显示<code>UI</code>**，保留<code>UI</code>控件所有细节，可能会留黑边</p>
<ol start="2">
<li><code>Shrink</code>：水平或垂直<strong>裁剪画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会裁剪。即<strong>会将<code>Canvas</code>的画布大小设置得比参考分辨率<code>Reference Resolution</code>小。目的是让UI填满画面</strong></li>
</ol>
<p>将<code>Canvas Size</code>进行宽或高收缩，让它低于参考分辨率</p>
<p>计算公式：<br>缩放系数 &#x3D; <code>Mathf.Max</code>(屏幕宽&#x2F;参考分辨率宽，屏幕高&#x2F;参考分辨率高)</p>
<p>画布尺寸 &#x3D; 屏幕尺寸 &#x2F; 缩放系数</p>
<p>表现效果：最大程度的放大<code>UI</code>元素，让<code>UI</code>元素能够填满画面，可能会出现裁剪</p>
<ol start="3">
<li><code>Match Width Or Height</code>：<strong>以宽高或者二者的平均值作为参考</strong>来缩放画布区域。<strong>画布大小发生变化时，<code>UI</code>尺寸不变</strong></li>
</ol>
<ul>
<li><p><code>Match</code>：确定用于计算的宽高匹配值</p>
</li>
<li><p>要用于只有横屏模式或者竖屏模式的游戏</p>
</li>
<li><p>竖屏游戏：<code>Match = 0</code><br>将画布宽度设置为参考分辨率的宽度，<strong>即画布宽度不变，与屏幕比例相同算出画布高度</strong><br>并保持比例不变，屏幕越高可能会有黑边。</p>
</li>
<li><p>横屏游戏：<code>Match = 1</code><br>将画布高度设置为参考分辨率的高度，<strong>即画布高度不变，与屏幕比例相同算出画布宽度</strong><br>并保持比例不变，屏幕越长可能会有黑边。</p>
</li>
<li><p>总结</p>
</li>
</ul>
<p>游戏开发一般使用<br><code>Scale With Screen Size</code>缩放模式</p>
<p>使用建议<br>存在横竖屏切换选择：<br><code>Expand</code>（拓展匹配，有黑边）和 <code>Shrink</code>（收缩匹配，有裁剪）<br>不存在横竖屏切换（定死的横屏或者竖屏游戏）：<br><code>Match Width or Height</code>（宽高匹配）<br>横屏游戏 <code>Match = 0</code><br>竖屏游戏 <code>Match = 1</code></p>
<hr>
<ul>
<li><code>Constant Physical Size</code>（恒定物理模式）：<strong>无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小</strong></li>
<li>目的：相同像素大小在不同<code>DPI</code>设备上保持相同大小</li>
</ul>
<ol>
<li><code>DPI</code>：（<code>Dots Per Inch</code>，每英寸点数）图像每英寸长度内的像素点数</li>
<li><code>Physical Unit</code>：物理单位，使用的物理单位种类</li>
<li><code>Fallback Screen DPI</code>：备用<code>DPI</code>，当找不到设备<code>DPI</code>时，使用此值</li>
<li><code>Default Sprite DPI</code>：默认图片<code>DPI</code></li>
</ol>
<ul>
<li><p>恒定像素模式和恒定物理模式区别</p>
</li>
<li><p>相同点：他们都不会进行缩放，图片有多大显示多大，使用他们不会进行分辨率大小自适应</p>
</li>
<li><p>不同点：相同尺寸不同<code>DPI</code>设备像素点区别，像素点越多细节越多<br>同样为<code>5</code>像素，<code>DPI</code>较低的设备上看起来的尺寸可能会大于<code>DPI</code>较高的设备</p>
</li>
</ul>
<h1 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h1><ul>
<li><code>Graphic Raycaster</code>：图形射线投射器。它是用于检测<code>UI</code>输入事件的射线发射器。它主要<strong>负责通过射线检测玩家和<code>UI</code>元素的交互</strong>，判断是否点击到了<code>UI</code>元素。它并不会检测<code>Canvas</code>以外的内容，只会检测<code>Canvas</code>下的元素</li>
</ul>
<ol>
<li><code>Ignore Reversed Graphics</code>：是否忽略反转图形</li>
<li><code>Blocking Objects</code>：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效）</li>
<li><code>Blocking Mask</code>：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效）</li>
</ol>
<h1 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h1><ul>
<li><code>Event System</code>意思是<strong>事件系统</strong>，它是<strong>用于管理玩家的输入事件并分发给各<code>UI</code>控件</strong></li>
</ul>
<ol>
<li><code>First Selected</code>：首先选择的游戏对象，可以设置游戏一开始的默认选择</li>
<li><code>Send Navigation Events</code>：是否允许导航事件（移动&#x2F;按下&#x2F;取消）</li>
<li><code>Drag Threshold</code>：拖拽操作的阈值（移动多少像素算拖拽）</li>
</ol>
<h1 id="Standalone-Input-Module"><a href="#Standalone-Input-Module" class="headerlink" title="Standalone Input Module"></a>Standalone Input Module</h1><ul>
<li><code>Standalone Input Module</code>意思是<strong>独立输入模块</strong>。它<strong>主要针对处理鼠标&#x2F;键盘&#x2F;控制器&#x2F;触屏（新版<code>Unity</code>）的输入</strong>。输入的事件通过<code>EventSystem</code>进行分发。它依赖于<code>EventSystem</code>组件，它们两缺一不可</li>
</ul>
<ol>
<li><code>Horizontal Axis</code>：水平轴按钮对应的热键名（该名字对应<code>Input</code>管理器）</li>
<li><code>Vertical Axis</code>：垂直轴按钮对应的热键名（该名字对应<code>Input</code>管理器）</li>
<li><code>Submit Button</code>：提交（确定）按钮对应的热建名（该名字对应<code>Input</code>管理器）</li>
<li><code>Cancel Button</code>：取消按钮对应的热建名（该名字对应<code>Input</code>管理器）</li>
<li><code>Input Actions Per Second</code>：每秒允许键盘&#x2F;控制器输入的数量</li>
<li><code>Repeat Delay</code>：每秒输入操作重复率生效前的延迟时间</li>
<li><code>ForceModule Active</code>：是否强制模块处于激活状态</li>
</ol>
<h1 id="RectTransform"><a href="#RectTransform" class="headerlink" title="RectTransform"></a><code>RectTransform</code></h1><ul>
<li>中心点<code>Pivot</code>的作用</li>
</ul>
<ol>
<li>与锚点进行偏移计算</li>
<li>缩放的参考点</li>
<li>旋转的参考点</li>
</ol>
<ul>
<li>锚点时的作用：位置自适应</li>
<li>锚框时的作用：大小自适应</li>
</ul>
<h1 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h1><ol>
<li><code>Image</code></li>
<li><code>Text</code></li>
<li><code>RawImage</code></li>
</ol>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><ol>
<li><code>Source Image</code>：图片来源（必须是精灵<code>Sprite</code>类型）</li>
<li><code>Color</code>：图像的颜色</li>
<li><code>Material</code>：图像的材质（一般不修改，会使用<code>UI</code>的默认材质）</li>
<li><code>Raycast Target</code>：是否作为射线检测的目标（不勾选则不会响应射线检测）</li>
<li><code>Maskable</code>：是否能被遮罩遮挡</li>
<li><code>Image Type</code>：图片类型。1）<code>Simple</code>-普通模式：均匀缩放整个图片；2）<code>Sliced</code>-切片模式：<code>9</code>宫格拉伸，只拉伸中央十字区域，<code>Pixels Per UnitMultiplier</code>：每单位像素乘数，<code>Fill Center</code>：中心填充；3）<code>Tiled</code>-平铺模式：重复平铺中央部分；4）<code>Filled</code>-填充模式。<code>Fill Method</code>：填充模式，<code>Fill Origin</code>：填充原点，<code>Fill Amount</code>：填充量，<code>Colckwise</code>：顺时针方向</li>
<li><code>Use Sprite Mesh</code>：使用精灵网格，勾选的话，<code>Unity</code>会生成图片网格</li>
<li><code>Preserve Aspect</code>：确保图像保持其现有尺寸</li>
<li><code>Set Native Size</code>：设置为图片资源的原始大小</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br><span class="line"><span class="comment">//加载图片</span></span><br><span class="line">img.sprite = Resources.Load&lt;Sprite&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//修改尺寸</span></span><br><span class="line">(transform <span class="keyword">as</span> RectTransform).sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h1 id="RawImage"><a href="#RawImage" class="headerlink" title="RawImage"></a>RawImage</h1><ul>
<li><code>RawImage</code>是原始图像组件，一般<code>RawImage</code>用于显示大图（背影图，不需要打入图集的图片，网络下载的图等）</li>
</ul>
<ol>
<li><code>Texture</code>：图像纹理（对图片类型不限制）</li>
<li><code>UV Rect</code>：图像在<code>UI</code>矩形内的偏移和大小。位置偏移<code>X</code>和<code>Y</code>（取值<code>0~1</code>），大小偏移<code>W</code>和<code>H</code>（取值<code>0~1</code>），改变它们图像边缘将进行拉伸来填充<code>UV</code>矩形周围的空间</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">RawImage raw = <span class="keyword">this</span>.GetComponent&lt;RawImage&gt;();</span><br><span class="line"><span class="comment">//加载图片</span></span><br><span class="line">raw.texture = Resources.Load&lt;Texture&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//修改UV</span></span><br><span class="line">raw.uvRect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Image</code>与<code>RawImage</code>的区别</li>
</ul>
<ol>
<li><code>Imgae</code>比<code>RawImage</code>更消耗性能</li>
<li><code>Image</code>只能使用<code>Sprite</code>属性的图片，但是<code>RawImage</code>什么样的都可以使用。即<code>Image</code>控件要求其纹理为精灵，而<code>RawImage</code>控件可以接受任何纹理</li>
<li><code>Image</code>适合放一些有操作的图片（裁剪、平铺、旋转等），针对<code>Image Type</code>属性</li>
<li><code>RawImage</code>只放单独展示的图片就可以，性能会比<code>Image</code>好很多</li>
<li><code>RawImage</code>支持设置我们的<code>uv</code>坐标。<code>Image</code>不支持（<code>UV Rect</code>：设置<code>UV</code>缩放，偏移（即只让图片显示一部分，可使用图集） 注意：<code>x</code>、<code>y</code>属性控制<code>UV</code>左右、上下偏移；<code>W</code>、<code>H</code>控制<code>UV</code>的重复次数。）</li>
<li><code>Imgae</code>支持图集；<code>RawImage</code>不支持图集</li>
</ol>
<h1 id="TextMeshPro"><a href="#TextMeshPro" class="headerlink" title="TextMeshPro"></a>TextMeshPro</h1><ul>
<li><code>TextMeshPro</code>与<code>Text</code>的区别</li>
</ul>
<ol>
<li><strong>渲染的方式不同</strong>。<code>UGUI</code>的<code>Text</code>使用了一张字体贴图，Unity把所有需要显示的字符放到了一张图集中，字符的形状是通过像素定义的。当我们放大时，像素不够用就会出现文字变模糊的情况；<code>TextMesh Pro</code>的<code>Text</code>使用了不同的技术来渲染文字，叫做<code>Signed Distance Field（SDF）</code></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMeshPro tmp;</span><br><span class="line">    <span class="keyword">public</span> Text t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><ul>
<li>默认的<code>Button</code>有两个对象，父对象为——<code>Button</code>组件依附对象 同时挂载了一个<code>Image</code>组件 作为按钮背景图，子对象——按钮文本（可选）</li>
</ul>
<ol>
<li><code>Interactable</code>：是否接受输入</li>
<li><code>Transition</code>：相应用户输入的过渡效果。</li>
</ol>
<p>1）<code>None</code>：没有状态变化效果</p>
<p>2）<code>ColorTint</code>：用颜色表示不同状态的变化。<code>TargetGraphic</code>：控制的目标图形；<code>Normal Color</code>：正常状态颜色；<code>Highlighted Color</code>：鼠标进入时显示高亮颜色；<code>Pressed Color</code>：按下颜色；<code>Selected Color</code>：选中的颜色；<code>Disabled Color</code>：<code>Interactable</code>被禁用时的颜色；<code>Color Multiplier</code>：颜色倍增器，过渡颜色乘以该值；<code>FadeDuration</code>：衰减持续时间，从一个状态到另一个状态需要的时间</p>
<p>3）<code>Sprite Swap</code>：用图片表示不同状态的变化</p>
<p>4）<code>Animation</code>：用动画表示不同状态的变化</p>
<ol start="3">
<li><code>Navigation</code>：导航模式，可以设置<code>UI</code>元素如何在播放模式中导航。1）<code>None</code>：无键盘导航；2）<code>Horizontal</code>：水平导航；3）<code>Verticval</code>：垂直导航；4）<code>Automatic</code>：自动导航；5）<code>Explicit</code>：指定周边控件导航。<code>Visualize</code>：可视化导航连线</li>
<li><code>Onclick</code>：单击执行的函数列表</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line">btn.onClick.AddListener();</span><br><span class="line">btn.onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//指定移除函数</span></span><br><span class="line">btn.onClick.RemoveListener();</span><br><span class="line"><span class="comment">//移除所有函数</span></span><br><span class="line">btn.onClick.RemoveAllListeners();</span><br></pre></td></tr></table></figure>

<h1 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h1><ul>
<li><code>Toggle</code>是开关组件，是<code>UGUI</code>中用于处理玩家单选框多选框相关交互的关键组件</li>
<li>开关组件默认是多选框，可以通过配合<code>ToggleGroup</code>组件制作为单选框</li>
<li>默认创建的<code>Toggle</code>由<code>4</code>个对象组成。父对象——<code>Toggle</code>组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）</li>
</ul>
<ol>
<li><code>isOn</code>：当前是否处于打开状态</li>
<li><code>Toggle Transition</code>：在开关值变化时的过渡方式。1）<code>None</code>：无任何过渡，直接显示隐藏；2）<code>Fade</code>：淡入淡出</li>
<li><code>Graphic</code>：用于表示选中状态的图片</li>
<li><code>Groud</code>：单选框分组</li>
<li><code>Toggle Groud - Allow Switch Off</code>：是否允许不选中任何一个单选框。注意单选框分组组件可以挂载在任何对象上，只需将其和一组的单选框关联即可</li>
<li><code>OnValueChanged</code>：开关状态变化时执行的函数列表</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Toggle tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br><span class="line">tog.isOn = <span class="literal">true</span>;</span><br><span class="line">print(tog.isOn);</span><br><span class="line"></span><br><span class="line">ToggleGroup togGroup = <span class="keyword">this</span>.GetComponent&lt;ToggleGroup&gt;();</span><br><span class="line">togGroup.allowSwitchOff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以遍历提供的迭代器 得到当前处于选中状态的 Toggle</span></span><br><span class="line"><span class="keyword">foreach</span> (Toggle item <span class="keyword">in</span> togGroup.ActiveToggles())</span><br><span class="line">&#123;</span><br><span class="line">    print(item.name + <span class="string">&quot; &quot;</span> + item.isOn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件的两种方式</span></span><br><span class="line"><span class="comment">//1.拖脚本</span></span><br><span class="line"><span class="comment">//2.代码添加</span></span><br><span class="line">tog.onValueChanged.AddListener(ChangeValue2);</span><br><span class="line">tog.onValueChanged.AddListener((b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听 状态改变&quot;</span> + b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangValue</span>(<span class="params"><span class="built_in">bool</span> isOn</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;状态改变&quot;</span> + isOn);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeValue2</span>(<span class="params"><span class="built_in">bool</span> v</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听 状态改变&quot;</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="InputField"><a href="#InputField" class="headerlink" title="InputField"></a>InputField</h1><ul>
<li><p><code>InputField</code>是输入字段组件，是<code>UGUI</code>中用于处理玩家文本输入相关交互的关键组件</p>
</li>
<li><p>默认创建的<code>InputField</code>由<code>3</code>个对象组成，父对象——<code>InputField</code>组件依附对象以及同时在其上挂载了一个<code>Image</code>作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）</p>
</li>
</ul>
<ol>
<li><code>On Value Changed(string)</code>：每次改变时调用的函数列表</li>
<li><code>On End Edit(string)</code>：结束改变时调用的函数列表</li>
<li><code>On Select(string)</code>：选中时调用的函数列表，重复选中不会多次调用</li>
<li><code>On Deselect(string)</code>：结束选中时调用的函数列表</li>
</ol>
<h1 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h1><ul>
<li><p><code>Slider</code>是滑动条组件，是<code>UGUI</code>中用于处理滑动条相关交互的关键组件</p>
</li>
<li><p>默认创建的<code>Slider</code>由<code>4</code>组对象组成。父对象——<code>Slider</code>组件依附的对象,子对象——背景图、进度图、滑动块三组对象</p>
</li>
</ul>
<ol>
<li><code>FillRect</code>：用于填充的进度条图形</li>
<li><code>Handle Rect</code>：用于滑动的滑动块图形</li>
<li><code>Direction</code>：滑动条增加的方向</li>
<li><code>Min Value</code>：最小值</li>
<li><code>Max Value</code>：最大值</li>
<li><code>Whole Numbers</code>：是否约束为整数值变化</li>
<li><code>Value</code>：当前滑动条代表的数值</li>
<li><code>On Value Changed(Single)</code>：滑动条改变时执行的函数列表。<code>Single</code>是<code>float</code>类型</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br><span class="line">print(s.<span class="keyword">value</span>);</span><br><span class="line"><span class="comment">//监听事件的两种方式</span></span><br><span class="line"><span class="comment">//1.拖脚本</span></span><br><span class="line"><span class="comment">//2.代码添加</span></span><br><span class="line">s.onValueChanged.AddListener((v) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;代码添加的监听&quot;</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="Scrollbar"><a href="#Scrollbar" class="headerlink" title="Scrollbar"></a>Scrollbar</h1><ul>
<li><p><code>Scrollbar</code>是滚动条组件，是<code>UGUI</code>中用于处理滚动条相关交互的关键组件</p>
</li>
<li><p>默认创建的<code>Scrollbar</code>由<code>2</code>组对象组成。父对象——<code>Scrollbar</code>组件依附的对象，子对象——滚动块对象</p>
</li>
<li><p>一般情况下我们不会单独使用滚动条，都是配合<code>ScrollView</code>滚动视图来使用</p>
</li>
</ul>
<ol>
<li><code>Handle Rect</code>：关联滑动块图形对象</li>
<li><code>Direction</code>：滑动条值增加的方向</li>
<li><code>Value</code>：滚动条初始位置值（<code>0~1</code>）</li>
<li><code>Size</code>：滚动条在条中的比例大小（<code>0~1</code>）</li>
<li><code>Number of Steps</code>：允许可以滚动多次（不同滚动位置的数量）</li>
<li><code>On Value Changed(Single)</code>：滚动条值改变时执行的函数列表</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Scrollbar sb = <span class="keyword">this</span>.GetComponent&lt;Scrollbar&gt;();</span><br><span class="line">print(sb.<span class="keyword">value</span>);</span><br><span class="line">print(sb.size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件的两种方式</span></span><br><span class="line"><span class="comment">//1.拖脚本</span></span><br><span class="line"><span class="comment">//2.代码添加</span></span><br><span class="line">sb.onValueChanged.AddListener((v) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听的函数&quot;</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h1><ul>
<li><p><code>ScrollRect</code>是滚动视图组件，是<code>UGUI</code>中用于处理滚动视图相关交互的关键组件</p>
</li>
<li><p>默认创建的<code>ScrollRect</code>由<code>4</code>组对象组成。父对象——<code>ScrollRect</code>组件依附的对象 还有一个<code>Image</code>组件 最为背景图，子对象<code>Viewport</code>控制滚动视图可视范围和内容显示，<code>Scrollbar Horizontal</code> 水平滚动条，<code>Scrollbar Vertical</code> 垂直滚动条</p>
</li>
</ul>
<ol>
<li><code>Content</code>：控制滚动视图显示内容的父对象，它的尺寸有多大，滚动视图就能拖多远</li>
<li><code>Horizontal</code>：启用水平滚动</li>
<li><code>Verical</code>：启用垂直滚动</li>
<li><code>Movement Type</code>：滚动视图元素的运动类型，主要控制拖动时的反馈效果。1）<code>Unrestricted</code>（一般不使用）：不受限制，随意拖动；2）<code>Elastic</code>（常用）：有回弹效果，当滚出边缘后，会弹回边缘，<code>Elasticity</code>：回弹系数，控制回弹效果，值越大回弹越慢；3）<code>Clamped</code>：夹紧效果，始终限制在范围内，没有回弹效果</li>
<li><code>Inertia</code>：移动惯性。如果开启，移动滚动条有一定的惯性。<code>Deceleration Rate</code>：减速率（<code>0~1</code>）。<code>0</code>没有惯性，<code>1</code>不会停止</li>
<li><code>Scroll Secsitivity</code>：滚轮（鼠标中键）和触摸板（笔记本）的滚动事件敏感性</li>
<li><code>ViewPort</code>：关联滚动视图内容视口对象</li>
<li><code>Horizontal Scrollbar</code>：关联水平滚动条</li>
<li><code>Visibility</code>：是否在不需要时自动隐藏等模式。1）<code>Permanent</code>：一直显示滚动条；2）<code>Auto Hide</code>：自动隐藏滚动条；3）<code>Auto Hide And Expand Viewport</code>：自动隐藏滚动条并且自动拓展内容视口</li>
<li><code>Spacing</code>：滚动条和视口之间的间隔空间</li>
<li><code>On Value Changed（Vector2）</code>：滚动视图位置改变时执行的函数列表</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ScrollRect sr = <span class="keyword">this</span>.GetComponent&lt;ScrollRect&gt;();</span><br><span class="line"><span class="comment">//改变内容的大小 具体可以拖动多少 都是根据它的尺寸来的</span></span><br><span class="line"><span class="comment">//sr.content.sizeDelta = new Vector2(200, 200);</span></span><br><span class="line">sr.normalizedPosition = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>

<h1 id="DropDown"><a href="#DropDown" class="headerlink" title="DropDown"></a>DropDown</h1><ul>
<li><p><code>DropDown</code>是下拉列表（下拉选单）组件，是<code>UGUI</code>中用于处理下拉列表相关交互的关键组件</p>
</li>
<li><p>默认创建的<code>DropDown</code>由<code>4</code>组对象组成。父对象：<code>DropDown</code>组件依附的对象 还有一个<code>Image</code>组件作为背景图。子对象：<code>Label</code>是当前选项描述，<code>Arrow</code>右侧小箭头，<code>Template</code>下拉列表选单</p>
</li>
</ul>
<ol>
<li><code>Template</code>：关联下拉列表对象</li>
<li><code>Caption Text</code>：关联显示当前选择内容的文本组件</li>
<li><code>Caption Image</code>：关联显示当前选择内容的图片组件</li>
<li><code>Item Text</code>：关联下拉列表选项用的文本控件</li>
<li><code>Item Image</code>：关联拉列表选项用的图片控件</li>
<li><code>Value</code>：当前所选选项的索引值</li>
<li><code>Alpha Fada Speed</code>：下拉列表窗口淡入淡出的速度</li>
<li><code>Options</code>：存在的选项列表</li>
<li><code>On Value Changed（Int32）</code>：当所选选项的索引值改变时执行的函数列表</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Dropdown dd = <span class="keyword">this</span>.GetComponent&lt;Dropdown&gt;();</span><br><span class="line">print(dd.<span class="keyword">value</span>);</span><br><span class="line">print(dd.options[dd.<span class="keyword">value</span>].text);</span><br><span class="line">dd.options.Add(<span class="keyword">new</span> Dropdown.OptionData(<span class="string">&quot;123123123&quot;</span>));</span><br></pre></td></tr></table></figure>


<h1 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h1><ul>
<li>目的</li>
</ul>
<ol>
<li>减少<code>DrawCall</code>，提高性能</li>
<li></li>
</ol>
<h2 id="Sprite-Packer（旧版）"><a href="#Sprite-Packer（旧版）" class="headerlink" title="Sprite Packer（旧版）"></a>Sprite Packer（旧版）</h2><ul>
<li>在工程设置面板中打开功能：<code>Edit——&gt;Project Setting——&gt;Editor——&gt;Sprite Packer</code>(精灵包装器，可以通过<code>Unity</code>自带图集工具生成图集)</li>
</ul>
<ol>
<li><code>Disabled</code>：默认设置，不会打包图集</li>
<li><code>Enabled For Builds</code>（<code>Legacy Sprite Packer</code>）：<code>Unity</code>仅在构建时打包图集，在编辑模式下不会打包图集</li>
<li><code>Always Enabled</code>（<code>Legacy Sprite Packer</code>）：<code>Unity</code>在构建时打包图集，在编辑模式下运行前会打包图集</li>
</ol>
<h2 id="Sprite-Atlas（新版）"><a href="#Sprite-Atlas（新版）" class="headerlink" title="Sprite Atlas（新版）"></a>Sprite Atlas（新版）</h2><ul>
<li>Edit-Project Setting-Editor&#x2F;SpritePacker打开设置（设置为Enabled For Builds或者Always Enabled，第二三项是SpritePacker使用的）</li>
<li>要创建精灵图集 ，请选择菜单： Asset &gt; Create &gt; Sprite Atlas 。Unity 在 Asset 文件夹中创建精灵图集，文件扩展名为 *.spriteatlas</li>
<li></li>
</ul>
<h1 id="UI事件监听接口"><a href="#UI事件监听接口" class="headerlink" title="UI事件监听接口"></a>UI事件监听接口</h1><ul>
<li><p>目前所有的控件都只提供了常用的事件监听列表，如果想做一些类似长按，双击，拖拽等功能是无法制作的，或者想让<code>Image</code>和<code>Text</code>，<code>RawImage</code>三大基础控件能够响应玩家输入也是无法制作的。而事件接口就是用来处理类似问题，让所有控件都能够添加更多的事件监听来处理对应的逻辑</p>
</li>
<li><p>常用事件接口</p>
</li>
</ul>
<ol>
<li><code>IPointerEnterHandler</code> - <code>OnPointerEnter</code> - 当指针进入对象时调用 （鼠标进入）</li>
<li><code>IPointerExitHandler</code> - <code>OnPointerExit</code> - 当指针退出对象时调用 （鼠标离开）</li>
<li><code>IPointerDownHandler</code> - <code>OnPointerDown</code> - 在对象上按下指针时调用 （按下）</li>
<li><code>IPointerUpHandler</code> - <code>OnPointerUp</code> - 松开指针时调用（在指针正在点击的游戏对象上调用）（抬起）</li>
<li><code>IPointerClickHandler</code> - <code>OnPointerClick</code> - 在同一对象上按下再松开指针时调用 （点击）</li>
<li><code>IBeginDragHandler</code> - <code>OnBeginDrag</code> - 即将开始拖动时在拖动对象上调用 （开始拖拽）</li>
<li><code>IDragHandler</code> - <code>OnDrag</code> - 发生拖动时在拖动对象上调用 （拖拽中）</li>
<li><code>IEndDragHandler</code> - <code>OnEndDrag</code> - 拖动完成时在拖动对象上调用 （结束拖拽）</li>
</ol>
<ul>
<li>使用事件接口</li>
</ul>
<ol>
<li>继承<code>MonoBehavior</code>的脚本继承对应的事件接口，引用命名空间</li>
<li>实现接口中的内容</li>
<li>将该脚本挂载到想要监听自定义事件的<code>UI</code>控件上</li>
</ol>
<ul>
<li><code>PointerEventData</code>的父类：<code>BaseEventData</code></li>
</ul>
<ol>
<li><code>pointerId</code>： 鼠标左右中键点击鼠标的<code>ID</code>，通过它可以判断右键点击。范围（<code>-1~-3</code>），<code>-1</code>为左键，<code>-2</code>为中键，<code>-3</code>为右键</li>
<li><code>position</code>：当前指针位置（屏幕坐标系）</li>
<li><code>pressPosition</code>：按下的时候指针的位置</li>
<li><code>delta</code>：指针移动增量</li>
<li><code>clickCount</code>：连击次数</li>
<li><code>clickTime</code>：点击时间</li>
<li><code>pressEventCamera</code>：最后一个<code>OnPointerPress</code>按下事件关联的摄像机</li>
<li><code>enterEvetnCamera</code>：最后一个<code>OnPointerEnter</code>进入事件关联的摄像机</li>
</ol>
<ul>
<li>好处：</li>
</ul>
<ol>
<li>需要监听自定义事件的控件挂载继承实现了接口的脚本就可以监听到一些特殊事件，可以通过它实现一些长按，双击拖拽等功能</li>
</ol>
<ul>
<li>坏处：</li>
</ul>
<ol>
<li>不方便管理，需要自己写脚本继承接口挂载到对应控件上，比较麻烦</li>
</ol>
<h1 id="事件触发器"><a href="#事件触发器" class="headerlink" title="事件触发器"></a>事件触发器</h1><ul>
<li>事件触发器是<code>EventTrigger</code>组件，它是一个集成了<code>UI</code>所有事件监听接口的脚本，它可以让我们更方便的为控件添加事件监听</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何使用事件触发器</span></span><br><span class="line"><span class="comment">//1.拖曳脚本进行关联</span></span><br><span class="line"><span class="comment">//2.代码添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个希望监听的事件对象</span></span><br><span class="line">EventTrigger.Entry entry = <span class="keyword">new</span> EventTrigger.Entry();</span><br><span class="line"><span class="comment">//申明 事件的类型</span></span><br><span class="line">entry.eventID = EventTriggerType.Drag;</span><br><span class="line"><span class="comment">//监听函数关联</span></span><br><span class="line">entry.callback.AddListener((data) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;拖拽&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//把申明好的 事件对象 加入到 EventTrigger当中</span></span><br><span class="line"><span class="keyword">this</span>.GetComponent&lt;EventTrigger&gt;().triggers.Add(entry);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>EventTrigger</code>可以让我们写更少的代码。可以在面板类中处理面板控件的事件逻辑，更加的面向对象，便于管理</li>
</ul>
<h1 id="RectTransformUtility"><a href="#RectTransformUtility" class="headerlink" title="RectTransformUtility"></a>RectTransformUtility</h1><ul>
<li><code>RectTransformUtility</code>公共类是一个<code>RectTransform</code>的辅助类。主要用于进行一些坐标的转换等等操作，其中对于我们目前来说最重要的函数是 <strong>将屏幕空间上的点，转换成<code>UI</code>本地坐标下的点</strong></li>
<li>将屏幕坐标转换为<code>UI</code>本地坐标系下的点，方法：<code>RectTransformUtility.ScreenPointToLocalPointInRectangle</code>。一般配合拖拽事件使用</li>
</ul>
<ol>
<li>参数一：相对父对象</li>
<li>参数二：屏幕点</li>
<li>参数三：摄像机</li>
<li>参数四：最终得到的点</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector2 nowPos;</span><br><span class="line">    RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">    parent,</span><br><span class="line">    eventData.position,</span><br><span class="line">    eventData.enterEventCamera,</span><br><span class="line">    <span class="keyword">out</span> nowPos );</span><br><span class="line">    <span class="keyword">this</span>.transform.localPosition = nowPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>补充：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9a6ffd86f1746c366a6bf42e42d6c530_720w.webp"></p>
<h1 id="Mask遮罩"><a href="#Mask遮罩" class="headerlink" title="Mask遮罩"></a>Mask遮罩</h1><ul>
<li><code>Mask</code>遮罩通过在<strong>父对象上添加<code>Mask</code>组件即可遮罩其子对象</strong></li>
</ul>
<ol>
<li><code>Show Mask Graphic</code>：是否显示遮罩图片</li>
</ol>
<ul>
<li>注意</li>
</ul>
<ol>
<li>想要被遮罩的<code>Image</code>需要勾选<code>Maskable</code></li>
<li>只要父对象添加了<code>Mask</code>组件，那么所有的<code>UI</code>子对象都会被遮罩</li>
<li>遮罩父对象图片的制作，不透明的地方显示，透明的地方被遮罩</li>
</ol>
<ul>
<li><p>原理：<strong>利用<code>GPU</code>的模板缓冲<code>StencilBuffer</code>实现</strong>。<code>GPU</code>在渲染前会为每个像素点分配一个<code>1</code>字节(<code>8</code>位)大小的内存区域，即<code>StencilBuffer</code>，用于记录一个无符号整数。在决定是否要渲染某个像素点之前，会将它当前的<code>StencilBuffer</code>的值与某个参考值(<code>stencilID</code>)进行指定的逻辑运算(<code>Stencil Comparison</code>)，如果运算结果为<code>True</code>，则渲染这个像素点，否则就不渲染</p>
</li>
<li><p>关键代码如下：它的作用是为<code>Mask</code>对象生成一个特殊的材质，这个材质会将<code>StencilBuffer</code>的值置为<code>1</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always);</span><br></pre></td></tr></table></figure></li>
<li><p><code>Mask</code>会额外生成 <code>2</code>个<code>DrawCall</code>。第一个 <code>Mask</code> 是一个在底层模板绘制一个区域的命令，根据 <code>Image</code> 传进来的图片 <code>Alpha</code> 值，确定裁剪区域，之后 <code>Mask</code>节点下的元素会根据这个区域计算 <code>Alpha</code> 的值，最后一个 <code>Mask</code> 是绘制区域结束的指令，用于结束计算裁剪的操作</p>
</li>
</ul>
<h1 id="Rect-Mask-2D"><a href="#Rect-Mask-2D" class="headerlink" title="Rect Mask 2D"></a>Rect Mask 2D</h1><ul>
<li><code>Rect Mask 2D</code>：一个常见用途是显示较大区域的小部分。使用 <code>Rect Mask 2D </code>可框定此区域</li>
<li>优点</li>
</ul>
<ol>
<li>不使用模板缓冲区</li>
<li>无需额外的绘制调用</li>
<li>无需更改材质</li>
<li>高速性能</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>仅在 <code>2D</code> 空间中有效</li>
<li>不能正确掩盖不共面的元素</li>
</ol>
<ul>
<li><code>Rect Mask 2D</code>与<code>Mask</code>的异同</li>
<li>相同点</li>
</ul>
<ol>
<li>裁剪</li>
<li>都只生效于子元素</li>
</ol>
<ul>
<li>不同点</li>
</ul>
<ol>
<li><code>Mask</code>组件需要依赖一个<code>Image</code>组件（<code>Raw Image</code>组件，不行！），裁剪区域就是<code>Image</code>的大小；而<code>Rect Mask 2D</code>不用依赖任何组件，裁剪区域就是它的<code>RectTransform</code>的<code>rect</code>大小</li>
<li><code>Mask</code> 内的元素都不会跟外界非 <code>Mask</code> 内的元素合批；<code>RectMask2D</code>内的元素合批规则跟正常的是一样的</li>
<li><code>Mask</code> 内的元素可以和其他<code>Mask</code> 内的元素合批；<code>RectMask2D</code>内的元素不会跟外界任何元素进行合批（即使是其他 <code>RectMask2D</code>内的元素）</li>
<li><code>Mask</code>会额外生成 <code>2</code>个<code>DrawCall</code>；<code>RectMask2D</code> 不会产生额外的 <code>DrawCall</code></li>
</ol>
<h1 id="Sprite-Renderer"><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a>Sprite Renderer</h1><ul>
<li>Sprite Renderer 组件用于渲染精灵并控制其在 2D 和 3D 项目场景中的可视化效果</li>
<li>Sprite：渲染的精灵纹理</li>
</ul>
<h1 id="Sprite-Mask"><a href="#Sprite-Mask" class="headerlink" title="Sprite Mask"></a>Sprite Mask</h1><ul>
<li>精灵遮罩用于隐藏或显示精灵或精灵组的各个部分。</li>
<li>精灵遮罩仅影响使用精灵渲染器 (Sprite Renderer) 组件的对象</li>
<li>Sprite：遮罩精灵 </li>
<li>注意与Sprite Renderer的位置摆放</li>
</ul>
<h1 id="模型和粒子显示在UI之前"><a href="#模型和粒子显示在UI之前" class="headerlink" title="模型和粒子显示在UI之前"></a>模型和粒子显示在UI之前</h1><ul>
<li>模型显示在<code>UI</code>之前</li>
</ul>
<ol>
<li><strong>直接用摄像机渲染<code>3D</code>物体</strong>。<code>Canvas</code>的渲染模式只要不是覆盖模式，摄像机模式 和 世界(<code>3D</code>)模式都可以让模型显示在<code>UI</code>之前（<code>Z</code>轴在<code>UI</code>元素之前即可）</li>
</ol>
<p>注意：1）摄像机模式时建议用专门的摄像机渲染<code>UI</code>相关；2）面板上的<code>3D</code>物体建议也用UI摄像机进行渲染</p>
<ol start="2">
<li>方法二：<strong>将<code>3D</code>物体渲染在图片上，通过图片显示</strong>。专门使用一个摄像机渲染<code>3D</code>模型，将其渲染内容输出<code>Render Texture</code>上，类似小地图的制作方式，再将渲染的图显示在<code>UI</code>上</li>
</ol>
<p>注意：该方式不管<code>Canvas</code>的渲染模式是哪种都可以使用</p>
<ul>
<li>粒子特效显示在<code>UI</code>之前。粒子特效的显示和<code>3D</code>物体类似</li>
<li>注意点：在摄像机模式下时，可以在粒子组件的<code>Renderer</code>相关参数中改变排序层，让粒子特效始终显示在其之前不受<code>Z</code>轴影响</li>
</ul>
<h1 id="异形按钮"><a href="#异形按钮" class="headerlink" title="异形按钮"></a>异形按钮</h1><ul>
<li><p>异形按钮：图片形状不是传统矩形的按钮</p>
</li>
<li><p>如何让异形按钮能够准确点击</p>
</li>
</ul>
<ol>
<li>通过添加子对象的形式</li>
</ol>
<p>按钮之所以能够响应点击，<strong>主要是根据图片矩形范围进行判断的</strong>。它的范围判断是自下而上的，意思是如果有子对象图片，子对象图片的范围也会算为可点击范围，那么我们就可以<strong>用多个透明图拼凑不规则图形作为按钮子对象用于进行射线检测</strong></p>
<ol start="2">
<li>通过代码改变图片的透明度响应阈值</li>
</ol>
<p>1）第一步：修改图片参数，开启<code>Read/Write Enabled</code>开关</p>
<p>2）第二步：通过代码修改图片的响应阈值该参数含义：指定一个像素必须具有的最小<code>alpha</code>值，以变能够认为射线命中了图片。即当像素点<code>alpha</code>值小于了 该值 就不会被射线检测了</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">img.alphaHitTestMinimumThreshold = <span class="number">0.1f</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：通过增加内存消耗，来提高准确性</li>
<li>补充：Image.alphaHitTestMinimumThreshold。默认为0。此 Alpha 阈值指定要将事件视为图像“碰撞”时像素必须具有的最小 Alpha 值</li>
</ul>
<ol start="3">
<li>Polygon Collider2D</li>
</ol>
<ul>
<li>原理：利用Polygon Collider2D的编辑功能确定不规则点击区域，接着调用OverlapPoint()方法判断是否点击在不规则区域中<br>实现方法1：自身就是Image，即显示图片，又进行点击区域的判断</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">RequireComponent(typeof(PolygonCollider2D))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImage</span> : <span class="title">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D _polygen = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PolygonCollider2D polygen</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_polygen == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _polygen = GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _polygen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给定一个点和一个摄像机，判断射线投射是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point;</span><br><span class="line">        RectTransformUtility.ScreenPointToWorldPointInRectangle(rectTransform,sp,eventCamera,<span class="keyword">out</span> point);</span><br><span class="line">        <span class="keyword">return</span> polygen.OverlapPoint(point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方法2：自身不显示图片，只进行点击区域的判断</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">RequireComponent(typeof(PolygonCollider2D))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPolygon</span> : <span class="title">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D _polygon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D polygon</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_polygon == <span class="literal">null</span>)</span><br><span class="line">                _polygon = GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">            <span class="keyword">return</span> _polygon;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置只响应点击，不进行渲染</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UIPolygon</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        useLegacyMeshGeneration = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper vh</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vh.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 screenPoint, Camera eventCamera</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> polygon.OverlapPoint(eventCamera.ScreenToWorldPoint(screenPoint));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重置不规则区域</span></span><br><span class="line">        <span class="keyword">base</span>.Reset();</span><br><span class="line">        transform.position = Vector3.zero;</span><br><span class="line">        <span class="built_in">float</span> w = (rectTransform.sizeDelta.x * <span class="number">0.5f</span>) + <span class="number">0.1f</span>;</span><br><span class="line">        <span class="built_in">float</span> h = (rectTransform.sizeDelta.y * <span class="number">0.5f</span>) + <span class="number">0.1f</span>;</span><br><span class="line">        polygon.points = <span class="keyword">new</span> Vector2[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Vector2(-w,-h),</span><br><span class="line">            <span class="keyword">new</span> Vector2(w,-h),</span><br><span class="line">            <span class="keyword">new</span> Vector2(w,h),</span><br><span class="line">            <span class="keyword">new</span> Vector2(-w,h)</span><br><span class="line">          &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(UIPolygon), true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPolygonInspector</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//什么都不写用于隐藏面板的显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>补充：</li>
</ul>
<ol>
<li>Camera.ScreenToWorldPoint：将点从屏幕空间变换为世界空间。返回值类型为Vector3</li>
<li>RectTransformUtility.ScreenPointToWorldPointInRectangle：将一个屏幕空间点转换为世界空间中位于给定 RectTransform 平面上的一个位置。返回值类型为bool</li>
</ol>
<h1 id="Layout-Element"><a href="#Layout-Element" class="headerlink" title="Layout Element"></a>Layout Element</h1><ul>
<li>Layout Element用于修改布局元素的最小大小、偏好大小或灵活大小</li>
</ul>
<h1 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h1><ul>
<li>自动布局可以帮助我们自动<strong>设置<code>UI</code>控件的位置和大小等</strong></li>
<li>要参与自动布局的布局元素必须包含布局属性，布局元素组件为<code>Layout Element</code>，布局属性主要有以下几条</li>
</ul>
<ol>
<li><p><code>Ignore Layout</code>：忽略布局</p>
</li>
<li><p><code>Minmum width</code>：该布局元素应具有的最小宽度</p>
</li>
<li><p><code>Minmum height</code>：该布局元素应具有的最小高度</p>
</li>
<li><p><code>Preferred width</code>：在分配额外可用宽度之前，此布局元素应具有的宽度</p>
</li>
<li><p><code>Preferred height</code>：在分配额外可用高度之前，此布局元素应具有的高度。</p>
</li>
<li><p><code>Flexible width</code>：此布局元素应相对于其同级而填充的额外可用宽度的相对量</p>
</li>
<li><p><code>Flexible height</code>：此布局元素应相对于其同级而填充的额外可用宽度的相对量</p>
</li>
<li><p>在进行自动布局时 都会通过计算布局元素中的这<code>6</code>个属性得到控件的大小位置</p>
</li>
<li><p><code>Layout Priority</code>：此组件的布局优先级。如果一个游戏对象有一个以上包含布局属性的组件（例如，一个 <code>Image</code> 组件和一个 <code>LayoutElement</code> 组件），则布局系统将使用 <code>Layout Priority</code> 值最高的组件中的属性值。如果这些组件具有相同的 <code>Layout Priority</code> 值，则布局系统将使用每个属性的最大值，而不管该属性来自哪个组件</p>
</li>
</ol>
<ul>
<li>在布局时，布局元素大小设置的基本规则是</li>
</ul>
<ol>
<li>首先分配最小大小<code>Minmum width</code>和<code>Minmum height</code></li>
<li>如果父类容器中有足够的可用空间，则分配<code>Preferred width</code>和<code>Preferred height</code></li>
<li>如果上面两条分配完成后还有额外空间，则分配<code>Flexible width</code>和<code>Flexible height</code></li>
</ol>
<ul>
<li>一般情况下布局元素的这些属性都是<code>0</code>，但是特定的UI组件依附的对象布局属性会被改变，比如<code>Image</code>和<code>Text</code>。一般情况下我们不会去手动修改他们，但是如果有这些需求，可以手动添加一个<code>Layout Element</code>组件 可以修改这些布局属性</li>
</ul>
<hr>
<ul>
<li>水平垂直布局组件：<strong>将子对象并排或者竖直的放在一起</strong>。组件名：<code>Horizontal Layout Group</code> 和 <code>Vertical Layout Group</code></li>
<li>参数相关：</li>
</ul>
<ol>
<li><code>Padding</code>：左右上下边缘偏移位置</li>
<li><code>Spacing</code>：子对象之间的间距</li>
<li><code>ChildAlignment</code>：九宫格对齐方式</li>
<li><code>Reverse Arrangement</code>：反向排列</li>
<li><code>Control Child Size</code>：是否控制子对象的宽高</li>
<li><code>Use Child Scale</code>：在设置子对象大小和布局时，是否考虑子对象的缩放</li>
<li><code>Child Force Expand</code>：是否强制子对象拓展以填充额外可用空间</li>
</ol>
<hr>
<ul>
<li>网格布局组件：<strong>将子对象当成一个个的格子设置它们的大小和位置</strong>。组件名：<code>Grid Layout Group</code></li>
<li>参数相关：</li>
</ul>
<ol>
<li><code>Padding</code>：左右上下边缘偏移位置</li>
<li><code>Cell Size</code>：每个格子的大小</li>
<li><code>Spacing</code>：格子间隔</li>
<li><code>Start Corner</code>:第一个元素所在位置（<code>4</code>个角）</li>
<li><code>Start Axis</code>：沿哪个轴放置元素；<code>Horizontal</code>水平放置满换行，<code>Vertical</code>竖直放置满换列</li>
<li><code>Child Alignment</code>：格子对其方式（<code>9</code>宫格）</li>
<li><code>Constraint</code>：行列约束。1）<code>Flexible</code>：灵活模式，根据容器大小自动适应；2）<code>Fixed Column Count</code>：固定列数；3）<code>Fixed Row Count</code>：固定行数。<code>Constraint Count</code>：约束个数</li>
</ol>
<hr>
<ul>
<li>内容大小适配器：<strong>它可以自动地调整<code>RectTransform</code>的长宽来让组件自动设置大小</strong>。一般在<code>Text</code>上使用 或者 配合其它布局组件一起使用。组件名：<code>Content Size Fitter</code></li>
<li>官方描述：内容大小适配器充当布局控制器，可用于控制其自身布局元素的大小。大小由游戏对象上布局元素组件提供的最小大小或偏好大小确定。此类布局元素可以是图像或文本组件、布局组或布局元素组件</li>
<li>可以使用轴心来控制大小调整的方向</li>
<li>参数相关：</li>
</ul>
<ol>
<li><code>Horizontal Fit</code>：如何控制宽度</li>
<li><code>Vertical Fit</code>：如何控制高度</li>
<li><code>Unconstrained</code>：不根据布局元素伸展</li>
<li><code>Min Size</code>：根据布局元素的最小宽高度来伸展</li>
<li><code>Preferred Size</code>：根据布局元素的偏好宽度来伸展宽度</li>
</ol>
<hr>
<ul>
<li>宽高比适配器：1）让布局元素按照一定比例来调整自己的大小；2）使布局元素在父对象内部根据父对象大小进行适配。组件名：<code>Aspect Ratio Fitter</code></li>
<li>参数相关：</li>
</ul>
<ol>
<li><code>Aspect Mode</code>：适配模式，如果调整矩形大小来实施宽高。1）<code>None</code>：不让矩形适应宽高比；2）<code>Width Controls Height</code>：根据宽度自动调整高度；3）<code>Height Controls Width</code>：根据高度自动调整宽度；4）<code>Fit In Parent</code>：自动调整宽度、高度、位置和锚点，使矩形适应父项的矩形，同时保持宽高比，会出现“黑边”；5）<code>Envelope Parent</code>：自动调整宽度、高度、位置和锚点，使矩形覆盖父项的整个区域，同时保持宽高比，会出现“裁剪”</li>
<li><code>Aspect Ratio</code>：宽高比；宽除以高的比值</li>
</ol>
<h1 id="Canvas-Group组件"><a href="#Canvas-Group组件" class="headerlink" title="Canvas Group组件"></a>Canvas Group组件</h1><ul>
<li><code>Canvas Group</code>（画布组）：可以整体控制一个面板</li>
<li>参数相关：</li>
</ul>
<ol>
<li><code>Alpha</code>：此组中的 UI 元素的不透明度。</li>
<li><code>Interactable</code>：确定此组件是否接受输入。当设置为 false 时，禁用交互。</li>
<li><code>Blocks Raycasts</code>：此组件是否作为射线投射的碰撞体。如果不开启，则所有的子对象不能接受射线检测</li>
<li><code>Ignore Parent Groups</code>：是否忽略更上层的画布组<code>Canvas Group</code>的影响</li>
</ol>
<ul>
<li>画布组的典型用途为：</li>
</ul>
<ol>
<li>通过在窗口的游戏对象上添加画布组并控制其 Alpha 属性来淡入或淡出整个窗口。</li>
<li>通过将画布组添加到父游戏对象并将其 Interactable 属性设置为 false 来使整组控件不可交互（“灰显”）。</li>
<li>通过在 UI 元素或其某个父元素上放置画布组 (Canvas Group) 组件并将其 Block Raycasts 属性设置为 false 来使一个或多个 UI 元素不阻止鼠标事件</li>
</ol>
<h1 id="Canvas-Renderer"><a href="#Canvas-Renderer" class="headerlink" title="Canvas Renderer"></a>Canvas Renderer</h1><ul>
<li><code>Canvas Renderer</code>：负责发送渲染数据</li>
</ul>
<ol>
<li><code>Cull Transparent Mesh</code>：是否剔除透明网格</li>
</ol>
<h1 id="Rebuild、ReBatch"><a href="#Rebuild、ReBatch" class="headerlink" title="Rebuild、ReBatch"></a>Rebuild、ReBatch</h1><ul>
<li><p><code>Unity</code>将UI的渲染分为两个步骤，<strong>对<code>mesh</code>的操作称为<code>Rebatch</code><strong>，</strong>对<code>material</code>和<code>layout</code>的操作称为<code>Rebuild</code></strong></p>
</li>
<li><p><code>Rebuild</code>：<strong>重新计算 <code>Graphic</code> 组件的布局和网格的过程</strong></p>
</li>
<li><p><code>Batch Build</code>（<code>Rebatch</code>）：**<code>Canvas</code>把表示它<code>UI</code>元素的网格合并起来，并生成合适的渲染命令发送到<code>Unity</code>的图形管线中**。这个过程的结果会被缓存起来复用，直到这个<code>Canvas</code>被标记为<code>Dirty</code>，当<code>Canvas</code>中任何一个网格发生变化时，就会被标记成<code>Dirty</code>状态</p>
</li>
<li><p><code>Canvas</code>的网格是从从那些<code>Canvas</code>下的<code>CanvasRenderer</code>组件中获取的，但不包括子<code>Canvas</code></p>
</li>
<li><p>触发<code>Rebatch</code>的条件：当<code>Canvas</code>下有<code>Mesh</code>发生改变时，如：</p>
</li>
</ul>
<ol>
<li><p><code>SetActive</code></p>
</li>
<li><p><code>Transform</code>属性变化</p>
</li>
<li><p><code>Graphic</code>的<code>Color</code>属性变化（改<code>Mesh</code>顶点色）</p>
</li>
<li><p><code>Text</code>文本内容变化</p>
</li>
<li><p><code>Depth</code>发生变化</p>
</li>
</ol>
<ul>
<li>触发<code>Rebuild</code>的条件：</li>
</ul>
<ol>
<li><p><code>Layout</code>修改<code>RectTransform</code>部分影响布局的属性</p>
</li>
<li><p><code>Graphic</code>的<code>Mesh</code>或<code>Material</code>发生变化</p>
</li>
<li><p><code>Mask</code>裁剪内容变化</p>
</li>
</ol>
<h1 id="UGUI合批"><a href="#UGUI合批" class="headerlink" title="UGUI合批"></a>UGUI合批</h1><ul>
<li><p>合批原理： <code>UGUI</code>的合批规则是进行重叠检测，然后分层合并。只有在同一个<code>Canvas</code>的<code>UI</code>才可以合批</p>
</li>
<li><p>第一步<strong>计算每个<code>UI</code>元素的层级号</strong>。如果有一个<code>UI</code>元素，它所占的矩形范围内，如果没有任何<code>UI</code>在它的底下，那么它的层级号就是<code>0</code>（最底下）；如果有一个<code>UI</code>在其底下且该<code>UI</code>可以和它<code>Batch</code>，那它的层级号与底下的<code>UI</code>层级一样；如果有一个<code>UI</code>在其底下但是无法与它<code>Batch</code>，那它的层级号为底下的<code>UI</code>的层级<code>+1</code>；如果有多个<code>UI</code>都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号</p>
</li>
<li><p>第二步<strong>合并相同层级中可以<code>Batch</code>的元素作为一个批次，并对批次进行排序</strong> 。有了层级号之后，<code>Unity</code>会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以<code>Batch</code>的元素成为一个批次。经过以上排序，就可以得到一个有序的批次序列了。这时<code>Unity</code>会再做一个优化，即如果相邻间的两个批次正好可以<code>Batch</code>的话就会进行<code>Batch</code>。合批的<code>Batch</code>数据，最后会分别放在<code>CanvasMesh</code>的<code>SubMesh</code>里</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://docs.unity.cn/cn/2022.1/Manual/UICanvas.html">Unity 手册 - UGUI</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93813556">【Unity UGUI】屏幕坐标转换</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141731132">Unity 关于GUI与UGUI坐标 的一点问题解惑</a></li>
<li><a href="https://www.jianshu.com/p/4592bf809c8b">Unity——RectTransform详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/387071537">[Unity UGUI]实现精确点击响应的几种策略</a></li>
<li>《Unity 3D游戏开发（第二版）》</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/06/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>单例模式是一种设计模式。它保证一个类只有一个实例，并且提供了访问该实例的全局访问点</li>
<li>单例模式属于创建型模式</li>
<li>优点：1）保证内存里只有一个实例，减少了内存的开销。对于一些需要频繁创建和销毁的对象使用单例模式可以提高系统的性能；2）可以避免对资源的多重占用</li>
<li>缺点：单例模式所属的类不能被继承（构造函数是私有的），扩展性差，没有接口，与单一职责原则冲突</li>
<li>关键代码：构造函数私有化</li>
<li>单例模式有多种实现方式，具体可参考<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式-菜鸟教程</a>。本文实现两种，分别为懒汉式和饿汉式</li>
</ul>
<ol>
<li>懒汉式：所谓懒汉式，就是在需要调用的时候再创建类的实例化。如果不加锁<code>synchronized</code>，该方式线程不安全，因为当多个线程并发同时判断单例为空时，就会相应的实例化多个对象这种实现，最大的问题就是不支持多线程，必须加锁才能保证线程安全。懒汉式线程安全时的优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率</li>
<li>饿汉式：饿汉式是多线程安全。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存</li>
</ol>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ul>
<h1 id="不继承MonoBehaviour的类"><a href="#不继承MonoBehaviour的类" class="headerlink" title="不继承MonoBehaviour的类"></a>不继承MonoBehaviour的类</h1><ul>
<li>不继承<code>MonoBehaviour</code>的类必须使用<code>new</code>实例化<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程不安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式（线程安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;&#125;  </span><br><span class="line">    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseSingleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="title">new</span>()   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">BaseSingleton</span>&lt;<span class="title">GameManager</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="继承MonoBehaviour的类"><a href="#继承MonoBehaviour的类" class="headerlink" title="继承MonoBehaviour的类"></a>继承MonoBehaviour的类</h1><ul>
<li>继承<code>MonoBehaviour</code>的类不能使用<code>new</code>实例化，挂载到<code>GameObject</code>上时，<code>Unity</code>会自动实例化<h2 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//Unity 在切换游戏场景的时候，默认会消除上一个游戏场景里所有的 GameObject对象，所以Singleton对象也会被销毁。使用DontDestroyOnLoad()方法让Singleton在切换游戏场景的时候不会被销毁</span></span><br><span class="line">            DontDestroyOnLoad(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span>/Singleton 是在第一个场景里创建的，当我们从第二个游戏场景切换回第一个游戏场景的时候，Unity 并不是恢复第一个游戏场景，而是会重新创建出一个新游戏场景，这就会导致一个新的 Singleton 对象被创建，这就不能保证 Singleton 对象的唯一性。此时需要在 Singleton 类的 Awake() 方法里增加一些逻辑判断，当检查到已经有一个 Singleton 对象存在的时候，就把当前的 Singleton 对象销毁</span></span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = (T) <span class="keyword">this</span>;</span><br><span class="line">            DontDestroyOnLoad(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">Singleton</span>&lt;<span class="title">GameManager</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="双重检验锁式单例模式"><a href="#双重检验锁式单例模式" class="headerlink" title="双重检验锁式单例模式"></a>双重检验锁式单例模式</h1><p>双重检验锁式单例模式是在懒汉式基础上增加了同步锁，避免了线程不安全问题，同时也减少了不必要的同步开销</p>
<ul>
<li>避免了线程不安全问题：加锁</li>
<li>减少了不必要的同步开销：只有第一次检查是在没有锁的情况下进行的，如果实例已经创建了，那么后续线程就不需要再次获取锁，从而减少了同步开销</li>
<li><code>synchronized (Singleton.class)</code> ：用于对一个代码块或方法进行加锁，保证在同一时间只有一个线程可以执行该代码块或方法<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            synchronized (Singleton.<span class="keyword">class</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>为了保证实例是单一的，除了可以使用单例模式，还可以使用静态类或静态标识位，在运行时检测是不是只有一个实例被创建了</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://gpp.tkchu.me/singleton.html">游戏编程模式 - 单例模式</a></li>
<li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式-菜鸟教程</a></li>
<li><a href="https://www.jianshu.com/p/97e4758ff4b4">Unity 单例模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2023/04/03/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>原型模式：<strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</strong></li>
<li>原型模式属于创建型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象原型类(Prototype)：<strong>它是声明克隆方法的接口，是所有具体原型类的公共父类</strong>，可以是抽象类也可以是接口，甚至还可以是具体实现类</li>
<li>具体原型类(ConcretePrototype)：<strong>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</strong></li>
<li>客户类(Client)：<strong>让一个原型对象克隆自身从而创建一个新的对象</strong>，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/prototype.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li>
<li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li>
<li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li>
<li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li>
<li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象原型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPrototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPrototype <span class="title">Colne</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cube</span> : <span class="title">IPrototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPrototype <span class="title">Colne</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;克隆Cube&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MemberwiseClone() <span class="keyword">as</span> IPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sphere</span> : <span class="title">IPrototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPrototype <span class="title">Colne</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;克隆Sphere&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MemberwiseClone() <span class="keyword">as</span> IPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IPrototype cubePrototype = <span class="keyword">new</span> Cube();</span><br><span class="line">    <span class="keyword">public</span> IPrototype spherePrototype = <span class="keyword">new</span> Sphere();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">//克隆Cube</span></span><br><span class="line">        Cube cube = client.cubePrototype.Colne() <span class="keyword">as</span> Cube;</span><br><span class="line">        <span class="comment">//克隆Sphere</span></span><br><span class="line">        Sphere sphere = client.spherePrototype.Colne() <span class="keyword">as</span> Sphere;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/prototype.html">游戏设计模式 - 原型模式</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Prototype%20Pattern">原型模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511748">C#设计模式笔记之原型模式 (Prototype Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/prototype-pattern.html">原型模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2023/04/03/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>享元模式：<strong>使用共享对象可有效地支持大量的细粒度的对象</strong></li>
<li>享元模式属于结构型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象享元类（Flyweight）：<strong>通常是一个接口或抽象类，声明具体享元类公共的方法</strong>，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法设置外部数据（外部状态）</li>
<li>具体享元类（ConcreteFlyweight）：实现了抽象享元类，通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象</li>
<li>非共享具体享元类（UnsharedConcreteFlyweight）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可以设计为非共享具体享元类</li>
<li>享元工厂类（FlyweightFactory）：享元工厂用于创建并管理享元对象，将各种类型的具体享元对象存储在一个享元池中</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/flyweight.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>能够极大的减少系统中对象的个数，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li>
<li>享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。</li>
<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>如果一个系统中存在大量的相同或者相似的对象，由于这类对象的大量使用，会造成系统内存的耗费，可以使用享元模式来减少系统中对象的数量。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>游戏开发中的对象池技术</li>
</ol>
<ul>
<li>注意</li>
</ul>
<ol>
<li>为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。 正如其名，这意味着对象池是存储它们的好地方</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mesh mesh;</span><br><span class="line">    <span class="keyword">protected</span> Vector3 position;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">DisPlay</span>(<span class="params">Vector3 _position</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedCube</span>:<span class="title">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DisPlay</span>(<span class="params">Vector3 _position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        position = _position;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;画一个红色的立方体，位置为<span class="subst">&#123;position&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreenCube</span>:<span class="title">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DisPlay</span>(<span class="params">Vector3 _position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        position = _position;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;画一个红色的立方体，位置为<span class="subst">&#123;position&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, Cube&gt; _dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Cube&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cube <span class="title">GetCube</span>(<span class="params"><span class="built_in">string</span> color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cube target = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(_dic.TryGetValue(color,<span class="keyword">out</span> target))</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">switch</span>(color)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Red&quot;</span>:target = <span class="keyword">new</span> RedCube();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Green&quot;</span>:target = <span class="keyword">new</span> GreenCube();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _dic.Add(color, target);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CubeFactory cubeFactory = <span class="keyword">new</span> CubeFactory();</span><br><span class="line">        <span class="comment">//画一个红色的立方体，位置为(0.00, 1.00, 0.00)</span></span><br><span class="line">        cubeFactory.GetCube(<span class="string">&quot;Red&quot;</span>).DisPlay(Vector3.up);</span><br><span class="line">        <span class="comment">//画一个红色的立方体，位置为(0.00, -1.00, 0.00)</span></span><br><span class="line">        cubeFactory.GetCube(<span class="string">&quot;Green&quot;</span>).DisPlay(Vector3.down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/flyweight.html">游戏设计模式-享元模式</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Flyweight%20Pattern">享元模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346510680">C#设计模式笔记之享元模式（Flyweight Pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/flyweight-pattern.html">享元模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2023/03/30/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>中介者模式：<strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</strong></li>
<li>中介者模式属于行为型模式</li>
<li>优点：</li>
</ul>
<ol>
<li>符合迪米特原则</li>
<li>使得各个类松耦合</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>维护具体中介者困难</li>
</ol>
<ul>
<li>使用场景：</li>
</ul>
<ol>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类</li>
</ol>
<ul>
<li>中介者模式主要角色如下：</li>
</ul>
<ol>
<li>抽象中介者：它定义一个接口，该接口用于与各同事对象之间进行通信</li>
<li>具体中介者：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用</li>
<li>抽象同事类：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现</li>
<li>具体同事类：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/mediator.gif?raw=true"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li>具体中介者拥有通信的双方<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> Message, Person recivePeople</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChatMediator</span> : <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Person boy;</span><br><span class="line">    <span class="keyword">public</span> Person girl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> Message, Person recivePeople</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        recivePeople.GetMessage(Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPerson</span>(<span class="params">Person p1,Person p2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        boy = p1;</span><br><span class="line">        girl = p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span>(<span class="params"><span class="built_in">string</span> Message</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Boy</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetMessage</span>(<span class="params"><span class="built_in">string</span> Message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Boy接受信息：<span class="subst">&#123;Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Girl</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetMessage</span>(<span class="params"><span class="built_in">string</span> Message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Girl接受信息：<span class="subst">&#123;Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实例化具体中介者</span></span><br><span class="line">        ChatMediator chatMediator = <span class="keyword">new</span> ChatMediator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化具体同事类</span></span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">        chatMediator.SetPerson(boy, girl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Girl接受信息：Hello Girl</span></span><br><span class="line">        chatMediator.SendMessage(<span class="string">&quot;Hello Girl&quot;</span>, chatMediator.girl);</span><br><span class="line">        <span class="comment">//Boy接受信息：Hello Boy</span></span><br><span class="line">        chatMediator.SendMessage(<span class="string">&quot;Hello Boy&quot;</span>, chatMediator.boy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Mediator%20Pattern">中介者模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511259">C#设计模式笔记之中介者模式（Mediator pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/mediator-pattern.html">中介者模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>坐标系、向量、坐标空间</title>
    <url>/2022/07/29/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><ul>
<li>笛卡尔坐标系就是直角坐标系（又分为左手坐标系和右手坐标系）和斜角坐标系的统称</li>
<li><code>x</code>轴可以表示为红色，<code>y</code>轴可以表示为绿色，<code>z</code>轴可以表示为蓝色</li>
<li>左手坐标系</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%B7%A6%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%B7%A6%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB1.png?raw=true"></p>
<ul>
<li>右手坐标系</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB1.png?raw=true"></p>
<ul>
<li>注意</li>
</ul>
<ol>
<li><code>Unity</code>和<code>Unreal</code>的世界坐标均用左手坐标系</li>
<li><code>Maya</code> 、 <code>OpenGL</code> 使用右手坐标系</li>
<li><code>DirectX</code>、 <code>pbrt</code>、 <code>PRMan</code> 使用左手坐标系</li>
</ol>
<h1 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h1><ul>
<li>齐次坐标将一个原本是<code>n</code>维的向量用一个<code>n+1</code>维向量来表示</li>
<li>引入齐次坐标的目的</li>
</ul>
<ol>
<li>提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。例如通过增加一个数，将平移变换写成矩阵乘向量的形式</li>
<li>可以表示无穷远的点</li>
<li>允许在<code>3D</code>向量上进行位移</li>
</ol>
<ul>
<li>齐次坐标与笛卡尔坐标的转换：例如，<code>2D</code>齐次坐标在笛卡尔坐标<code>（X，Y）</code>的基础上增加一个新分量<code>w</code>，变为<code>(x,y,w)</code>，其中笛卡尔坐标系中的<code>X</code>、<code>Y</code>与齐次坐标中的<code>x</code>、<code>y</code>有如下对应关系：<code>X=x/w</code>，<code>Y=y/w</code></li>
<li>齐次坐标描述的是缩放的不变性。例如，点<code>（1，2，3）</code>、<code>（2，4，6）</code>和（<code>4，8，12）</code>对应笛卡尔坐标的同一点<code>（1/3，2/3）</code>，因为这些都是齐次的</li>
</ul>
<h1 id="向量归一化"><a href="#向量归一化" class="headerlink" title="向量归一化"></a>向量归一化</h1><ul>
<li>向量归一化将向量<code>a</code>等比例缩放为单位矢量即大小变为<code>1</code>，但是向量的方向不变。在计算时我们无需考虑具体的模长所带来的影响，只考虑向量的方向</li>
<li>公式：<code>a(归一化) = a / |a|</code></li>
</ul>
<h1 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a>向量的点乘</h1><ul>
<li>定义：在空间中有两个向量，<code>a = (x1,y1,z1)</code>，<code>b = (x2,y2,z2)</code>，则点乘为<code>a·b = |a|·|b|cos&lt;a,b&gt;</code>，或者<code>a·b = x1x2 + y1y2 + z1z2</code></li>
<li>点乘又称点积、数量积、内积,（<code>Dot Product</code>）</li>
<li>意义：是一条边向另一条边的投影乘以另一条边的长度<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E7%82%B9%E4%B9%98%E7%9A%84%E6%84%8F%E4%B9%89.jpg?raw=true"></li>
<li>点积是一个浮点值，它等于将两个向量的大小相乘，然后乘以向量之间角度的余弦值</li>
<li>当两个单位向量的长度都是<code>1</code>（向量归一化）的时候，向量的点乘就是他们夹角的余弦值</li>
<li>根据点乘的结果，可以分为以下三种情况</li>
</ul>
<ol>
<li>当两个向量的夹角为<code>(0-90)°</code>的时候，余弦值是正数。点乘结果是正的</li>
<li>当两个向量的夹角为<code>90°</code>的时候，余弦值为<code>0</code>。点乘结果为<code>0</code></li>
<li>当两个向量的夹角为<code>(90-180)°</code>的时候，余弦值是负数。点乘结果是负的</li>
</ol>
<ul>
<li>应用</li>
</ul>
<ol>
<li>点乘可以判断出目标物体在我的前方还是后方。大于零在前方，小于零在后方，等于零则在正左方或者正右方</li>
</ol>
<h1 id="向量的叉乘"><a href="#向量的叉乘" class="headerlink" title="向量的叉乘"></a>向量的叉乘</h1><ul>
<li><p>定义：在空间中有两个向量，<code>a = (x1,y1,z1)</code>，<code>b = (x2,y2,z2)</code>，则叉乘为<code>v1( x1,y1,z1) x v2(x2,y2,z2) = (y1*z2 - y2*z1)i + (x2*z1 - x1*z2)j + (x1*y2-x2*y1)k</code>，或者如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%89%E4%B9%98%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%A4%BA.png?raw=true"></p>
</li>
<li><p>叉乘又称叉积、向量积、外积（<code>cross product</code>）</p>
</li>
<li><p>意义：叉乘的结果是一个向量。向量的模长是两个向量组成的平行四边形的面积；向量的方向是垂直于两个向量的平面<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%89%E4%B9%98%E7%9A%84%E6%84%8F%E4%B9%89.jpg?raw=true"></p>
</li>
<li><p>两个向量的叉积生成第三个向量，该向量垂直于两个输入向量。结果的大小等于： 将两个输入的大小相乘，然后乘以输入之间角度的正弦值。可以使用“左手规则”确定结果向量的方向</p>
</li>
<li><p>叉乘的方向：在左手坐标系用左手定则，在右手坐标系用右手定则<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%B7%A6%E6%89%8B%E8%A7%84%E5%88%99%20.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%B3%E6%89%8B%E8%A7%84%E5%88%99%20.png?raw=true"></p>
</li>
<li><p>应用</p>
</li>
</ul>
<ol>
<li>点乘可以判断出目标物体在我的左边还是右边。叉乘结果向量的<code>y</code>值。大于零在右方，小于零在左方，等于零则这两个向量的方向相同或者相反。例如：<code>a*b</code>，<code>a</code>向量为我正前方的向量，<code>b</code>为目标物体的向量，这两个向量都是以我的所处的位置为起点，叉乘所得向量的<code>y</code>值，如果大于<code>0</code>，说明目标物体位于我的右边；如果小于<code>0</code>，说明目标物体位于我的左边；如果等于<code>0</code>，说明目标物体位于我的正前方或者正后方</li>
<li>判断内和外（判断一个点是否在三角形的内部，可拓展为三角形包含了哪些像素）:<code>P</code>点在三角形内部的条件：<code>P</code>点在三个向量的左边或者右边（受向量方向的影响。如图为逆时针，则<code>P</code>点在三角形内部的条件为<code>P</code>点在三个向量的左边。如果是顺时针，则<code>P</code>点在三角形内部的条件为<code>P</code>点在三个向量的右边）<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%8F%89%E4%B9%98%E5%88%A4%E6%96%AD%E5%86%85%E5%92%8C%E5%A4%96.png?raw=true"></li>
</ol>
<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><ul>
<li>欧拉角有两种：</li>
</ul>
<ol>
<li><p>静态欧拉角：即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静止，所以称为静态。</p>
</li>
<li><p>动态欧拉角：即绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。<strong>（只有动态的欧拉角才会出现万向锁）</strong></p>
</li>
</ol>
<ul>
<li>优点</li>
</ul>
<ol>
<li>欧拉角具有直观的“可读”格式，由三个角度组成</li>
<li>欧拉角可表示通过大于 <code>180</code> 度转向从一个方向到另一个方向的旋转</li>
<li>欧拉角拥有无数种表达方式</li>
</ol>
<ul>
<li>局限性</li>
</ul>
<ol>
<li>欧拉角受到万向锁 (<code>Gimbal Lock</code>) 的影响。当依次施加三个旋转时，第一个或第二个旋转可能导致第三个轴的方向与先前两个轴之一相同。这意味着已失去“自由度”，因为不能围绕唯一轴应用第三个旋转值</li>
</ol>
<ul>
<li>万向节死锁：三个旋转轴提供了三个旋转自由度变成三个旋转轴提供了两个旋转自由度，其中两个轴只能提供一个旋转自由度</li>
<li>如下图</li>
</ul>
<ol>
<li><p><code>y</code>轴（绿色的环）在最上的层级，<code>x</code>轴（红色的环）其次，<code>z</code>轴（蓝色的环）在最下的层级<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E4%B8%87%E5%90%91%E8%8A%82%E6%AD%BB%E9%94%811.png?raw=true"></p>
</li>
<li><p><code>y</code>轴和<code>z</code>轴合并都一起，损失了一个自由度<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E4%B8%87%E5%90%91%E8%8A%82%E6%AD%BB%E9%94%812.png?raw=true"></p>
</li>
</ol>
<h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><ul>
<li>为什么需要四元数？</li>
</ul>
<ol>
<li>欧拉角有很多种表示角度的方法，例如<code>100°</code>的旋转角也可以用<code>-260°</code>表示，而且插值上也存在问题，对一个<code>-260°</code>角和一个<code>50°</code>进行插值是需要先进行转换，先将<code>260°</code>角转换成<code>-100°</code>，再进行插值才可以得到正确的结果</li>
</ol>
<ul>
<li><p>此表示方式在内部由四个数字组成，四元数本质上是一种高阶复数，它的虚部包含了三个虚数单位，<code>i</code>、<code>j</code>、<code>k</code>，即一个四元数可以表示为<code>q = w + bi + cj + dk</code></p>
</li>
<li><p><code>i</code>、<code>j</code>、<code>k</code>分量经过归一化，即<code>i*i+j*j+k*k=1</code>，旋转角的余弦作为实部，旋转角的正弦作为虚部，假如旋转角为<code>40°</code>，指定的单位向量为<code>(0.67,-0.67,0.33)</code>，所以该四元数<code>q</code>为<code>cos(20°)+sin(20°)(0.67i-0.67j+0.33k)</code>，同时取一个点<code>p(1i+0.25j+1.2k)</code>，所以点p旋转后的坐标为<code>q*p*q-1</code>,<code>q-1</code>为<code>q</code>的共轭复数，为<code>cos(-20°)+sin(-20°)(0.67i-0.67j+0.33k)</code>。为什么右乘<code>q</code>的共轭复数？左乘<code>q</code>中不仅对点进行了旋转，还进行了偏移和形变，所以需要右乘<code>q</code>的共轭复数来抵消左乘<code>q</code>的偏移和形变，这也是为什么旋转角为<code>40°</code>，而在四元数中使用<code>20°</code>的原因</p>
</li>
<li><p>即创建一个方向对象，指定一个方向，旋转多少角度，然后生成一个向量坐标，四元数不能表示超过 <code>180</code> 度的旋转</p>
</li>
<li><p>优点</p>
</li>
</ul>
<ol>
<li>四元数旋转不受万向锁的影响</li>
<li>能进行增量旋转</li>
<li>给定方位的表达方式有两种，互为负（即<code>cos(45°)+sin(45°)(0i+1j+0k)</code>和<code>cos(-45°)+sin(-45°)(0i-1j+0k)</code>，它们表示的旋转角相等）</li>
</ol>
<ul>
<li>局限性</li>
</ul>
<ol>
<li>单个四元数不能表示任何方向超过 <code>180</code> 度的旋转</li>
<li>四元数的数字表示在直观上难以理解</li>
</ol>
<ul>
<li>补充</li>
</ul>
<ol>
<li>在<code>Untiy</code>中用四元数旋转点。如下对<code>v1</code>绕<code>y</code>轴旋转<code>90°</code></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Vector3 v1 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//(x,y,z,w)</span></span><br><span class="line">Quaternion q1 = <span class="keyword">new</span> Quaternion(<span class="number">0</span>, Mathf.Sin(Mathf.PI/<span class="number">4</span>), <span class="number">0</span>, Mathf.Cos(Mathf.PI/<span class="number">4</span>));</span><br><span class="line"><span class="comment">//(0,0,1)</span></span><br><span class="line">Vector3 v2 = q1 * v1;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>绕轴旋转正负：从轴的正方向看向原点，左手坐标系下 ：顺序时针方向即是旋转正向;右手坐标系下：逆时针方向即是旋转正向</li>
</ol>
<h1 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h1><ul>
<li>下图是顶点如何从模型空间变换到屏幕坐标的过程<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E9%A1%B6%E7%82%B9%E5%8F%98%E6%8D%A2%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%90%84%E4%B8%AA%E5%9D%90%E6%A0%87%E7%B3%BB.png?raw=true"></li>
</ul>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至<code>-1.0</code>到<code>1.0</code>的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（<code>Viewport Transform</code>）的过程。视口变换将位于<code>-1.0</code>到<code>1.0</code>范围的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E9%A1%B6%E7%82%B9%E7%9A%84%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png?raw=true"></p>
<ul>
<li><code>Unity</code> 中各个坐标空间的旋向性</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/Unity%20%E4%B8%AD%E5%90%84%E4%B8%AA%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E7%9A%84%E6%97%8B%E5%90%91%E6%80%A7.png?raw=true"></p>
<h1 id="模型空间（Model-Space）"><a href="#模型空间（Model-Space）" class="headerlink" title="模型空间（Model Space）"></a>模型空间（<code>Model Space</code>）</h1><ul>
<li>模型空间也称对象空间（<code>Object Space</code>）或局部空间（<code>Local Space</code>）</li>
<li>模型空间是指物体所在的坐标空间，即对象最开始所在的地方。每个模型都有自己独<br>立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转</li>
</ul>
<h1 id="世界空间（World-Space-）"><a href="#世界空间（World-Space-）" class="headerlink" title="世界空间（World Space)）"></a>世界空间（<code>World Space)</code>）</h1><ul>
<li>世界空间可以被用于描述绝对位置（绝对位置指的就是在世界坐标系中的位置）。通常，我们会把世界空间的原点放置在游戏空间的中心</li>
<li>将顶点坐标从模型空间变换到世界空间中，这个变换通常叫做模型变换 (<code>model transform</code>)</li>
</ul>
<h1 id="观察空间（View-Space）"><a href="#观察空间（View-Space）" class="headerlink" title="观察空间（View Space）"></a>观察空间（<code>View Space</code>）</h1><ul>
<li>观察空间也称视觉空间（<code>Eye Space</code>）或称摄像机空间（<code>Camera Space</code>）</li>
<li>在观察空间中，摄像机位于原点，同样，其坐标轴的选择可以是任意的，以 <code>Unity</code> 为例， <code>Unity</code> 中观察空间的坐标轴选择<code>+x</code> 轴指向右方， <code>+y</code> 轴指向上方，而<code>+z</code> 轴指向的是摄像机的后方</li>
<li>观察空间是一个三维空间</li>
<li>将顶点坐标从世界空间变换到观察空间中。这个变换通常叫做观察变换 （<code>view transform</code>）</li>
</ul>
<h1 id="裁剪空间（Clip-Space）"><a href="#裁剪空间（Clip-Space）" class="headerlink" title="裁剪空间（Clip Space）"></a>裁剪空间（<code>Clip Space</code>）</h1><ul>
<li>裁剪空间也称齐次裁剪空间</li>
<li>将顶点从观察空间转换到裁剪空间，这个用于变换的矩阵叫做裁剪矩阵 (<code>clip matrix</code>), 也被称为投影矩阵 (<code>projection matrix</code>)</li>
<li>裁剪空间的目标是能够方便地对渲染图元进行裁剪。完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪</li>
<li>裁剪空间由视锥体决定</li>
</ul>
<h1 id="屏幕空间（Screen-Space）"><a href="#屏幕空间（Screen-Space）" class="headerlink" title="屏幕空间（Screen Space）"></a>屏幕空间（<code>Screen Space</code>）</h1><ul>
<li>顶点从裁剪空间投影到屏幕空间中，来生成对应的<code>2D</code>坐标</li>
<li>屏幕空间是一个二维空间</li>
<li>屏幕坐标系在 <code>OpenGL</code>和 <code>DirectX</code> 之间的差异问题<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E5%90%91%E9%87%8F/%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E7%B3%BB%E5%9C%A8%20%60OpenGL%60%E5%92%8C%20%60DirectX%60%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82%E9%97%AE%E9%A2%98.png?raw=true"></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/89046275">Unity游戏开发——向量运算（点乘和叉乘）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/359975221">向量点乘与叉乘的概念及几何意义</a></li>
<li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_2">LearnOpenGL - 坐标系统</a></li>
<li><a href="https://morisa66.github.io/2021/01/14/MVP/#:~:text=MVP,%E7%9F%A9%E9%98%B5%E5%8D%B3%20Model%EF%BC%88%E6%A8%A1%E5%9E%8B%EF%BC%89%E3%80%81View%EF%BC%88%E8%A7%82%E5%AF%9F%EF%BC%89%E3%80%81Projection%EF%BC%88%E6%8A%95%E5%BD%B1%EF%BC%89%E7%9F%A9%E9%98%B5%E3%80%82">MVP 矩阵公式推导</a></li>
<li><a href="https://docs.qq.com/slide/DUGZtZlVtQVBRaFli">渲染管线简介</a></li>
<li><a href="https://www.bilibili.com/video/BV1Lt411U7og/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=d2d44d4ce8893453aa70df7d2d5f6651">3Blue1Brown - 四元数和三维转动，可互动的探索式视频</a></li>
<li><a href="https://eater.net/quaternions/video/intro">四元数和三维转动，可互动的探索式网页</a></li>
<li>《Unity Shader入门精要》</li>
<li>《Unity3D 高级编程：主程手记》</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2023/04/01/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>备忘录模式：<strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</strong></li>
<li>备忘录模式属于行为型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>原发器（Originator）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，<strong>一般将需要保存内部状态的类设计为原发器</strong></li>
<li>备忘录（Memento）：<strong>存储原发器的内部状态，根据原发器来决定保存哪些内部状态</strong>。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同</li>
<li>负责人（Caretaker）：负责人又称为管理者，<strong>它负责保存备忘录，但是不能对备忘录的内容进行操作或检查</strong>。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/memento.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原</li>
<li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作</li>
<li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象</li>
</ol>
<ul>
<li>注意事项：</li>
</ul>
<ol>
<li>为了符合迪米特原则，还要增加一个管理备忘录的类。 </li>
<li>为了节约内存，可使用原型模式+备忘录模式</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原发器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Boss</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span>(<span class="params"><span class="built_in">float</span> _hp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = _hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">SaveMemento</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(hp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestoreMemento</span>(<span class="params">Memento m</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = m.hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//备忘录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Memento</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span>(<span class="params"><span class="built_in">float</span> _hp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = _hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置新的备忘录状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetState</span>(<span class="params"><span class="built_in">float</span> _hp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = _hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负责人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Memento memento;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(<span class="number">100f</span>);</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">        caretaker.memento = boss.SaveMemento();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//改变原发器状态</span></span><br><span class="line">        boss.hp = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">//50</span></span><br><span class="line">        Debug.Log(boss.hp);</span><br><span class="line">        <span class="comment">//恢复状态</span></span><br><span class="line">        boss.RestoreMemento(caretaker.memento);</span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        Debug.Log(boss.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Memento%20Pattern">备忘录模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511461">C#设计模式笔记之备忘录模式 (Memento Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/memento-pattern.html">备忘录模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2023/04/03/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>外观模式：<strong>为复杂的子系统中提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</strong></li>
<li>外观模式属于结构型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>外观类（Facade）：<strong>在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任</strong>；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理</li>
<li>子系统类集合（SubSystem Classes）：<strong>子系统类集合实现了子系统的功能，处理外观类对象指派的任务</strong></li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/facade.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>Facade模式降低了客户端对子系统使用的复杂性。</li>
<li>外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</li>
<li>通过合理使用Facade，可以帮助我们更好的划分访问的层次</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>过多的或者是不太合理的Facade也容易让人迷惑，到底是调用Facade好呢，还是直接调用模块好</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>需要将设计进行分层时考虑Facade模式。</li>
<li>在开发阶段，子系统往往因为重构变得越来越复杂，增加外观模式可以提供一个简单的接口，减少它们之间的依赖。</li>
<li>在维护一个遗留的大型系统时，可以这个系统已经非常难以维护和扩展，可以为新系统开发一个Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外观类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Facade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemOne one;</span><br><span class="line">    <span class="keyword">private</span> SubSystemTwo two;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = <span class="keyword">new</span> SubSystemOne();</span><br><span class="line">        two = <span class="keyword">new</span> SubSystemTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        one.Request();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        two.Attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubSystemOne</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;SubSystemOne接受请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubSystemTwo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;SubSystemTwo攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        <span class="comment">//SubSystemOne接受请求</span></span><br><span class="line">        facade.Request();</span><br><span class="line">        <span class="comment">//SubSystemTwo攻击</span></span><br><span class="line">        facade.Attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Facade%20Pattern">外观模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511002">C#设计模式笔记之外观模式（Facade pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/facade-pattern.html">外观模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>事件队列模式</title>
    <url>/2023/04/04/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>事件队列模式：<strong>对消息或事件的发送与处理进行时间上的解耦</strong></li>
<li>要点</li>
</ul>
<ol>
<li>事件队列：<strong>在先入先出的队列中存储一系列通知或请求。发送通知时，将请求放入队列并返回。处理请求的系统在稍晚些的时候从队列中获取请求并进行处理。</strong>这样就解耦了发送者和接收者，既静态又及时。</li>
<li>事件队列很复杂，会对游戏架构引起广泛影响。中心事件队列是一个全局变量。这个模式的通常方法是一个大的交换站，游戏中的每个部分都能将消息送过这里。</li>
<li>事件队列是基础架构中很强大的存在，但有些时候强大并不代表好。事件队列模式将状态包裹在协议中，但是它还是全局的，仍然存在全局变量引发的一系列危险。</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象事件：定义处理消息或者事件的接口</li>
<li>具体事件：继承抽象事件，定义具体事件处理消息或者事件的方法</li>
<li>事件队列：定义一个存储事件的集合，提供处理事件的方法，供外部在合适时机调用或者自备合适时机处理消息或事件的方法，外部直接调用</li>
</ol>
<ul>
<li>使用场合</li>
</ul>
<ol>
<li>如果你只是想解耦接收者和发送者，像观察者模式和命令模式都可以用较小的复杂度来进行处理。在需要解耦某些实时的内容时才建议使用事件队列。</li>
<li>不妨用推和拉来的情形来考虑。有一块代码A需要另一块代码B去做些事情。对A自然的处理方式是将请求推给B。同时，对B自然的处理方式是在B方便时将请求拉入。当一端有推模型另一端有拉模型时，你就需要在它们间放一个缓冲的区域。这就是队列比简单的解耦模式多出来的那一部分。队列给了代码对拉取的控制权——接收者可以延迟处理，合并或者忽视请求。发送者能做的就是向队列发送请求然后就完事了，并不能决定什么时候发送的请求会受到处理。</li>
<li>而当发送者需要一些回复反馈时，队列模式就不是一个好的选择</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li>很大程度上， 事件队列模式就是广为人知的GOF设计模式中观察者模式的异步实现。</li>
<li>就像其他很多模式一样，事件队列有很多别名。 其中一个是“消息队列”。消息队列通常指代一个更高层次的实现。可以这样理解，事件队列在应用中进行交流，而消息队列通常在应用间进行交流。另一个别名是“发布&#x2F;提交”，有时被缩写为“pubsub”，这个别名通常指代更大的分布式系统中的应用。</li>
<li>在有限状态机与状态模式中，往往需要一个输入流。如果想要异步响应，可以考虑用队列模式来存储它们。</li>
<li>Go语言内建的“Channel”机制，其本质上就是事件队列。</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//待处理的消息和事件的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;IMessageEvent&gt; eventList = <span class="keyword">new</span> List&lt;IMessageEvent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddMessageEvent</span>(<span class="params">IMessageEvent target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventList.Add(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventList.Count&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> tmp = eventList[<span class="number">0</span>];</span><br><span class="line">            tmp.Request();</span><br><span class="line">            eventList.Remove(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMessageEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AMessageEvent</span> : <span class="title">IMessageEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BMessageEvent</span> : <span class="title">IMessageEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EventQueue eventQueue;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventQueue = <span class="keyword">new</span> EventQueue();</span><br><span class="line">        eventQueue.AddMessageEvent(<span class="keyword">new</span> AMessageEvent());</span><br><span class="line">        eventQueue.AddMessageEvent(<span class="keyword">new</span> BMessageEvent());</span><br><span class="line">        <span class="comment">//等待1s后，每2s处理消息或者事件</span></span><br><span class="line">        <span class="comment">//A </span></span><br><span class="line">        <span class="comment">//B</span></span><br><span class="line">        InvokeRepeating(<span class="string">&quot;EventQueueHandle&quot;</span>, <span class="number">1f</span>, <span class="number">2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EventQueueHandle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventQueue.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/event-queue.html">游戏编程模式 - 事件队列模式</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#11">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Event%20Queue%20Pattern">事件队列模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>字节码</title>
    <url>/2023/04/04/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>字节码：<strong>将行为编码为虚拟机器上的指令，赋予其数据的灵活性</strong></li>
<li>要点</li>
</ul>
<ol>
<li>字节码模式：指令集定义了可执行的底层操作。 一系列的指令被编码为字节序列。虚拟机使用中间值堆栈 依次执行这些指令。通过组合指令，可以定义复杂的高层行为。</li>
<li>可以理解为项目中的转表工具，将excel中的数据转为二进制数据，并读取到工程中，如在项目中使用google protobuf或json。</li>
<li>字节码类似GOF的解释器模式，这两种方式都能让我们将数据与行为相组合。其实很多时候都是两者一起使用。用来构造字节码的工具会有内部的对象树，而为了编译到字节码，我们需要递归回溯整棵树，就像用解释器模式去解释它一样。唯一的不同在于，并不是立即执行一段行为，而是生成整个字节码再执行</li>
</ol>
<ul>
<li>使用场合，这是GPP一书中最复杂的模式，不能轻易的加入到游戏中。 当我们需要定义很多行为，而游戏实现语言因为以下原因不能很好地完成任务时，就可以使用字节码模式：</li>
</ul>
<ol>
<li>这些行为过于底层，繁琐易错。</li>
<li>这些行为遍历起来很缓慢，导致编译时间长。</li>
<li>这些行为太受依赖。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开。</li>
</ol>
<ul>
<li><p>如果是上述的这些情况，就比较适合使用字节码模式。</p>
</li>
<li><p>但需要注意，字节码比本地代码慢，所以最好不要用于引擎对性能敏感的部分</p>
</li>
<li><p>引申与参考</p>
</li>
</ul>
<ol>
<li>Lua的内部实现就是一个非常紧凑的，基于寄存器的字节码虚拟机</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Instruction</span><br><span class="line">&#123;</span><br><span class="line">    INST_SET_HEALTH      = <span class="number">0</span>,</span><br><span class="line">    INST_SET_WISDOM      = <span class="number">1</span>,</span><br><span class="line">    INST_SET_AGILITY     = <span class="number">2</span>,</span><br><span class="line">    INST_PLAY_SOUND      = <span class="number">3</span>,</span><br><span class="line">    INST_SPAWN_PARTICLES = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyApi</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetHealth</span>(<span class="params"><span class="built_in">int</span> wizard, <span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;设置<span class="subst">&#123;wizard&#125;</span>：Health为：<span class="subst">&#123;amount&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetWisdom</span>(<span class="params"><span class="built_in">int</span> wizard, <span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;设置<span class="subst">&#123;wizard&#125;</span>：Wisdom为：<span class="subst">&#123;amount&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAgility</span>(<span class="params"><span class="built_in">int</span> wizard, <span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;设置<span class="subst">&#123;wizard&#125;</span>：Agility为：<span class="subst">&#123;amount&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlaySound</span>(<span class="params"><span class="built_in">int</span> soundId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;播放：<span class="subst">&#123;soundId&#125;</span>音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpawnParticles</span>(<span class="params"><span class="built_in">int</span> particleType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;生成：<span class="subst">&#123;particleType&#125;</span>粒子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VM</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyApi myApi = <span class="keyword">new</span> MyApi();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params"><span class="built_in">int</span>[] bytecode</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytecode.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> instruction = bytecode[i];</span><br><span class="line">            <span class="keyword">switch</span> (instruction)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">int</span>)Instruction.INST_SET_HEALTH:</span><br><span class="line">                    myApi.SetHealth(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">int</span>)Instruction.INST_SET_WISDOM:</span><br><span class="line">                    myApi.SetWisdom(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">int</span>)Instruction.INST_SET_AGILITY:</span><br><span class="line">                    myApi.SetAgility(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">int</span>)Instruction.INST_PLAY_SOUND:</span><br><span class="line">                    myApi.PlaySound(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">int</span>)Instruction.INST_SPAWN_PARTICLES:</span><br><span class="line">                    myApi.SpawnParticles(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        VM vm = <span class="keyword">new</span> VM();</span><br><span class="line">        <span class="built_in">int</span>[] bytes = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="comment">//设置0：Health为：100</span></span><br><span class="line">        <span class="comment">//设置0：Wisdom为：100</span></span><br><span class="line">        <span class="comment">//设置0：Agility为：100</span></span><br><span class="line">        <span class="comment">//播放：0音效</span></span><br><span class="line">        <span class="comment">//生成：0粒子</span></span><br><span class="line">        vm.Interpret(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/bytecode.html">游戏编程模式 - 字节码</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2022/06/18/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>命令模式：是一种数据驱动的设计模式，属于行为型模式。在<code>GoF</code>定义为<strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</strong>。命令模式是一种回调的面向对象实现；在游戏编程模式中精简定义为<strong>命令是具现化的方法调用</strong></li>
<li>命令模式属于行为型模式</li>
<li>目的：行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。这种情况下，我们可以使用命令模式，将请求封装成对象，实现行为请求者与行为实现者之间的松耦合</li>
<li>过程：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者</li>
<li>优点：</li>
</ul>
<ol>
<li>通过引入中间件（抽象接口）降低系统的耦合度</li>
<li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li>
<li>方便实现 <code>Undo</code>(撤销) 和 <code>Redo</code>(重做) 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</li>
<li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活</li>
</ol>
<ul>
<li><p>缺点：可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性</p>
</li>
<li><p>命令模式包含以下主要角色</p>
</li>
</ul>
<ol>
<li>抽象命令类（<code>Command</code>）角色：是一个抽象类，类中对需要被执行的命令进行声明，一般来说要对外公布一个 <code>execute</code> 方法用来执行命令，而有撤销需求的还会公布一个<code>unexecute</code>方法</li>
<li>具体命令类（<code>Concrete Command</code>）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。<code>Command</code>类的实现类，需要重写<code>Command</code>类中声明的方法</li>
<li>实现者&#x2F;接收者（<code>Receiver</code>）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。为游戏玩家对象和其他游戏对象</li>
<li>调用者&#x2F;请求者（<code>Invoker</code>）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</li>
</ol>
<ul>
<li><p>结构示意图</p>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></p>
</li>
</ul>
<h1 id="配置输入"><a href="#配置输入" class="headerlink" title="配置输入"></a>配置输入</h1><ul>
<li><p>使用命令模式之前<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D.png?raw=true"></p>
</li>
<li><p>使用命令模式之后<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%90%8E.png?raw=true"></p>
</li>
<li><p>如下代码，分别为抽象命令类、具体命令类、实例化具体命令类、请求者</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里可以改为一个接口，让接收者继承该接口，那么在具体命令类中就不用SendMessage</span></span><br><span class="line">    <span class="keyword">public</span> GameObject go;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ForwardCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.SendMessage(<span class="string">&quot;Forward&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.SendMessage(<span class="string">&quot;Back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LeftCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.SendMessage(<span class="string">&quot;Left&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RightCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.SendMessage(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化具体命令类。封装成静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AllCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ForwardCommand m_forward = <span class="keyword">new</span> ForwardCommand();</span><br><span class="line">    <span class="keyword">public</span> BackCommand m_back = <span class="keyword">new</span> BackCommand();;       </span><br><span class="line">    <span class="keyword">public</span> LeftCommand m_left = <span class="keyword">new</span> LeftCommand();;</span><br><span class="line">    <span class="keyword">public</span> RightCommand m_right = <span class="keyword">new</span> RightCommand();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;KeyCode&gt; keyCodeList = <span class="keyword">new</span> List&lt;KeyCode&gt; &#123; KeyCode.W, KeyCode.S, KeyCode.A, KeyCode.D &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject target;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetGameObject(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ExchangeGameObject();</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置操作的游戏物体</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetGameObject</span>(<span class="params">GameObject tmp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AllCommand.m_forward.go = tmp;</span><br><span class="line">        AllCommand.m_back.go = tmp;</span><br><span class="line">        AllCommand.m_left.go = tmp;</span><br><span class="line">        AllCommand.m_right.go = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测更换操作的游戏物体</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExchangeGameObject</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.K))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==GameObject.Find(<span class="string">&quot;Car&quot;</span>))</span><br><span class="line">                target = GameObject.Find(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                target = GameObject.Find(<span class="string">&quot;Car&quot;</span>);</span><br><span class="line">            SetGameObject(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的按键返回的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Command <span class="title">InputkeyCodes</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodeList[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> AllCommand.m_forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodeList[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> AllCommand.m_back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodeList[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> AllCommand.m_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodeList[<span class="number">3</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> AllCommand.m_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据返回的命令执行不同的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Command comand = InputkeyCodes();</span><br><span class="line">        <span class="keyword">if</span> (comand != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            comand.Excute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Player</code>挂载名为<code>PlayerController</code>的脚本，<code>Car</code>挂载名为<code>CarController</code>的脚本，<code>Player</code>和<code>Car</code>为<code>Receiver</code></p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Forward</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Player.Forward&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Back</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Player.Back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Left</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Player.Left&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Right</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Player.Right&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Forward</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Car.Forward&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Back</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Car.Back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Left</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Car.Left&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Right</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Car.Right&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h1><ul>
<li>将此脚本挂在<code>Cube</code>上即可</li>
<li>通过泛型集合<code>List</code>存储命令和索引，实现撤销和重做<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">GameObject go</span>)</span>;</span><br><span class="line">    <span class="comment">//撤销操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">UnDo</span>(<span class="params">GameObject go</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ForwardCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.up;</span><br><span class="line">        Debug.Log(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UnDo</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.down;</span><br><span class="line">        Debug.Log(<span class="string">&quot;撤销向上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.down;</span><br><span class="line">        Debug.Log(<span class="string">&quot;向下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UnDo</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.up;</span><br><span class="line">        Debug.Log(<span class="string">&quot;撤销向下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LeftCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.left;</span><br><span class="line">        Debug.Log(<span class="string">&quot;向左&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UnDo</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.right;</span><br><span class="line">        Debug.Log(<span class="string">&quot;撤销向左&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RightCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.right;</span><br><span class="line">        Debug.Log(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UnDo</span>(<span class="params">GameObject go</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        go.transform.position = go.transform.position + Vector3.left;</span><br><span class="line">        Debug.Log(<span class="string">&quot;撤销向右&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandPattern</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//记录操作命令的泛型集合的索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> curIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录操作命令的泛型集合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Command&gt; commands = <span class="keyword">new</span> List&lt;Command&gt;();</span><br><span class="line">    <span class="comment">//Cube</span></span><br><span class="line">    <span class="keyword">public</span> GameObject cube;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ForwardCommand forward;</span><br><span class="line">    <span class="keyword">private</span> BackCommand back;</span><br><span class="line">    <span class="keyword">private</span> LeftCommand left;</span><br><span class="line">    <span class="keyword">private</span> RightCommand right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按键</span></span><br><span class="line">    <span class="keyword">public</span> KeyCode[] keyCodes = &#123; KeyCode.W, KeyCode.S, KeyCode.A, KeyCode.D, KeyCode.Z, KeyCode.Y &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过名字查找对象</span></span><br><span class="line">        cube = GameObject.Find(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        forward = <span class="keyword">new</span> ForwardCommand();</span><br><span class="line">        back = <span class="keyword">new</span> BackCommand();</span><br><span class="line">        left = <span class="keyword">new</span> LeftCommand();</span><br><span class="line">        right = <span class="keyword">new</span> RightCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Inputkeycode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Inputkeycode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            commands.Add(forward);</span><br><span class="line">            forward.Do(cube);</span><br><span class="line">            ++curIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            commands.Add(back);</span><br><span class="line">            back.Do(cube);</span><br><span class="line">            ++curIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            commands.Add(left);</span><br><span class="line">            left.Do(cube);</span><br><span class="line">            ++curIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">3</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            commands.Add(right);</span><br><span class="line">            right.Do(cube);</span><br><span class="line">            ++curIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按Z键撤销</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">4</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;此次撤销的索引值为&quot;</span> + curIndex);</span><br><span class="line">            <span class="keyword">if</span>(curIndex==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;已最旧, 无法再撤销&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                commands[curIndex].UnDo(cube);</span><br><span class="line">                --curIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按Y键重做</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(keyCodes[<span class="number">5</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;此次重做的索引值为&quot;</span> + curIndex);</span><br><span class="line">            <span class="keyword">if</span>(curIndex+<span class="number">1</span>&gt;=commands.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;已最新, 无法再重做&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++curIndex;</span><br><span class="line">                commands[curIndex].Do(cube);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://gpp.tkchu.me/command.html">游戏编程模式 - 命令模式</a></li>
<li><a href="https://www.runoob.com/design-pattern/command-pattern.html">命令模式 | 菜鸟教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46937284">游戏设计模式 - 命令模式在Unity中的应用(C#)</a></li>
<li><a href="https://blog.csdn.net/weixin_43994445/article/details/121303615">Unity命令模式, 实现撤销&#x2F;反撤销</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>寻路算法</title>
    <url>/2022/06/22/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul>
<li>图：由”节点”或”顶点”(<code>Vertex</code>）以及连接这些顶点的”边”（<code>Edge</code>）组成<br>。表示为<code>G=(V,E)</code></li>
<li>图的存储结构有邻接矩阵、邻接表等</li>
</ul>
<ol>
<li>邻接矩阵：用一个一维数组存储图中的顶点，存储顶点之间邻接关系的二维数组称为邻接矩阵，邻接矩阵是一个<code>n*n</code>的方阵。无向图的邻接矩阵一定是对称矩阵，而有向图的不一定。邻接矩阵适合表示稠密图</li>
</ol>
<ul>
<li>无向图及其邻接矩阵存储示意图</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></p>
<ul>
<li>有向图及其邻接矩阵存储示意图</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></p>
<ol start="2">
<li>邻接表：是一顺序存储与链接存储相结合的存储方法。对于图的每个顶点v，将v的所有邻接点链成一个单链表，称为顶点v的边表。邻接表适合表示稀疏图</li>
</ol>
<ul>
<li>无向图的邻接表存储示意图</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></p>
<ul>
<li>有向图的邻接表存储示意图</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></p>
<h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h1><ul>
<li><p><code>BFS</code>是一种盲目搜寻法（又叫非启发式搜索），它的思想是从一个顶点开始，在各个方向上均等搜索，辐射状地优先遍历其周围较广的区域，彻底地搜索整张图</p>
</li>
<li><p>广度优先搜索无法计算加权最短路径</p>
</li>
<li><p>流程</p>
</li>
</ul>
<ol>
<li>设定搜索起点<code>S</code>，放入<code>openList</code>（用于记忆访问节点）队列中。新建<code>closeList</code>队列用于存放已访问的节点，防止重复访问</li>
<li>判断<code>openList</code>是否为空，若为空，搜索结束；若不为空，拿出<code>openList</code>中的第一个节点<code>G</code></li>
<li>遍历<code>G</code>的上下左右四个相邻节点<code>N1-N4</code>，对每个节点<code>N</code>，如果<code>N</code>不在<code>openList</code>或<code>closeList</code>中，那么令<code>N</code>的父节点为<code>G</code>，将<code>N</code>放入<code>openList</code>中。如果<code>N</code>已经在<code>openList</code>或<code>closeList</code>中，跳过不处理，最后将<code>G</code>放入<code>closeList</code>中</li>
<li>重复步骤2-3</li>
</ol>
<ul>
<li><p>广度优先搜索示意图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B%E5%9B%BE.gif?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png?raw=true"></p>
</li>
<li><p>补充</p>
</li>
</ul>
<ol>
<li>可以在流程2-3之间判断<code>G</code>是否为目标点，如果是，则可提前结束搜索，而不必搜索全部区域：如下<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%8F%90%E5%89%8D%E7%BB%93%E6%9D%9FBFS.png?raw=true"></li>
</ol>
<h1 id="Dijkstra（统一成本搜索）"><a href="#Dijkstra（统一成本搜索）" class="headerlink" title="Dijkstra（统一成本搜索）"></a>Dijkstra（统一成本搜索）</h1><ul>
<li><code>Dijkstra</code>算法用于求单源点最短路径问题。是贪心思想实现的（单源：从一个顶点出发，<code>Dijkstra</code>算法只能求一个顶点到其他点的最短距离而不能任意两点）</li>
<li><code>Dijkstra</code>相比于广度优先算法，添加了移动成本计算。每个节点的优先级<code>F</code>，是起点走到当前格子的成本<code>G</code>。估价函数<code>F = G</code></li>
<li>时间复杂度和空间复杂度为<code>O(n^2)</code></li>
<li>流程</li>
</ul>
<ol>
<li><code>result</code>集合：已求出最小路径的顶点。<code>notFound</code>集合：未求出最小路径的顶点，里面的值是到起点的距离。将起点放入<code>result</code>，将其余各点放入<code>notFound</code>，若该点是起点的邻接点，修改其在<code>notFound</code>中的值，否则设为无穷大</li>
<li>判断<code>notFound</code>是否为空，若为空，搜索结束；若不为空，拿出<code>notFound</code>中值最小的顶点<code>A</code>，放入<code>result</code></li>
<li>计算顶点<code>A</code>的邻接点<code>B</code>，若（顶点<code>A</code>的距离+顶点<code>A</code>到顶点<code>B</code>的权值） &lt; 顶点<code>B</code>的距离，则修改顶点<code>B</code>的值</li>
<li>重复步骤2-3</li>
</ol>
<ul>
<li><p>下面对比了不考虑节点移动代价差异的广度优先搜索与考虑移动代价的<code>Dijkstra</code>算法的运算结果<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/dij%E5%92%8C%E5%B9%BF%E5%BA%A6%E5%AF%B9%E6%AF%94.gif?raw=true"></p>
</li>
<li><p>补充</p>
</li>
</ul>
<ol>
<li>当图形为网格图，并且每个节点之间的移动代价是相等的，那么<code>Dijkstra</code>算法将和广度优先算法变得一样</li>
<li>如果地图过大，那么开始时放入<code>notFound</code>里的节点数量就会很多，此时如果<code>notFound</code>是优先队列，那么执行过程中性能消耗会增大</li>
</ol>
<h1 id="最佳优先搜索（GBFS）"><a href="#最佳优先搜索（GBFS）" class="headerlink" title="最佳优先搜索（GBFS）"></a>最佳优先搜索（GBFS）</h1><ul>
<li>贪婪最佳优先搜索：是启发式算法。可以将它看做广度优先搜索算法的一种改进；最佳优先搜索算法在广度优先搜索的基础上，用启发估价函数对将要被遍历到的点进行估价，然后选择代价小的进行遍历，直到找到目标节点或者遍历完所有点，算法结束</li>
<li>每个节点的代价<code>F</code>由<code>H</code>决定。是当前节点到终点的距离。估价函数<code>F = H</code></li>
<li>步骤</li>
</ul>
<ol>
<li><code>OpenList</code>优先队列：待到达的格子，<code>CloseList</code>集合：已到达的格子。将起点放入<code>OpenList</code></li>
<li>如果<code>OpenList</code>不为空，找出其中<code>F</code>最小的节点作为当前方格，如果该节点是目标节点，则结束循环，否则放入<code>CloseList</code></li>
<li>找出当前方格所有可到达的节点<code>N</code>，分三种情况：1）<code>N</code>不在<code>OpenList</code>或<code>CloseList</code>中，计算<code>F</code>，放入<code>OpenList</code>队列中；2）<code>N</code>在<code>OpenList</code>中，且<code>F</code>值小于<code>OpenList</code>中的<code>N</code>，则将其替换成新的<code>F</code>值；3）<code>N</code>在<code>CloseList</code>中，且<code>F</code>值小于<code>CloseList</code>中的<code>N</code>，则将<code>CloseList</code>中<code>N</code>节点移除并放入<code>OpenList</code>。最后将当前方格放入<code>CloseList</code></li>
<li>重复2-3</li>
</ol>
<ul>
<li>下图为广度优先搜索与最佳优先搜索对比，左边是广度优先搜索，右边是最佳优先搜索<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.gif?raw=true"></li>
<li>缺点：如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E7%BC%BA%E7%82%B9.gif?raw=true"></li>
</ul>
<h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><ul>
<li><p><code>A*</code>：是启发式算法（一种基于成本计算的最优解）。通过<code>F = G + H</code>来计算每个节点的优先级。<code>F</code>：<code>G</code>和<code>H</code>的综合评估，值越小，优先级越高，也就是从起点到达当前格子，再从当前格子到达目标格子的总步数。<code>G</code>：从起点走到当前格子的成本，也就是已经花费了多少步。<code>H</code>：在不考虑障碍的情况下，从当前格子走到目标格子的距离，也就是离目标还有多远，计算距离的方式可根据移动方向决定。估价函数<code>F = G + H</code></p>
</li>
<li><p><code>A*</code>是<code> Unity</code> 使用的算法</p>
</li>
<li><p>平均时间复杂度：<code>O(nlogn)</code></p>
</li>
<li><p>流程</p>
</li>
</ul>
<ol>
<li><code>OpenList</code>优先队列：待到达的格子，<code>CloseList</code>集合：已到达的格子。将起点放入<code>OpenList</code></li>
<li>如果<code>OpenList</code>不为空，找出其中<code>F</code>最小的节点作为当前方格，如果该节点是目标节点，则结束循环，否则放入<code>CloseList</code>。如果目标节点在<code>CloseList</code>集合中，则已经找到了最佳路径</li>
<li>找出当前方格所有可到达的节点，看它们是否在<code>OpenList</code>或<code>CloseList</code>中。如果都不在，则将它们放入<code>OpenList</code>，计算相应的<code>F</code>、<code>G</code>、<code>H</code>值，并将当前方格作为它们的父节点；如果在<code>CloseList</code>中，则跳过该节点</li>
<li>重复步骤<code>2-3</code></li>
</ol>
<ul>
<li>例子：假设我们有一个<code>7×5</code>大小的迷宫，上图中绿色的格子是起点，红色的格子是终点，中间的<code>3</code>个蓝色格子是一堵墙。角色从起点开始，每一步只能向上下&#x2F;左右移动<code>1</code>格，且不能穿越墙壁。那么如何让角色用最少的步数到达终点？</li>
<li>每个节点的<code>F</code>、<code>G</code>、<code>H</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E8%8A%82%E7%82%B9%E7%9A%84FGH.png?raw=true"></li>
</ul>
<ol>
<li>将起点放入<code>OpenList</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E6%AD%A5%E9%AA%A41.png?raw=true"></li>
<li>找出其中<code>F</code>最小的节点作为当前方格<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E6%AD%A5%E9%AA%A42.png?raw=true"></li>
<li>找出当前方格所有可到达的节点<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E6%AD%A5%E9%AA%A4%E4%B8%89.png?raw=true"></li>
<li>重复步骤2-3</li>
</ol>
<ul>
<li><p>第二轮循环后<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E7%AC%AC%E4%BA%8C%E8%BD%AE%E5%BE%AA%E7%8E%AF.png?raw=true"></p>
</li>
<li><p>第三轮循环后<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E7%AC%AC%E4%B8%89%E8%BD%AE%E5%BE%AA%E7%8E%AF.png?raw=true"></p>
</li>
<li><p>最终结果<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E6%9C%80%E7%BB%88%E5%BE%AA%E7%8E%AF.png?raw=true"></p>
</li>
<li><p><code>A*</code>与最佳优先搜索对比。左边是最佳优先搜索，右边是<code>A*</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E5%92%8C%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%AF%B9%E6%AF%94.png?raw=true"></p>
</li>
<li><p>补充</p>
</li>
</ul>
<ol>
<li>如果令<code>H</code>等于<code>0</code>，那么<code>A*</code>就会退化为<code>Dijkstra</code>。如果令<code>G</code>等于<code>0</code>，那么<code>A*</code>就会退化为<code>GBFS</code></li>
<li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离；如果图形中允许朝八个方向移动，则可以使用对角距离；如果图形中允许朝任何方向移动，则可以使用欧几里得距离</li>
<li>下图中红线代表曼哈顿距离；绿色代表欧氏距离，也就是直线距离。而蓝色和黄色代表等价的曼哈顿距离。曼哈顿距离用以标明两个点上在标准坐标系上的绝对轴距之总和。在二维平面上，<code>d(x,y) = |x1-x2| + |y1-y2|</code>。欧氏距离是两点之间线段的长度，在二维平面上，<img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB%E4%BA%8C%E7%BB%B4%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png?raw=true"><br>​<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%90%84%E7%A7%8D%E8%B7%9D%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></li>
</ol>
<h2 id="A-优化"><a href="#A-优化" class="headerlink" title="A*优化"></a>A*优化</h2><h3 id="长距离导航"><a href="#长距离导航" class="headerlink" title="长距离导航"></a>长距离导航</h3><ul>
<li>长距离导航通常发生在场景地图很大的情况下，当我们需要寻路的两点距离很长，中间有很多障碍物时，<code>A*</code>算法就会有瓶颈。即当两点距离很长，<code>OpenList</code>队列会被塞入很多节点，进而导致排序速度变慢</li>
<li>优化方法：可以把路径寻路中实时运算的一大部分转化到离线状态下进行。在这种大地图的寻路算法中，通常不需要非常精确的寻路路线，因为它的目标只是脱手操作达到目的地，而不是走最短路径，因此我们可以把中间很长一段距离的计算放到脱机工具中去。将一些常用的路径在离线状态下计算好并放在数据文件中，当需要时，再从已经计算好的点对点数据中寻找起点和目的地最近的数据，找到后即可直接使用而不用再次计算</li>
<li>例子：如图中<code>A</code>点到<code>B</code>点的路径是我们已经计算好的并存放在内存里的，当要在<code>A</code>点的附近<code>C</code>点寻路到<code>B</code>点附近的<code>D</code>点时，即从起点<code>C</code>到终点<code>D</code>，这中间由<code>A</code>点到<code>B</code>点的相似路径。由于离线时<code>A</code>点和<code>B</code>点的路劲已经计算完毕，那么可以先计算<code>C</code>点到A点的路径和<code>B</code>点到<code>D</code>点的路径，再调出<code>A</code>和<code>B</code>点的路径进行拼接，即可完成<code>C</code>点到<code>D</code>点的寻路<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E5%AF%BB%E8%B7%AF.jpg?raw=true"><h3 id="A-排序算法优化"><a href="#A-排序算法优化" class="headerlink" title="A*排序算法优化"></a>A*排序算法优化</h3></li>
<li><code>OpenList</code>队列在<code>A*</code>起重要作用。由于每次向<code>OpenList</code>中插入点后，<code>OpenList</code>就不再有序了，所以每次取最小值时，都要重新进行排序</li>
<li>优化方法：<code>OpenList</code>使用最小堆（或优先队列）来执行插入操作，它的插入和删除的时间复杂度都为<code>O(logn)</code></li>
</ul>
<h3 id="通过权重引导巡路方向"><a href="#通过权重引导巡路方向" class="headerlink" title="通过权重引导巡路方向"></a>通过权重引导巡路方向</h3><ul>
<li>期望值<code>F</code>所代表的通向目的地的地方越准确，寻路算法效率越高，寻找到路径的速度也就越快，所以，期望值问题就变成了如何帮助期望值更加准确地判断通向目的地的方向</li>
<li>优化方法：在某些网格（这些网格用于引导寻路）中加入权重值<code>E</code>来改变期望值<code>F</code>。所以，<code>F = G + H + E</code></li>
<li>例子：如下图的浅色格子时，所有可行走的格子都会给一个基础权重(假设为<code>100</code>)，而用来引导寻路的浅色格子的权值设为比基础权重更低(假设为<code>10</code>)。通过这个期望着公式，在计算期望值时，浅色引导的格子会比其他格子获得更小的值，这也意味着浅色引导类格子会在<code>OpenList</code>更靠前，更容易被算法取出而成为路径搜索方向。<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E9%80%9A%E8%BF%87%E6%9D%83%E9%87%8D%E5%BC%95%E5%AF%BC%E5%B7%A1%E8%B7%AF%E6%96%B9%E5%90%91.jpg?raw=true"></li>
</ul>
<h3 id="拆分寻路区域"><a href="#拆分寻路区域" class="headerlink" title="拆分寻路区域"></a>拆分寻路区域</h3><ul>
<li>当地图很大时，寻路会很费劲，主要原因是节点数量过多，如果路径上的节点都要搜一遍，会导致<code>OpenList</code>队列越来越大，计算量也越来越大，所以问题的关键在于如何减少搜索的次数</li>
<li>优化方法：将某个范围内的格子（节点）合并为一个区域，那么整个地图会分成几十个区域，相较于成千上万个格子作为寻路节点要好得多。但需要保证区域内的点对点不再需要寻路（区域内任意两点可以直达，区域内无任何障碍物），则需要该区域为无障碍的凸多边形。寻路时以区域块为寻路网格，每个区域都记录与之连接的区域以连接点，当算法找到起点与目的地点的区域路径时，只要拼接邻接的路径点就能得出两点的真实路径</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%8B%86%E5%88%86%E5%AF%BB%E8%B7%AF%E5%8C%BA%E5%9F%9F1.jpg?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%8B%86%E5%88%86%E5%AF%BB%E8%B7%AF%E5%8C%BA%E5%9F%9F2.jpg?raw=true"></p>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>对动态添加障碍物并不是十分友好。如果动态添加或更改障碍物则需要对此区域重新计算分区</li>
<li>需要考虑不同拆分区域的算法。比如栅格地图较三角形网格地图的拆分区域算法简单</li>
</ol>
<h1 id="跳点算法-JPS"><a href="#跳点算法-JPS" class="headerlink" title="跳点算法 JPS"></a>跳点算法 JPS</h1><ul>
<li><p><code>JPS</code>（<code>Jump Point Search</code>）对<code>A*</code>的搜索规则进行了改造，即不再是搜索某个点附近的点，而是想要用拐点（跳点）来代替</p>
</li>
<li><p><code>JPS</code>在寻路时只关心拐点，因此它以寻找拐点为主要目标，认为从起点到终点的路径可以由<code>N</code>个拐点组成，只能找到这<code>N</code>个拐点，就能将这些拐点连接起来形成一条完整的路径。于是，问题就变为如何识别拐点和如何寻找拐点</p>
</li>
<li><p>拐点在<code>JPS</code>中称为跳点。<code>JPS</code>算法是专门栅格地图定制的，所以它可以从<code>8</code>个方向寻找跳点，即前、后、左、右、左上、左下、右上、右下</p>
</li>
<li><p>跳点算法的一般步骤：</p>
</li>
</ul>
<ol>
<li>初始化：设置起点节点为当前节点，并将其加入封闭列表中。</li>
<li>循环：只要当前节点不是目标节点，就反复执行下列步骤：<ol>
<li>从当前节点的所有相邻节点中找到距离目标节点最近的节点。</li>
<li>将当前节点放入封闭列表中，并将找到的节点设置为当前节点。</li>
</ol>
</li>
<li>结束：如果当前节点是目标节点，则已经找到了最佳路径，可以通过跟踪节点的父节点来构建最佳路径。</li>
</ol>
<ul>
<li>优点</li>
</ul>
<ol>
<li>简单易实现，可以快速找到最佳路径</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>它可能不能找到最优解，因为它只考虑了距离目标节点最近的节点，而没有考虑其他因素</li>
<li>跳点算法对于图中的边权也不敏感，因此可能会导致结果不准确，因为它只考虑了距离目标节点最近的节点，而没有考虑其他因素。</li>
</ol>
<ul>
<li>下图为<code>A*</code>与<code>JPS</code>寻路路径的比较</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E5%9B%BE%E7%A4%BA.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/JPS%E5%9B%BE%E7%A4%BA.png?raw=true"></p>
<ul>
<li><code>JPS</code>和<code>A*</code>相比，优缺点：</li>
</ul>
<ol>
<li>使用<code>JPS</code>算法比<code>A</code>更快（绝大部分地图），内存占用更小，因为<code>Openlist</code>少了很多节点（最差的情况和<code>A*</code>一样，最差的是每个障碍都不连续，中间都有缝隙，这样所有地方都是跳点了）</li>
<li>只适用于网格节点类型，不支持<code>Navmesh</code>或者路径点寻路方式<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/A%E6%98%9F%E3%80%81JPS%E3%80%81JPS+.png?raw=true"></li>
</ol>
<h1 id="Navgation"><a href="#Navgation" class="headerlink" title="Navgation"></a>Navgation</h1><h2 id="导航网格"><a href="#导航网格" class="headerlink" title="导航网格"></a>导航网格</h2><ul>
<li>导航网格（即 <code>Navigation Mesh</code>，缩写为 <code>NavMesh</code>）是一种数据结构，用于描述游戏世界的可行走表面。**<code>NavMesh</code>为凸多边形**。原因是</li>
</ul>
<ol>
<li>如果是凹多边形，那么穿过该多边形时，可能会穿过不可导航区域。而凸多边形不会发生该情况</li>
<li>保证了相邻<code>NavMesh</code>之间只有一条公共边（<code>Portal</code>，过道）。而凹多边形则可能多条<code>Portal</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Navmesh%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"><h2 id="导航网格的路径和启发函数"><a href="#导航网格的路径和启发函数" class="headerlink" title="导航网格的路径和启发函数"></a>导航网格的路径和启发函数</h2></li>
</ol>
<ul>
<li>在<code>NaveMesh</code>上的路径如下图，第一个是将沿途<code>NavMesh</code>的中心点连接，形成路径；第二个是将<code>NavMesh</code>的公共边连接，形成路径（前两种方法通常会高估成本）；第三个是将沿途<code>NavMesh</code>的公共边的中点连接，形成路径；第四个是第二个和第三个的混合，会引入了太多要检查的点<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%9B%9B%E7%A7%8D%E5%9C%A8NavMesh%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84.png?raw=true"></li>
<li>对第三个方法加入启发函数。1）在允许任何移动角度的导航网格上，使用直线距离；2）使用进入当前节点的边的中点作为节点坐标计算点；3）<code>D</code>：沿任何方向移动单位距离的成本。优先选择代价小的路径<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/NavMesh%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/NavMesh%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></li>
</ul>
<h2 id="Path-Smoothing与Funnel-Algorithm"><a href="#Path-Smoothing与Funnel-Algorithm" class="headerlink" title="Path Smoothing与Funnel Algorithm"></a>Path Smoothing与Funnel Algorithm</h2><ul>
<li><code>Path Smoothing</code>（路径平滑）引入目的是使路径平滑，减少不必要的转弯。实现方法：<code>Funnel Algorithm</code>（漏斗算法）。1）漏斗的范围是可能的路径范围；2）必要时缩小漏斗以适应<code>Portal</code>。效果对比如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Path%20Smoothing%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"></li>
<li><code>Funnel Algorithm</code>示意图如下<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Funnel%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Funnel%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE2.png?raw=true"></li>
</ul>
<h2 id="生成导航网格"><a href="#生成导航网格" class="headerlink" title="生成导航网格"></a>生成导航网格</h2><ul>
<li><code>Voxelization</code>（体素化）。首先对通过体素化采样碰撞场景<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E4%BD%93%E7%B4%A0%E5%8C%96%E9%87%87%E6%A0%B7%E7%A2%B0%E6%92%9E%E5%9C%BA%E6%99%AF.png?raw=true"></li>
<li>计算每个体素到边界的距离,按代理半径标记边界体素以避免剪裁<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E4%BD%93%E7%B4%A0%E5%88%B0%E8%BE%B9%E7%95%8C%E7%9A%84%E8%B7%9D%E7%A6%BB.png?raw=true"></li>
<li>使用<code>Watershed Algorithm</code>（分水岭算法），淹没地形，当水池相遇时形成分水岭，从而进行网格分割<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95.png?raw=true"></li>
<li>分割相邻的体素区域，为多边形网格提供良好的基础<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%9B%B8%E9%82%BB%E7%9A%84%E4%BD%93%E7%B4%A0%E5%8C%BA%E5%9F%9F.png?raw=true"></li>
<li>区域在二维中没有重叠体素。下图为区域的俯视图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%BF%AF%E8%A7%86%E5%9B%BE.png?raw=true"></li>
<li>从分段区域生成导航网格<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E4%BB%8E%E5%88%86%E6%AE%B5%E5%8C%BA%E5%9F%9F%E7%94%9F%E6%88%90%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC.png?raw=true"></li>
</ul>
<h2 id="多边形标志（Polygon-Flag）"><a href="#多边形标志（Polygon-Flag）" class="headerlink" title="多边形标志（Polygon Flag）"></a>多边形标志（Polygon Flag）</h2><ul>
<li>可用于标记地形类型：平原、山脉、水域等。绘制颜色以添加用户定义的区域，从用户定义的区域生成的多边形具有特殊标志<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%A0%87%E5%BF%97.png?raw=true"></li>
</ul>
<h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><ul>
<li>快速响应动态对象，进行寻路的动态更新</li>
<li>避免重建整个导航网格</li>
<li><code>Tilesize</code>寻路和动态重建性能之间的权衡</li>
</ul>
<h2 id="网格外链接（Off-mesh-Link）"><a href="#网格外链接（Off-mesh-Link）" class="headerlink" title="网格外链接（Off-mesh Link）"></a>网格外链接（Off-mesh Link）</h2><ul>
<li><code>Off Mesh Link</code> 组件允许合并无法使用可行走表面来表示的导航捷径。例如，跳过沟渠或围栏，或在通过门之前打开门，全都可以描述为网格外链接<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Off-mesh%20Link%E7%BD%91%E6%A0%BC%E5%A4%96%E9%93%BE%E6%8E%A5.png?raw=true"></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示 | 菜鸟教程</a></li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to the A* Algorithm</a></li>
<li><a href="https://www.jianshu.com/p/74ca39e670ba">寻路算法小结</a></li>
<li><a href="https://paul.pub/a-star-algorithm/#id-%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0">路径规划之 A* 算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346666812">路径规划 | 图搜索算法：DFS、BFS、GBFS、Dijkstra、A*</a></li>
<li><a href="https://mp.weixin.qq.com/s/JiVx-tyXBt5ef53hjFZyHA">如何快速找到最优路线？深入理解游戏中寻路算法</a></li>
<li><a href="https://blog.csdn.net/hy592070616/article/details/121569933?spm=1001.2014.3001.5501">机器学习中的数学——距离定义（二）：曼哈顿距离（Manhattan Distance）</a></li>
<li><a href="https://docs.unity.cn/cn/2022.1/Manual/nav-InnerWorkings.html">Unity 手册 - 导航和寻路</a></li>
<li><a href="https://www.bilibili.com/video/BV19N4y1T7eU/?spm_id_from=333.788&vd_source=d2d44d4ce8893453aa70df7d2d5f6651">GAMES104现代游戏引擎 - 第十六节（上）：游戏引擎GamePlay玩法系统：基础AI</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/359393767">Navigation Mesh (NavMesh) 原理讲解（二） 当地块都是三角形时的路径优化</a></li>
<li><a href="https://blog.csdn.net/fengkeyleaf/article/details/118832924">几何寻路：漏斗算法（Funnel Algorithm）</a></li>
<li><a href="https://zerowidth.com/2013/a-visual-explanation-of-jump-point-search.html#try-it-out">A Visual Explanation of Jump Point Search</a></li>
<li><a href="https://www.jianshu.com/p/9335dddb04b4">JPS寻路算法</a></li>
<li>《Unity3D 高级编程：主程手记》</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>双缓冲模式</title>
    <url>/2023/04/04/%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>双缓冲模式：<strong>用序列的操作模拟瞬间或者同时发生的事情</strong></li>
<li>要点</li>
</ul>
<ol>
<li>一个双缓冲类封装了一个缓冲：一段可改变的状态。这个缓冲被增量的修改，但我们想要外部的代码将其视为单一的元素修改。为了实现这点，双缓冲类需保存两个缓冲的实例：下一缓存和当前缓存。</li>
<li>当信息从缓冲区中读取，我们总是去读取当前的缓冲区。当信息需要写到缓存，我们总是在下一缓冲区上操作。当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区则成为了下一个重用的缓冲区。</li>
<li>双缓冲模式常用来做帧缓冲区交换</li>
</ol>
<ul>
<li>使用场合，以下情况都满足时，使用这个模式很合适：</li>
</ul>
<ol>
<li>我们需要维护一些被增量修改的状态</li>
<li>在修改过程中，状态可能会被外部请求</li>
<li>我们想要防止请求状态的外部代码知道内部是如何工作的</li>
<li>我们想要读取状态，而且不想在修改的时候等待</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li>我们几乎可以在任何一个图形API中找到双缓冲模式的应用。如OpenGl中的swapBuffers() 函数, Direct3D中的“swap chains”,微软XNA框架的 endDraw() 方法</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FrameBuffer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[,] pixel = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1920</span>,<span class="number">1080</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1920</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1080</span>;++j)</span><br><span class="line">                pixel[i,j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScreen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> FrameBuffer frameBuffer1;</span><br><span class="line">    <span class="keyword">private</span> FrameBuffer frameBuffer2;</span><br><span class="line">    <span class="keyword">private</span> FrameBuffer current;</span><br><span class="line">    <span class="keyword">private</span> FrameBuffer next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyScreen</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        frameBuffer1 = <span class="keyword">new</span> FrameBuffer();</span><br><span class="line">        frameBuffer2 = <span class="keyword">new</span> FrameBuffer();</span><br><span class="line">        current = frameBuffer1;</span><br><span class="line">        next = frameBuffer2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        next.Draw(num);</span><br><span class="line">        Swap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Swap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = current;</span><br><span class="line">        current = next;</span><br><span class="line">        next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FrameBuffer <span class="title">GetCurrent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyScreen myScreen = <span class="keyword">new</span> MyScreen();</span><br><span class="line">        myScreen.Draw(<span class="number">1</span>);</span><br><span class="line">        myScreen.Draw(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/double-buffer.html">游戏编程模式 - 双缓冲模式</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2023/04/03/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>建造者模式：<strong>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</strong></li>
<li>建造者模式属于创建型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>建造者（Builder）：<strong>为创建一个产品对象的各个部件指定抽象接口</strong>，控制建造的细节。</li>
<li>具体建造者（ConcreteBuilder）：<strong>实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示</strong>，并提供一个检索产品的接口</li>
<li>指挥者（Director）：<strong>指挥并构造一个使用Builder接口的对象</strong>，控制建造的过程</li>
<li>产品（Product）：<strong>表示被构造的复杂对象</strong>。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口</li>
</ol>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>用户只需要指定要建造的类型就可以得到它们，而具体的建造过程和细节不需要知道</li>
<li>建造代码与表示相分离</li>
<li>建造过程由指挥者来控制，建造细节由一个抽象类来控制，对于实现建造细节的具体类来说，不会遗漏某一个步骤</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>产品必须有共同点，范围有限制</li>
<li>如内部变化复杂，会有很多的建造类</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li>
<li>游戏开发中的开发角色管理系统、管理所有角色</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Snake</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SnakeBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Snake snake;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnakeBuilder</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        snake = <span class="keyword">new</span> Snake();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildHead</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildBody</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Snake <span class="title">GetResult</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BigSnake</span> : <span class="title">SnakeBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildHead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;建造大头&quot;</span>);</span><br><span class="line">        snake.head = <span class="string">&quot;BigHead&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildBody</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;建造大身体&quot;</span>);</span><br><span class="line">        snake.body = <span class="string">&quot;BigBody&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Snake <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> snake;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Director</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Snake <span class="title">Construct</span>(<span class="params">SnakeBuilder snakeBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        snakeBuilder.BuildHead();</span><br><span class="line">        snakeBuilder.BuildBody();</span><br><span class="line">        <span class="keyword">return</span> snakeBuilder.GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        <span class="comment">//建造大头</span></span><br><span class="line">        <span class="comment">//建造大身体</span></span><br><span class="line">        Snake snake = director.Construct(<span class="keyword">new</span> BigSnake());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Builder%20Pattern">建造者模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346510567">C#设计模式笔记之建造者模式（Builder Pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/builder-pattern.html">建造者模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>子类沙盒</title>
    <url>/2023/04/03/%E5%AD%90%E7%B1%BB%E6%B2%99%E7%9B%92%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>子类沙盒：<strong>用一系列由基类提供的操作定义子类中的行为</strong></p>
</li>
<li><p>要点：基类定义抽象的沙箱方法和几个提供操作的实现方法，将他们设为protected，表明它们只为子类所使用。每个推导出的沙箱子类用提供的操作实现了沙箱方法</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>抽象基类：<strong>定义抽象的沙箱方法和提供所有子类操作的实现方法</strong></li>
<li>子类：<strong>子类继承抽象基类，实现自已的沙盒方法</strong></li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>你有一个能推导很多子类的基类。</li>
<li>基类可以提供子类需要的所有操作。</li>
<li>在子类中有行为重复，你想要更容易的在它们间分享代码。</li>
<li>你想要最小化子类和程序的其他部分的耦合</li>
</ol>
<ul>
<li>引申和参考：</li>
</ul>
<ol>
<li>当你使用上文中介绍到的更新模式时，你的更新函数通常也是沙箱方法。</li>
<li>这个模式与GOF模板方法正好相反。两种模式中，都使用了一系列受限操作实现方法。使用子类沙箱时，方法在推导类中，受限操作在基类中。使用模板方法时，基类有方法，而受限操作在推导类中。</li>
<li>你也可以认为这个模式是GOF外观模式的变形。外观模式将一系列不同系统藏在简化的API后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Power</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//沙盒方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供所有子类操作的实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;飞行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Swim</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fish</span> : <span class="title">Power</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Power</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//飞行</span></span><br><span class="line">        <span class="keyword">new</span> Bird().Activate();</span><br><span class="line">        <span class="comment">//游泳</span></span><br><span class="line">        <span class="keyword">new</span> Fish().Activate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/subclass-sandbox.html">游戏编程模式 - 子类沙箱</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#11">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/SubclassSandbox%20Pattern">子类沙盒模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>更新方法</title>
    <url>/2023/04/04/%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>更新方法：<strong>通过每次处理一帧的行为模拟一系列独立对象</strong></li>
<li>要点</li>
</ul>
<ol>
<li>更新方法模式：在游戏中保持游戏对象的集合。每个对象实现一个更新方法，以处理对象在一帧内的行为。每一帧中，游戏循环对集合中的每一个对象进行更新。</li>
<li>当离开每帧时，我们也许需要存储下状态，以备不时之需</li>
</ol>
<ul>
<li>使用场合，更新方法和游戏循环模式一般一起使用。更新方法适应以下情况：</li>
</ul>
<ol>
<li>游戏中有很多对象或系统需要同时运行。</li>
<li>每个对象的行为都与其他的大部分独立。</li>
<li>游戏中的对象需要随时间模拟。</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li>更新方法模式，以及游戏循环模式和组件模式，是构建游戏引擎核心的铁三角。</li>
<li>Unity引擎在多个类中使用了这个模式，包括MonoBehaviour。</li>
<li>微软的XNA框架在 Game 和 GameComponent 类中使用了这个模式。</li>
<li>当你关注在每帧中更新实体或组件的缓存性能时，数据局部性模式可以帮上忙</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyObject</span><br><span class="line">&#123;</span><br><span class="line">    void Update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Player : MyObject</span><br><span class="line">&#123;</span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;玩家存活&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Enemy : MyObject</span><br><span class="line">&#123;</span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;敌人存活&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GameController </span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;MyObject&gt; myObjects = new List&lt;MyObject&gt;();</span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach(var i in myObjects)</span><br><span class="line">            i.Update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void AddObject(MyObject myObject)</span><br><span class="line">    &#123;</span><br><span class="line">        myObjects.Add(myObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void RemoveObject(MyObject myObject)</span><br><span class="line">    &#123;</span><br><span class="line">        myObjects.Remove(myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        GameController gameController = new GameController();</span><br><span class="line">        gameController.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/update-method.html">游戏编程模式 - 更新方法</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>数据局部性</title>
    <url>/2023/04/04/%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>数据局部性：<strong>合理组织数据，充分使用CPU的缓存来加速内存读取</strong></li>
<li>要点</li>
</ul>
<ol>
<li>现代的CPU有缓存来加速内存读取，其可以更快地读取最近访问过的内存毗邻的内存。 基于这一点，我们通过保证处理的数据排列在连续内存上，以提高内存局部性，从而提高性能。</li>
<li>为了保证数据局部性，就要避免的缓存不命中。也许你需要牺牲一些宝贵的抽象。你越围绕数据局部性设计程序，就越放弃继承、接口和它们带来的好处。没有银弹，只有权衡</li>
</ol>
<ul>
<li>使用场合</li>
</ul>
<ol>
<li>使用数据局部性的第一准则是在遇到性能问题时使用。不要将其应用在代码库不经常使用的角落上。优化代码后其结果往往更加复杂，更加缺乏灵活性。</li>
<li>就本模式而言，还得<strong>确认你的性能问题确实由缓存不命中而引发的</strong>。如果代码是因为其他原因而缓慢，这个模式自然就不会有帮助。</li>
<li>简单的性能评估方法是手动添加指令，用计时器检查代码中两点间消耗的时间。而为了找到糟糕的缓存使用情况，知道缓存不命中有多少发生，又是在哪里发生的，则需要使用更加复杂的工具 ——profilers。</li>
<li>组件模式是为缓存优化的最常见例子。而任何需要接触很多数据的关键代码，考虑数据局部性都是很重要的</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AiComponent</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;AIComponent Update!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsComponent</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;PhysicsComponent Update!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxNum = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于大数组存储保证数据连续性</span></span><br><span class="line">    <span class="keyword">public</span> AiComponent[] aiComponents = <span class="keyword">new</span> AiComponent[MaxNum];</span><br><span class="line">    <span class="keyword">public</span> PhysicsComponent[] physicsComponents = <span class="keyword">new</span> PhysicsComponent[MaxNum];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            aiComponents[i] = <span class="keyword">new</span> AiComponent();</span><br><span class="line">            physicsComponents[i] = <span class="keyword">new</span> PhysicsComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            aiComponents[i].Update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            physicsComponents[i].Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game();</span><br><span class="line">        game.Start();</span><br><span class="line">        game.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/data-locality.html">游戏编程模式 - 数据局部性</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Data%20Locality%20Pattern">数据局部性模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>服务定位器</title>
    <url>/2023/04/04/%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>服务定位器：<strong>提供服务的全局接入点，而不必让用户和实现它的具体类耦合</strong></li>
<li>要点</li>
</ul>
<ol>
<li>服务定位模式：服务类定义了一堆操作的抽象接口。具体的服务提供者实现这个接口。 分离的服务定位器提供了通过查询合适的提供者，获取服务的方法，同时隐藏了提供者的具体细节和需要定位它的进程。</li>
<li>一般通过使用单例或者静态类来实现服务定位模式，提供服务的全局接入点。</li>
<li>服务定位模式可以看做是更加灵活，更加可配置的单例模式。如果用得好，它能以很小的运行时开销，换取很大的灵活性。相反，如果用得不好，它会带来单例模式的所有缺点以及更多的运行时开销。</li>
<li>使用服务定位器的核心难点是它将依赖，也就是两块代码之间的一点耦合，推迟到运行时再连接。这有了更大的灵活度，但是代价是更难在阅读代码时理解其依赖的是什么</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>服务类：<strong>定义一堆操作的抽象接口</strong></li>
<li>具体服务类：<strong>继承服务类，实现服务类的接口</strong></li>
<li>服务定位器管理类：<strong>提供全局接入点以访问具体服务类</strong></li>
</ol>
<ul>
<li>使用场合</li>
</ul>
<ol>
<li>服务定位模式在很多方面是单例模式的亲兄弟，在应用前应该考虑看看哪个更适合你的需求。</li>
<li>让大量内容在程序的各处都能被访问时，就是在制造混乱。对何时使用服务定位模式的最简单的建议就是：尽量少用。</li>
<li>与其使用全局机制让某些代码直接接触到它，不妨先考虑将对象传过来。因为这样可以明显地保持解耦，而且可以满足我们大部分的需求。当然，有时候不方便手动传入对象，也可以使用单例的方式</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li>Unity引擎在它的GetComponent()方法中使用了这个模式，协助组件模式的使用，方便随时获取到指定的组件。</li>
<li>Microsoft的 XNA框架将这个模式内嵌到它的核心类Game中。每个实例有一个GameServices对象，能够用来注册和定位任何类型的服务</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAudio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlaySound</span>(<span class="params"><span class="built_in">int</span> soundID</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopSound</span>(<span class="params"><span class="built_in">int</span> soundID</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopAllSounds</span>()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体服务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameAudio</span> : <span class="title">IAudio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlaySound</span>(<span class="params"><span class="built_in">int</span> soundID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;播放ID为<span class="subst">&#123;soundID&#125;</span>的音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopSound</span>(<span class="params"><span class="built_in">int</span> soundID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;停止播放ID为<span class="subst">&#123;soundID&#125;</span>的音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopAllSounds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;停止播放所有音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务定位器管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceLocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameAudio gameAudio = <span class="keyword">new</span> GameAudio();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameAudio <span class="title">GetGameAudio</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gameAudio;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//播放ID为0的音效</span></span><br><span class="line">        ServiceLocator.GetGameAudio().PlaySound(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//停止播放ID为0的音效</span></span><br><span class="line">        ServiceLocator.GetGameAudio().StopSound(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//停止播放所有音效</span></span><br><span class="line">        ServiceLocator.GetGameAudio().StopAllSounds();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/service-locator.html">游戏编程模式 - 服务定位器</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Service%20Locator%20Pattern">服务定位器模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2023/04/01/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>模板方法模式：<strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong></p>
</li>
<li><p>模板方法模式属于行为型模式</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>抽象类（AbstractClass）：在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法</li>
<li>具体子类（ConcreteClass）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/template.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用</li>
<li>在父类中定义一组算法，由它的子类来实现细节的处理，在子类实现详细的处理算法时，并不会改变算法中步骤的执行次序</li>
<li>封装不变部分，扩展可变部分</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AtHome</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomthing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GoHome();</span><br><span class="line">        Behavior();</span><br><span class="line">        LeaveHome();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Behavior</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoHome</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;回到家了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LeaveHome</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;离开家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//具体模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">AtHome</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Behavior</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;写作业&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Worker</span> : <span class="title">AtHome</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Behavior</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//回到家了 写作业 离开家</span></span><br><span class="line">        student.DoSomthing();</span><br><span class="line"></span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">//回到家了 做饭 离开家</span></span><br><span class="line">        worker.DoSomthing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Template%20Method%20Pattern">模板方法模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346510883">C#设计模式笔记之模板方法模式（Template Method pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/template-pattern.html">模板模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>对象池</title>
    <url>/2022/10/08/%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>对象池旨在通过事先实例化许多对象，然后激活&#x2F;停用对象，并在需要时<strong>重用对象来减轻实例化&#x2F;销毁许多对象的性能损失</strong></li>
</ul>
<h1 id="用SO与工厂模式实现对象池"><a href="#用SO与工厂模式实现对象池" class="headerlink" title="用SO与工厂模式实现对象池"></a>用SO与工厂模式实现对象池</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li>获取物品需要从对象池中获取，而对象池的物品从工厂模式中获取</li>
<li>工厂模式的接口<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">Create</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>封装工厂模式<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FactorySO</span>&lt;<span class="title">T</span>&gt; : <span class="title">ScriptableObject</span>, <span class="title">IFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">Create</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>生成某物体的工厂模式的<code>ScriptableObject</code></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;CoinFactory&quot;</span>, menuName = <span class="string">&quot;Factory/CoinFactory&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoinFactorySO</span> : <span class="title">FactorySO</span>&lt;<span class="title">Transform</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform prefab;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Transform <span class="title">Create</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><ul>
<li>对象池的接口<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPool</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//预热</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prewarm</span>(<span class="params"><span class="built_in">int</span> num</span>)</span>;</span><br><span class="line">    <span class="comment">//供应</span></span><br><span class="line">    <span class="function">T <span class="title">Request</span>()</span>;</span><br><span class="line">    <span class="comment">//回收</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T member</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>封装对象池<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PoolSO</span>&lt;<span class="title">T</span>&gt; : <span class="title">ScriptableObject</span>, <span class="title">IPool</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//栈作为容器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">readonly</span> Stack&lt;T&gt; Available = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IFactory&lt;T&gt; Factory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">bool</span> HasBeenPrewarmed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> T <span class="title">Create</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Factory.Create();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span> isPoolHaveMaxSize;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">int</span> PoolMaxSize;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prewarm</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HasBeenPrewarmed)</span><br><span class="line">		&#123;</span><br><span class="line">			Debug.LogWarning(<span class="string">$&quot;Pool <span class="subst">&#123;name&#125;</span> has already been prewarmed.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="built_in">int</span> nums = num;</span><br><span class="line">        <span class="keyword">if</span>(isPoolHaveMaxSize &amp;&amp; PoolMaxSize&lt;num)</span><br><span class="line">		&#123;</span><br><span class="line">			Debug.LogWarning(<span class="string">$&quot;Pool <span class="subst">&#123;name&#125;</span> Initialize greater than PoolMaxSize.&quot;</span>);</span><br><span class="line">			nums = PoolMaxSize;</span><br><span class="line">		&#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Available.Push(Create());</span><br><span class="line">		&#125;</span><br><span class="line">		HasBeenPrewarmed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> T <span class="title">Request</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Available.Count &gt; <span class="number">0</span> ? Available.Pop() : Create();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T member</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Available.Push(member);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		Available.Clear();</span><br><span class="line">		HasBeenPrewarmed = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>约束</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ComponentPoolSO</span>&lt;<span class="title">T</span>&gt; : <span class="title">PoolSO</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Transform _poolRoot;</span><br><span class="line">	<span class="keyword">private</span> Transform PoolRoot</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">get</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (_poolRoot == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				_poolRoot = <span class="keyword">new</span> GameObject(name).transform;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> _poolRoot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> T <span class="title">Request</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		T member = <span class="keyword">base</span>.Request();</span><br><span class="line">		member.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span> member;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T member</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPoolHaveMaxSize &amp;&amp; Available.Count&gt;=PoolMaxSize)</span><br><span class="line">		&#123;</span><br><span class="line">			Destroy(member.gameObject);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			member.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">base</span>.Return(member);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> T <span class="title">Create</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		T newMember = <span class="keyword">base</span>.Create();</span><br><span class="line">		newMember.transform.SetParent(PoolRoot.transform);</span><br><span class="line">		newMember.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> newMember;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">base</span>.OnDisable();</span><br><span class="line">		<span class="keyword">if</span> (_poolRoot != <span class="literal">null</span>)</span><br><span class="line">			Destroy(_poolRoot.gameObject); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>组合</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName =<span class="string">&quot;CoinPool&quot;</span>,menuName =<span class="string">&quot;Pool/CoinPool&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoinPoolSO</span> : <span class="title">ComponentPoolSO</span>&lt;<span class="title">Transform</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> CoinFactorySO factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> IFactory&lt;Transform&gt; Factory </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; factory <span class="keyword">as</span> IFactory&lt;Transform&gt;;</span><br><span class="line">        <span class="keyword">set</span> =&gt; factory = <span class="keyword">value</span> <span class="keyword">as</span> CoinFactorySO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试脚本</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CoinPoolSO coinpoolso;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">init</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinpoolso.Prewarm(<span class="keyword">init</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            coinpoolso.Request();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Unity内置对象池-ObjectPool"><a href="#Unity内置对象池-ObjectPool" class="headerlink" title="Unity内置对象池 - ObjectPool"></a>Unity内置对象池 - ObjectPool</h1><ul>
<li><p><code>ObjectPool</code>基于栈实现</p>
</li>
<li><p>注意不要更改资产，实例化资产与激活、禁用、销毁对象要注意</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2></li>
<li><p><code>GamePool</code>脚本用于存放<code>ObjectPool</code>并初始化</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GoController prefab;</span><br><span class="line">    <span class="keyword">public</span> ObjectPool&lt;GoController&gt; pool;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//5. 当实例返回到池时，将执行集合检查。如果实例已在池中，则将引发异常。集合检查仅在编辑器中执行</span></span><br><span class="line">        <span class="comment">//6. 创建堆栈的默认容量</span></span><br><span class="line">        <span class="comment">//7. 池的最大大小。 当池达到最大大小时，返回到池中的任何其他实例将被忽略并可以被垃圾收集。 这可用于防止池增长到非常大的大小。</span></span><br><span class="line">        pool = <span class="keyword">new</span> ObjectPool&lt;GoController&gt;(createFunc, actionOnGet, actionOnRelease, actionOnDestroy, <span class="literal">true</span>, <span class="number">10</span>, <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 用于在池为空时创建新实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GoController <span class="title">createFunc</span>()</span> =&gt; Instantiate(prefab);</span><br><span class="line">    <span class="comment">//2. 从池中获取实例时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">actionOnGet</span>(<span class="params">GoController prefab</span>)</span> =&gt; prefab.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3. 当实例返回到池时调用。这可用于清理或禁用实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">actionOnRelease</span>(<span class="params">GoController prefab</span>)</span> =&gt; prefab.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//4. 当由于池达到最大大小而无法将元素返回到池时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">actionOnDestroy</span>(<span class="params">GoController prefab</span>)</span> =&gt; Destroy(prefab.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GameController</code>脚本用于控制对应游戏物体的生成</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GamePool gamePool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从池中获取一个实例。 如果池为空，则将创建一个新实例</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            gamePool.pool.Get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GoController</code>脚本挂载到对应游戏对象上，控制回收</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GoController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GamePool gamePool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeSum = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(gamePool==<span class="literal">null</span>)</span><br><span class="line">            gamePool = GameObject.Find(<span class="string">&quot;EGameObject&quot;</span>).GetComponent&lt;GamePool&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(timeSum!=<span class="number">0f</span>)</span><br><span class="line">            timeSum = <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">if</span>(transform.position!=Vector3.zero)</span><br><span class="line">            transform.position = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//激活1s后，将实例返回到池中</span></span><br><span class="line">        <span class="keyword">if</span>(timeSum&gt;<span class="number">1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gamePool.pool.Release(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            timeSum += Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通用版本"><a href="#通用版本" class="headerlink" title="通用版本"></a>通用版本</h2></li>
<li><p><code>BasePool&lt;T&gt;</code>为泛型通用对象池</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BasePool</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> T prefab;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> defaultSize = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxSize = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    ObjectPool&lt;T&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ActiveCount =&gt; pool.CountActive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> InactiveCount =&gt; pool.CountInactive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TotalCount =&gt; pool.CountAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">bool</span> collectionCheck = <span class="literal">true</span></span>)</span> =&gt; </span><br><span class="line">        pool = <span class="keyword">new</span> ObjectPool&lt;T&gt;(OnCreatePoolItem, OnGetPoolItem, OnReleasePoolItem, OnDestroyPoolItem, collectionCheck, defaultSize, maxSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">OnCreatePoolItem</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">T obj</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">T obj</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroyPoolItem</span>(<span class="params">T obj</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>()</span> =&gt; pool.Get();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">T obj</span>)</span> =&gt; pool.Release(obj);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span> =&gt; pool.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建对象池</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GoControllerPool</span> : <span class="title">BasePool</span>&lt;<span class="title">GoController</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> GoController <span class="title">OnCreatePoolItem</span>()</span> =&gt; Instantiate(prefab);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">GoController obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">GoController obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">GoController obj</span>)</span> =&gt; Destroy(prefab.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/UnityTechnologies/open-project-1/wiki/Object-pooling">UnityTechnologies&#x2F;open-project-1 - Object Pooling</a></li>
<li><a href="https://learn.unity.com/tutorial/dui-xiang-chi-jian-jie-2019-3">Unity Learn - 对象池简介</a></li>
<li><a href="https://liamederzeel.com/a-generic-object-pool-for-unity3d/">A Generic Object Pool for Unity3D</a></li>
<li><a href="https://docs.unity.cn/cn/2022.1/ScriptReference/Pool.ObjectPool_1.html">Unity - ObjectPool</a></li>
<li><a href="https://github.com/AtCloudStudio/UnityObjectPoolTutorial">Github - UnityObjectPoolTutorial</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>游戏循环模式</title>
    <url>/2023/04/04/%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>游戏循环模式：<strong>将游戏的进行和玩家的输入解耦，和处理器速度解耦</strong></li>
<li>要点</li>
</ul>
<ol>
<li>游戏循环模式：游戏循环在游戏过程中持续运转。每循环一次，它非阻塞地处理用户的输入，更新游戏状态，并渲染游戏。它跟踪流逝的时间并控制游戏的速率。</li>
<li>游戏循环将游戏的处理过程和玩家输入解耦，和处理器速度解耦，实现用户输入和处理器速度在游戏行进时间上的分离。</li>
<li>游戏循环也许需要与平台的事件循环相协调。如果在操作系统的高层或有图形UI和内建事件循环的平台上构建游戏，那就有了两个应用循环在同时运作，需要对他们进行相应的协调</li>
</ol>
<ul>
<li>使用场合</li>
</ul>
<ol>
<li>任何游戏或游戏引擎都拥有自己的游戏循环，因为游戏循环是游戏运行的主心骨。</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGameLoop</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">float</span> updateTime = <span class="number">0.5F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnterGameLoop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> previous = Time.realtimeSinceStartup; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前时间</span></span><br><span class="line">            <span class="built_in">float</span> current = Time.realtimeSinceStartup;</span><br><span class="line">            <span class="comment">//消逝的时间</span></span><br><span class="line">            <span class="built_in">float</span> elapsed = current - previous;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(elapsed&gt;=updateTime)</span><br><span class="line">            &#123;</span><br><span class="line">                InputHandle();</span><br><span class="line">                Update();</span><br><span class="line">                Render();</span><br><span class="line">                previous = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InputHandle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.K))</span><br><span class="line">            Debug.Log(<span class="string">&quot;按下K键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Render</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Render&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyGameLoop myGameLoop = <span class="keyword">new</span> MyGameLoop();</span><br><span class="line">        <span class="comment">//如果执行，主线程会被卡死</span></span><br><span class="line">        <span class="comment">//myGameLoop.EnterGameLoop();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/game-loop.html">游戏编程模式 - 游戏循环</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#11">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Game%20Loop%20Pattern">游戏循环模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2022/06/20/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>状态模式：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类</p>
</li>
<li><p>状态模式属于行为型模式</p>
</li>
<li><p>主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为</p>
</li>
<li><p>何时使用：代码中包含大量与对象状态有关的条件语句</p>
</li>
<li><p>如何解决：将各种具体的状态类抽象出来</p>
</li>
<li><p>主要包含以下角色：</p>
</li>
</ul>
<ol>
<li>上下文（Context）：维护一个抽象状态类State的实例，这个实例定义了当前状态。</li>
<li>抽象状态：定义一个接口，用于封装与上下文的特定状态关联的行为</li>
<li>具体状态：现抽象状态定义的接口。每一个子类实现一个与Context的一个状态相关的行为。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;GreenState&quot;</span>);</span><br><span class="line">        context.state = <span class="keyword">new</span> GreenState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreenState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;BlueState&quot;</span>);</span><br><span class="line">        context.state = <span class="keyword">new</span> BlueState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlueState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;RedState&quot;</span>);</span><br><span class="line">        context.state = <span class="keyword">new</span> RedState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文。Context</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">State state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置初始状态为RedState</span></span><br><span class="line">    <span class="keyword">public</span> Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> RedState());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//响应请求改变状态</span></span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>结构如下图:创建一个 <code>State</code> 接口和实现了 <code>State</code> 接口的实体状态类。<code>Context</code> 是一个带有某个状态的类。<code>StatePatternDemo</code>，我们的演示类使用 <code>Context</code> 和状态对象来演示 <code>Context</code> 在状态改变时的行为变化</li>
</ul>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/state.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>封装了转换规则</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>状态模式的使用必然会增加系统类和对象的个数</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码</li>
</ol>
<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><ul>
<li>构成</li>
</ul>
<ol>
<li>状态基类（<code>FSMstate</code>）：此类负责处理一个状态的周期，包括进入状态前、状态中、离开状态前、转换条件的增删、根据转换条件获得状态ID。所有状态都要继承这个状态基类</li>
<li>状态管理类（<code>FSMsystem</code>）：包括添加状态、删除状态、状态转换。用来管理所有的状态（状态的添加、删除、切换、更新等）</li>
<li>具体状态类：具体状态类都继承状态基类，负责状态的具体实现</li>
</ol>
<hr>
<p>假如怪物有以下状态，巡逻、追逐、攻击状态。状态切换条件有看到玩家、看不到玩家、进入攻击范围、离开攻击范围，编写一个有限状态机</p>
<ul>
<li><p>新建脚本，编写状态基类（<code>FSMstate</code>），代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//状态ID</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StateID</span><br><span class="line">&#123;</span><br><span class="line">    NoneStateID,</span><br><span class="line">    <span class="comment">//巡逻状态</span></span><br><span class="line">    Parol, </span><br><span class="line">    <span class="comment">//追逐状态     </span></span><br><span class="line">    Chase,     </span><br><span class="line">    <span class="comment">//攻击状态</span></span><br><span class="line">    Attack,     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态切换条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Transition</span><br><span class="line">&#123;</span><br><span class="line">    NoneTransition,</span><br><span class="line">    <span class="comment">//看到玩家</span></span><br><span class="line">    SeePlayer,  </span><br><span class="line">    <span class="comment">//看不到玩家</span></span><br><span class="line">    LosePlayer, </span><br><span class="line">    <span class="comment">//进入攻击范围</span></span><br><span class="line">    Enter,      </span><br><span class="line">    <span class="comment">//离开攻击范围</span></span><br><span class="line">    Leave,      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FSMstate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//状态对应的ID</span></span><br><span class="line">    <span class="keyword">protected</span> StateID stateID;</span><br><span class="line">    <span class="keyword">public</span> StateID ID &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> stateID; &#125; &#125;</span><br><span class="line">    <span class="comment">//存储转换条件和状态的ID</span></span><br><span class="line">    <span class="keyword">protected</span> Dictionary&lt;Transition, StateID&gt; Transition_StateIDDic = <span class="keyword">new</span> Dictionary&lt;Transition, StateID&gt;();</span><br><span class="line">    <span class="comment">//管理状态对象（因为要状态更新需要通过FSMsystem去管理实现的，所以需要一个管理对象）</span></span><br><span class="line">    <span class="keyword">protected</span> FSMsystem fsmSystem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FSMstate</span>(<span class="params">FSMsystem fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.fsmSystem = fsm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加转换条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTransition</span>(<span class="params">Transition trans, StateID id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (trans == Transition.NoneTransition)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;添加的转换条件不能为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id == StateID.NoneStateID)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;添加的状态ID不能为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Transition_StateIDDic.ContainsKey(trans))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;添加转换条件的时候，&quot;</span> + trans + <span class="string">&quot;已经存在于Transition_StateIDDic中&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Transition_StateIDDic.Add(trans, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除转换条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteTransition</span>(<span class="params">Transition trans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (trans == Transition.NoneTransition)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;删除的转换条件不能为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Transition_StateIDDic.ContainsKey(trans))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;删除转换条件的时候，&quot;</span> + trans + <span class="string">&quot;不存在于Transition_StateIDDic中&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Transition_StateIDDic.Remove(trans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据转换条件获得状态ID</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StateID <span class="title">GetStateID</span>(<span class="params">Transition trans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Transition_StateIDDic.ContainsKey(trans))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Transition_StateIDDic[trans];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StateID.NoneStateID;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换到此状态前要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoBeforeEnterAcion</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//离开此状态前要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoAfterLevAction</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//处在本状态时要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">CurrStateAction</span>()</span>;</span><br><span class="line">    <span class="comment">//切换到下一状态需要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">NextStateAction</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建脚本，编写状态管理类（<code>FSMsystem</code>），代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//状态处理类（添加，删除，切换，更新等管理所有状态）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FSMsystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//保存状态ID以及ID对应的状态</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;StateID, FSMstate&gt; StateDic = <span class="keyword">new</span> Dictionary&lt;StateID, FSMstate&gt;();</span><br><span class="line">    <span class="comment">//当前处于的状态ID</span></span><br><span class="line">    <span class="keyword">private</span> StateID _CurrentStateID;</span><br><span class="line">    <span class="comment">//当前处于的状态</span></span><br><span class="line">    <span class="keyword">private</span> FSMstate _CurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddState</span>(<span class="params">FSMstate state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;添加的状态&quot;</span> + state + <span class="string">&quot;不能为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_CurrentState == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _CurrentState = state;</span><br><span class="line">            _CurrentStateID = state.ID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StateDic.ContainsKey(state.ID))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;状态机 &quot;</span> + state.ID + <span class="string">&quot;已经存在，无法添加&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StateDic.Add(state.ID, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteState</span>(<span class="params">StateID stateID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stateID == StateID.NoneStateID)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;无法删除Null的状态&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StateDic.ContainsKey(stateID))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;无法删除不存在的状态：&quot;</span> + stateID);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StateDic.Remove(stateID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换（状态的切换是根据转换条件的变化）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformTranstion</span>(<span class="params">Transition trans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (trans == Transition.NoneTransition)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;无法执行NULL的转换条件&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StateID stateId = _CurrentState.GetStateID(trans);</span><br><span class="line">        <span class="keyword">if</span> (stateId == StateID.NoneStateID)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;要转换的状态ID为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StateDic.ContainsKey(stateId))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;状态机中没找到状态ID  &quot;</span> + stateId + <span class="string">&quot;  无法转换状态&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据状态ID获取要转换的状态</span></span><br><span class="line">        FSMstate state = StateDic[stateId];</span><br><span class="line">        <span class="comment">//执行离开上一状态逻辑</span></span><br><span class="line">        _CurrentState.DoAfterLevAction();</span><br><span class="line">        <span class="comment">//更新当前状态</span></span><br><span class="line">        _CurrentState = state;</span><br><span class="line">        <span class="comment">//更新当前状态ID</span></span><br><span class="line">        _CurrentStateID = stateId;</span><br><span class="line">        <span class="comment">//执行进入当前状态前要执行的逻辑</span></span><br><span class="line">        _CurrentState.DoBeforeEnterAcion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新当前状态行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _CurrentState.CurrStateAction();</span><br><span class="line">        _CurrentState.NextStateAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建脚本，用于实现各个状态，所有状态都要继承状态基类。代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//怪物巡逻状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolState</span> : <span class="title">FSMstate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化巡逻状态数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PatrolState</span>(<span class="params">FSMsystem fsm</span>) : <span class="title">base</span>(<span class="params">fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stateID = StateID.Parol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前状态执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CurrStateAction</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//切换到下一状态要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">NextStateAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下A键从巡逻状态切换到追逐状态</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            fsmSystem.PerformTranstion(Transition.SeePlayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//追逐状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChaseState</span> : <span class="title">FSMstate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化追逐状态数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChaseState</span>(<span class="params">FSMsystem fsm</span>) : <span class="title">base</span>(<span class="params">fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stateID = StateID.Chase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前状态执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CurrStateAction</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//切换到下一状态要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">NextStateAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下S键从追逐状态切换到攻击状态</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.S))</span><br><span class="line">        &#123;</span><br><span class="line">            fsmSystem.PerformTranstion(Transition.Enter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按下D键从追逐状态切换到巡逻</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line">            fsmSystem.PerformTranstion(Transition.LosePlayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//攻击状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AttackState</span> : <span class="title">FSMstate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化攻击状态数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttackState</span>(<span class="params">FSMsystem fsm</span>) : <span class="title">base</span>(<span class="params">fsm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stateID = StateID.Attack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换到此状态前要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DoBeforeEnterAcion</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//当前状态执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CurrStateAction</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//切换到下一状态要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">NextStateAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下F键从攻击状态切换到追逐状态</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.F))</span><br><span class="line">        &#123;</span><br><span class="line">            fsmSystem.PerformTranstion(Transition.Leave);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开此状态前要执行的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DoAfterLevAction</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>新建名为<code>EnemyFSM</code>的脚本挂在敌人的预制体下，代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyFSM</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在EnemyFSM类中，实例化FSMSystem对象，添加巡逻、追逐、攻击状态，还有之间的转换条件</span></span><br><span class="line">    <span class="keyword">private</span> FSMsystem fsmsystem; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态机</span></span><br><span class="line">        InitFsm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查更新状态</span></span><br><span class="line">        fsmsystem.UpdateState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitFsm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        fsmsystem = <span class="keyword">new</span> FSMsystem();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建巡逻类。添加转换条件，看到玩家就切换状态为追逐</span></span><br><span class="line">        FSMstate PatrolState = <span class="keyword">new</span> PatrolState(fsmsystem);</span><br><span class="line">        PatrolState.AddTransition(Transition.SeePlayer, StateID.Chase);     </span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建追逐类。添加转换条件，看不到玩家就切换状态为巡逻；进入攻击范围就切换状态为攻击</span></span><br><span class="line">        FSMstate ChaseState = <span class="keyword">new</span> ChaseState(fsmsystem);</span><br><span class="line">        ChaseState.AddTransition(Transition.LosePlayer, StateID.Parol);     </span><br><span class="line">        ChaseState.AddTransition(Transition.Enter, StateID.Attack);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新建攻击类。添加转换条件，离开攻击范围就切换状态为追逐</span></span><br><span class="line">        FSMstate AttackState = <span class="keyword">new</span> AttackState(fsmsystem);</span><br><span class="line">        AttackState.AddTransition(Transition.Leave, StateID.Chase);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加状态，第一个状态为初始状态。三个状态分别为巡逻、追逐、攻击</span></span><br><span class="line">        fsmsystem.AddState(PatrolState);        </span><br><span class="line">        fsmsystem.AddState(ChaseState);         </span><br><span class="line">        fsmsystem.AddState(AttackState);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://gpp.tkchu.me/state.html">游戏编程模式 - 状态模式</a></li>
<li><a href="https://www.runoob.com/design-pattern/state-pattern.html">状态模式 | 菜鸟教程</a></li>
<li><a href="https://blog.csdn.net/weixin_43839583/article/details/105501884">Unity FSM(有限状态机)</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/State%20Pattern">状态模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346508704">C#设计模式笔记之状态模式（State Pattern）</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/10/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>工厂模式属于创建型模式</p>
</li>
<li><p>工厂模式有三种：简单工厂模式、工厂方法模式和抽象工厂模式</p>
</li>
<li><p>工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</p>
</li>
<li><p>使用场景：明确地计划不同条件下创建不同实例时</p>
</li>
<li><p>优点</p>
</li>
</ul>
<ol>
<li>可以使代码结构清晰，有效地封装变化</li>
<li>对调用者屏蔽具体的产品类</li>
<li>降低耦合度</li>
</ol>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><ul>
<li>该模式对对象创建管理方式最为简单，<strong>将一个具体类的实例化交给一个静态工厂方法来执行</strong>，因为其<strong>仅简单地对不同类对象的创建进行了一层封装</strong>。该模式通过向工厂传递类型来指定要创建的对象</li>
<li>主要有如下：</li>
</ul>
<ol>
<li>工厂类</li>
<li>抽象产品</li>
<li>具体产品</li>
</ol>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>实现简单</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>违反高内聚责任分配原则</li>
</ol>
<ul>
<li>其<code>UML</code>类图如下：</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Product1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XiaoMi</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Product2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IPhone</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Factory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">MakePhone</span>(<span class="params"><span class="built_in">string</span> phoneName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(phoneName==<span class="string">&quot;XiaoMi&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XiaoMi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(phoneName==<span class="string">&quot;IPhone&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    XiaoMi xiaoMi = <span class="keyword">new</span> Factory().MakePhone(<span class="string">&quot;XiaoMi&quot;</span>) <span class="keyword">as</span> XiaoMi;</span><br><span class="line">    IPhone iPhone = <span class="keyword">new</span> Factory().MakePhone(<span class="string">&quot;IPhone&quot;</span>) <span class="keyword">as</span> IPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><ul>
<li>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式<strong>将生成具体产品的任务分发给具体的产品工厂</strong>，其<code>UML</code>类图如下。即<strong>定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂</strong>。这样不用通过指定类型来创建对象了</li>
<li>主要如下：</li>
</ul>
<ol>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Product1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XiaoMi</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Product2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IPhone</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">MakePhone</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteFactory1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XiaoMiFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">MakePhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteFactory2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IPhoneFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">MakePhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    XiaoMi xiaoMi = <span class="keyword">new</span> XiaoMiFactory().MakePhone() <span class="keyword">as</span> XiaoMi;</span><br><span class="line">    IPhone iphone = <span class="keyword">new</span> IPhoneFactory().MakePhone() <span class="keyword">as</span> IPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><ul>
<li>抽象工厂模式<strong>通过在<code>AbstarctFactory</code>中增加创建产品的接口，并在具体子工厂中实现新加产品的创建</strong>，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ol>
<ul>
<li>其<code>UML</code>类图如下：</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractPhone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractPC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PC</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MiPhone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XiaoMi</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iphone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IPhone</span>: <span class="title">Phone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MiPC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MiPC</span>: <span class="title">PC</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MAC</span>: <span class="title">PC</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractFactory</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">MakePhone</span>()</span>;</span><br><span class="line">    <span class="function">PC <span class="title">MakePC</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XiaoMiFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XiaoMiFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">MakePhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">MakePC</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AppleFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppleFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">MakePhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">MakePC</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MAC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    XiaoMi xiaoMi = <span class="keyword">new</span> XiaoMiFactory().MakePhone() <span class="keyword">as</span> XiaoMi;</span><br><span class="line">    IPhone iphone = <span class="keyword">new</span> AppleFactory().MakePhone() <span class="keyword">as</span> IPhone;</span><br><span class="line"></span><br><span class="line">    MiPC miPC = <span class="keyword">new</span> XiaoMiFactory().MakePC() <span class="keyword">as</span> MiPC;</span><br><span class="line">    MAC mac = <span class="keyword">new</span> AppleFactory().MakePC() <span class="keyword">as</span> MAC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Unity的实现"><a href="#Unity的实现" class="headerlink" title="Unity的实现"></a>Unity的实现</h1><ul>
<li>将工厂做成<code>ScriptableObject</code>来实现，不同的产品生成不同的<code>ScriptableObject</code>，哪些脚本需要用到工厂模式，声明一个变量，获取即可调用</li>
<li>如下是一个预制体的工厂模式</li>
<li><code>IFactory&lt;T&gt;</code>定义子类的行为，即创建类型的方法。子类决定生成的类型</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">GetCreate</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FactorySO&lt;T&gt;</code>继承<code>ScriptableObject</code>、<code>IFactory&lt;T&gt;</code>。主要目的是继承<code>ScriptableObject</code></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FactorySO</span>&lt;<span class="title">T</span>&gt; : <span class="title">ScriptableObject</span>, <span class="title">IFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">GetCreate</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成具体物体的实体类。创建<code>ScriptableObject</code>后，将需要生成物体的预制体挂载即可<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;CoinFactory&quot;</span>, menuName = <span class="string">&quot;Factory/CoinFactory&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoinFactorySO</span> : <span class="title">FactorySO</span>&lt;<span class="title">GameObject</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Prefab;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> GameObject <span class="title">GetCreate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Instantiate(Prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FactorySOTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CoinFactorySO coinfactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            coinfactory.GetCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/UnityTechnologies/open-project-1/wiki/Factory">UnityTechnologies &#x2F; open-project-1 - Factory</a></li>
<li><a href="https://www.cnblogs.com/yssjun/p/11102162.html">设计模式之工厂模式（factory pattern）</a></li>
<li><a href="https://www.zhihu.com/column/c_1325411823555391488">C# 设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>空间分区</title>
    <url>/2023/04/04/%E7%A9%BA%E9%97%B4%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>空间分区：<strong>将对象根据它们的位置存储在数据结构中，来高效地定位对象</strong></li>
<li>要点</li>
</ul>
<ol>
<li>对于一系列对象，每个对象都有空间上的位置。将它们存储在根据位置组织对象的空间数据结构中，让我们有效查询在某处或者附近的对象。当对象的位置改变时，更新空间数据结构，这样它可以继续找到对象。</li>
<li>最简单的空间分区：固定网格。想象某即时战略类游戏，一改在单独的数组中存储我们的游戏对象的常规思维，我们将它们存到网格的格子中。每个格子存储一组单位，它们的位置在格子的边界内部。当我们处理战斗时，一般只需考虑在同一格子或相邻格子中的单位，而不是将每个游戏中的单位与其他所有单位比较，这样就大大节约了计算量</li>
</ol>
<ul>
<li>使用场合</li>
</ul>
<ol>
<li>空间分区模式在需要大量存储活跃、移动的游戏物体，和静态的美术模型的游戏中比较常用。因为复杂的游戏中不同的内容有不同的空间划分。</li>
<li>这个模式的基本适用场景是你有一系列有位置的对象，当做了大量通过位置寻找对象的查询而导致性能下降的时候。</li>
<li>空间分区的存在是为了将O(n)或者O(n²) 的操作降到更加可控的数量级。你拥有的对象越多，此模式就越好用。相反的，如果n足够小，也许就不需要使用此模式</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li><p>了解了空间分区模式，下一步应该是学习一下常见的结构。常见的有：Grid、Quadtree、BSP、k-d tree、Bounding volume hierarchy</p>
</li>
<li><p>每种空间划分数据结构基本上都是将一维数据结构扩展成更高维度的数据结构。知道它的直系子孙有助于分辨它是否适合解决当前的问题：网格其实是持续的桶排序、BSP，k-d tree，和层次包围盒是线性搜索树、四叉树和八叉树是多叉树。</p>
</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网格类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Grid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Grid&gt; neighborGrids;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grid</span>(<span class="params"><span class="built_in">string</span> _name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        neighborGrids = <span class="keyword">new</span> List&lt;Grid&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNeighborGrid</span>(<span class="params">Grid neighborGrid</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        neighborGrids.Add(neighborGrid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Grid&gt; <span class="title">GetNeighborGrids</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> neighborGrids;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网格管理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GridController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Grid&gt; grids = <span class="keyword">new</span> List&lt;Grid&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddGrid</span>(<span class="params">Grid grid</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        grids.Add(grid);</span><br><span class="line">        <span class="keyword">if</span>(grids.Count&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grids[grids.Count - <span class="number">2</span>].AddNeighborGrid(grid);</span><br><span class="line">            grid.AddNeighborGrid(grids[grids.Count - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Grid&gt; <span class="title">GetIndexNeighborGrids</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> grids[index].GetNeighborGrids();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GridController gridController = <span class="keyword">new</span> GridController();</span><br><span class="line">        gridController.AddGrid(<span class="keyword">new</span> Grid(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        gridController.AddGrid(<span class="keyword">new</span> Grid(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        gridController.AddGrid(<span class="keyword">new</span> Grid(<span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第0个元素的邻居网格</span></span><br><span class="line">        <span class="comment">//B</span></span><br><span class="line">        <span class="comment">//————————————————————————</span></span><br><span class="line">        <span class="comment">//第1个元素的邻居网格</span></span><br><span class="line">        <span class="comment">//A</span></span><br><span class="line">        <span class="comment">//C</span></span><br><span class="line">        <span class="comment">//————————————————————————</span></span><br><span class="line">        <span class="comment">//第2个元素的邻居网格</span></span><br><span class="line">        <span class="comment">//B</span></span><br><span class="line">        <span class="comment">//————————————————————————</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;第<span class="subst">&#123;i&#125;</span>个元素的邻居网格&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> tmp = gridController.GetIndexNeighborGrids(i);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> j <span class="keyword">in</span> tmp)</span><br><span class="line">                Debug.Log(j.GetName());</span><br><span class="line">            Debug.Log(<span class="string">&quot;————————————————————————&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/spatial-partition.html">游戏编程模式 - 空间分区</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>渲染流程中的各种剔除与裁剪</title>
    <url>/2022/09/03/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/</url>
    <content><![CDATA[<h1 id="视椎体剔除"><a href="#视椎体剔除" class="headerlink" title="视椎体剔除"></a>视椎体剔除</h1><ul>
<li>发生在应用程序阶段，一般由游戏引擎内部实现或者自己编写对应的算法来实现，运行在<code>CPU</code>上</li>
<li>裁剪的依据主要是根据摄像机的视野(<code>field of view</code>)以及近裁减面和远裁剪面的距离，将可视范围外的物体排除出渲染，被剔除的物体将不会进入渲染的几何阶段(<code>Geometry Stage</code>)。视椎体剔除是减少渲染消耗的最有效手段之一，可以在不影响渲染效果的情况下大幅减少渲染涉及到的顶点数和面数</li>
<li>工作原理：</li>
</ul>
<ol>
<li><p>遮挡剔除会在 <code>Unity Editor</code> 中生成有关场景的数据，然后在运行时使用该数据来确定摄像机可以看到的内容。这种生成数据的过程称为烘焙</p>
</li>
<li><p>在对遮挡剔除数据进行烘焙时，<code>Unity</code> 将场景划分为多个单元，并生成描述单元内几何体以及相邻单元之间可见性的数据。然后，<code>Unity</code> 尽可能合并单元，以减小生成的数据的大小。要配置烘焙过程，可以在 <code>Occlusion Culling</code> 窗口中更改参数，并在场景中使用遮挡区域</p>
</li>
<li><p>在运行时，<code>Unity</code> 会将这些烘焙的数据加载到内存中，并且对于每个启用了<code>Occlusion Culling</code> 属性的摄像机，将会对数据执行查询以确定该摄像机可以看到的内容。请注意，启用遮挡剔除后，摄像机将执行视锥体剔除和遮挡剔除</p>
</li>
</ol>
<ul>
<li>在<code>Unity</code>中的视锥体剔除，其原理就是通过判定目标包围盒与组成相机视锥体的<code>6</code>个平面进行同侧判定</li>
</ul>
<h1 id="遮挡剔除（Occlusion-Culling）"><a href="#遮挡剔除（Occlusion-Culling）" class="headerlink" title="遮挡剔除（Occlusion Culling）"></a>遮挡剔除（<code>Occlusion Culling</code>）</h1><ul>
<li>遮挡裁剪，也常被称作遮挡剔除</li>
<li>发生在应用程序阶段(<code>Application Stage</code>)，由游戏引擎实现，运行在<code>CPU</code>上</li>
<li>以<code>Unity</code>为例，需要根据场景中<code>Static</code>物体的位置预先生成场景<code>Occlusion Culling</code>数据，运行时就可以剔除对应静态物体之后的其他物体。遮挡剔除是减少渲染消耗的有效手段之一，可以和视椎体剔除同时生效，进一步减少渲染的消耗</li>
<li>如下分别为没有遮挡剔除和遮挡剔除</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A41.jpg?raw=true"></p>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A42.jpg?raw=true"></p>
<h1 id="视口裁剪"><a href="#视口裁剪" class="headerlink" title="视口裁剪"></a>视口裁剪</h1><ul>
<li><p>发生在几何阶段后期，投影变换之后屏幕映射之前，是渲染管线的必要一环。只有当图元完全或部分存在于规范立方体内部的时候，才将其返送到光栅化阶段。其中，对于完全位于规范立方体内部的图元，则直接进行下一阶段；完全处于规范立方外部的图元则完全被舍弃；部分处于规范立方体内部图元，则会根据视口进行对应的裁剪，在这一过程中可能会产生新的顶点</p>
</li>
<li><p>通过视口剔除可以将视口外的图元舍弃掉，减小光栅化阶段的消耗</p>
</li>
</ul>
<h1 id="背面裁剪"><a href="#背面裁剪" class="headerlink" title="背面裁剪"></a>背面裁剪</h1><ul>
<li>背面剔除即是将背向视点的图元剔除，因为它们对最终渲染的图像没有贡献。这是一种简单直观的操作，一次对一个多边形进行操作</li>
<li>基本原理：先判定多边形的朝向，并和当前的观察方向进行比较</li>
<li><code>Unity</code>中的背面剔除在光栅化阶段进行，执行在<code>Vertex Shader</code> 之后，在<code>Fragment Shader</code>片元着色器之前，通过<code>Shader</code>中的<code>Cull</code>指令来控制背面剔除的开启和关闭<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/%E8%83%8C%E9%9D%A2%E8%A3%81%E5%89%AA1.png?raw=true"></li>
<li>右图为视点空间中背面测试情形，多边形 <code>A</code> 是背向的，而 <code>B</code> 和 <code>C</code> 是正向的。多背向的多边形<code>A</code>，无需进行光栅化<h1 id="深度剔除"><a href="#深度剔除" class="headerlink" title="深度剔除"></a>深度剔除</h1></li>
<li>在<code>Fragment Shader</code>之后，光栅化阶段末期的融合阶段执行，又叫深度检测(或<code>Z</code>缓存检测)。每次将一个图元回执为相应的像素时，都会计算像素位置处图元的深度值，和深度缓存中对应像素的值进行比较，如果新计算出的深度小于缓存中的深度，则更新深度缓存中的值；如果深度值大于深度缓冲中的值，则计算结果被舍弃，深度缓冲的值也无需更新</li>
</ul>
<h1 id="入口裁剪"><a href="#入口裁剪" class="headerlink" title="入口裁剪"></a>入口裁剪</h1><ul>
<li>入口裁剪算法的基本思想：在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪。当遍历入口的时候，就减小视锥</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/%E5%85%A5%E5%8F%A3%E8%A3%81%E5%89%AA1.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%89%94%E9%99%A4/%E5%85%A5%E5%8F%A3%E8%A3%81%E5%89%AA2.png?raw=true"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/game_fengxiaorui/article/details/79958722">不同几种剔除(Culling)在渲染流程中的使用总结</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/119431#:~:text=%E8%A7%86%E9%94%A5%E8%A3%81%E5%89%AA%E4%B8%80%E8%88%AC%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5%E8%BF%9B%E8%A1%8C%2C,%E8%BF%99%E4%B8%AA%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">三维渲染中的裁剪总汇</a></li>
<li><a href="https://blog.csdn.net/poem_qianmo/article/details/78884513">【《Real-Time Rendering 3rd》 提炼总结】(十一) 第十四章 : 游戏开发中的渲染加速算法总结</a></li>
<li><a href>《Real-Time Rendering 3rd》</a></li>
</ul>
]]></content>
      <categories>
        <category>渲染</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2023/04/02/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>桥接模式：<strong>将抽象和实现解耦，使得两者可以独立地变化</strong></li>
<li>桥接模式属于结构型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象类(Abstraction)：定义抽象接口，它一般是抽象类而不是接口。该接口中包含实现具体行为、具体特征的Implementor接口</li>
<li>扩充的抽象类(RefinedAbstraction)：继承自Abstraction的子类，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法</li>
<li>实现类(Implementor)：定义具体行为，具体特征的应用接口</li>
<li>具体实现类(ConcreteImplementor)：实现Implementor</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/bridge.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>降低了沿着两个或多个维度扩展时的复杂度，防止类的过度膨胀</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>当一个对象有多个变化因素时，可以考虑使用桥接模式，通过抽象这些变化因素，将依赖具体实现修改为依赖抽象。</li>
<li>当我们期望一个对象的多个变化因素可以动态变化，而且不影响客户端的程序使用时。</li>
<li>如果使用继承的实现方案，会导致产生很多子类，任何一个变化因素都需要产生多个类来完成，就要考虑桥接模式。</li>
<li>游戏开发中一个武器有多种变化形态，可以考虑使用桥接模式</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Examination</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSubject</span>(<span class="params">ISubject _subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = _subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Test</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩充的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MaxCount</span> : <span class="title">Examination</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        subject?.ExaminationCount(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinCount</span> : <span class="title">Examination</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        subject?.ExaminationCount(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExaminationCount</span>(<span class="params"><span class="built_in">int</span> Count</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Math</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExaminationCount</span>(<span class="params"><span class="built_in">int</span> Count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;数学科目分数为：<span class="subst">&#123;Count&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">English</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExaminationCount</span>(<span class="params"><span class="built_in">int</span> Count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;英语科目分数为：<span class="subst">&#123;Count&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        English english = <span class="keyword">new</span> English();</span><br><span class="line"></span><br><span class="line">        MaxCount maxCount = <span class="keyword">new</span> MaxCount();</span><br><span class="line">        MinCount minCount = <span class="keyword">new</span> MinCount();</span><br><span class="line"></span><br><span class="line">        maxCount.SetSubject(math);</span><br><span class="line">        <span class="comment">//数学科目分数为：100</span></span><br><span class="line">        maxCount.Test();</span><br><span class="line"></span><br><span class="line">        maxCount.SetSubject(english);</span><br><span class="line">        <span class="comment">//英语科目分数为：100</span></span><br><span class="line">        maxCount.Test();</span><br><span class="line"></span><br><span class="line">        minCount.SetSubject(math);</span><br><span class="line">        <span class="comment">//数学科目分数为：0</span></span><br><span class="line">        minCount.Test();</span><br><span class="line"></span><br><span class="line">        minCount.SetSubject(english);</span><br><span class="line">        <span class="comment">//英语科目分数为：0</span></span><br><span class="line">        minCount.Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Bridge%20Pattern">桥接模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511192">C#设计模式笔记之桥接模式（Bridge pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/bridge-pattern.html">桥接模式</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>类型对象</title>
    <url>/2023/04/03/%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>类型对象：<strong>创造一个类A来允许灵活地创造新类型，类A的每个实例都代表了不同的对象类型</strong></li>
<li>要点：</li>
</ul>
<ol>
<li>类型对象模式：定义类型对象类与有类型的对象类。每个类型对象实例代表一种不同的逻辑类型。每种有类型的对象保存描述它类型的对类型对象的引用。</li>
<li>类型对象的基本思想就是给基类一个品种类（breed类），而不是用一些子类继承自这个基类。所以我们在做种类区分的时候就可以只有两个类，怪物类monster和品种类breed，而不是monster，dragon，troll等一堆类。所以在此种情况下，游戏中的每个怪物都是怪物类的一个实例，而实例中的breed类包含了所有同种类型怪物共享的信息</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>类型对象类：<strong>每个类型对象实例代表一种不同的逻辑类型。被同种类分享的数据或者行为存储在类型对象中</strong></li>
<li>有类型的对象类：<strong>每种有类型的对象保存对描述它类型的类型对象的引用。实例相关的数据被存储在有类型对象的实例中</strong></li>
</ol>
<ul>
<li>使用场合：</li>
</ul>
<ol>
<li>不知道后续还需什么新类型。（举个例子，如果你的游戏需要支持增量更新，让用户下载后续新包含进来的怪物品种）</li>
<li>想要不改变代码或不重新编译就能修改或添加新类型</li>
</ol>
<ul>
<li>引申与参考：</li>
</ul>
<ol>
<li>这个模式引出的进阶问题是如何在不同对象之间共享数据。以不同的方式解决同一个问题的是GOF设计模式中的原型模式（prototype pattern）。</li>
<li>类型对象是GOF设计模式中享元模式的亲兄弟。两者都让你在实例间分享代码。使用享元，意图是节约内存，而分享的数据也许不代表任何概念上对象的“类型”。而使用类型对象模式，焦点在组织性和灵活性。</li>
<li>这个模式和GOF设计模式中状态模式有很多相似之处，两者都是委托了对象的部分定义给另外一个对象</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型对象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Breed</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Breed</span>(<span class="params"><span class="built_in">int</span> _hp,<span class="built_in">string</span> _name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = _hp;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enemy <span class="title">NewEnmey</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enemy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有类型的对象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> enemyName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> enemyHp;</span><br><span class="line">    <span class="keyword">private</span> Breed breed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enemy</span>(<span class="params">Breed _breed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        breed = _breed;</span><br><span class="line">        enemyHp = breed.hp;</span><br><span class="line">        enemyName = breed.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> breed.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Breed small = <span class="keyword">new</span> Breed(<span class="number">1</span>, <span class="string">&quot;smallEnemy&quot;</span>);</span><br><span class="line">        Breed big = <span class="keyword">new</span> Breed(<span class="number">10</span>, <span class="string">&quot;bigEnemy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Enemy smallEnemy = small.NewEnmey();</span><br><span class="line">        <span class="comment">//smallEnemy</span></span><br><span class="line">        Debug.Log(smallEnemy.GetName());</span><br><span class="line"></span><br><span class="line">        Enemy bigEnemy = big.NewEnmey();</span><br><span class="line">        <span class="comment">//bigEnemy</span></span><br><span class="line">        Debug.Log(bigEnemy.GetName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/subclass-sandbox.html">游戏编程模式 - 类型对象</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#11">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Type%20Object%20Pattern">类型对象模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2023/04/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>策略模式：<strong>定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换</strong>。策略模式让算法独立于使用它的客户而变化。与状态模式是如此的相似，就犹如一对双胞胎一样。只不过状态模式是通过改变对象内部的状态来帮助对象控制自己的行为，而策略模式则是围绕可以互换的算法来创建成功业务。</p>
</li>
<li><p>策略模式属于行为型模式</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>上下文类（Context）：<strong>上下文类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略</strong>。在上下文类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类（Strategy）：<strong>它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口</strong>。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法</li>
<li>具体策略类（ConcreteStrategy）：<strong>它实现了在抽象策略类中声明的算法</strong>，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/strategy.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>扩展性良好</li>
<li>避免使用多重条件判断</li>
<li>具体策略可根据具体需要切换</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>策略类会增多，代码量会上升</li>
<li>所有策略类都需要对外暴露</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为</li>
<li>一个系统需要动态地在几种算法中选择一种</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Compute</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;未重写IStrategy的Compute方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Addition</span> : <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Compute</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;a + b = <span class="subst">&#123;a + b&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subtraction</span> : <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Compute</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;a - b = <span class="subst">&#123;a - b&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Multiplication</span> : <span class="title">IStrategy</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num1;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetStrategy</span>(<span class="params">IStrategy _strategy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = _strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行真正的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Compute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        strategy?.Compute(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置算数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNum</span>(<span class="params"><span class="built_in">int</span> n1,<span class="built_in">int</span> n2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = n1;</span><br><span class="line">        num2 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.SetNum(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        context.SetStrategy(<span class="keyword">new</span> Addition());</span><br><span class="line">        <span class="comment">//a + b = 10</span></span><br><span class="line">        context.Compute();</span><br><span class="line"></span><br><span class="line">        context.SetStrategy(<span class="keyword">new</span> Subtraction());</span><br><span class="line">        <span class="comment">//a - b = 2</span></span><br><span class="line">        context.Compute();</span><br><span class="line"></span><br><span class="line">        context.SetStrategy(<span class="keyword">new</span> Multiplication());</span><br><span class="line">        <span class="comment">//未重写IStrategy的Compute方法</span></span><br><span class="line">        context.Compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Strategy%20Pattern">策略模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511096">C#设计模式笔记之策略模式（Strategy pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/strategy-pattern.html">策略模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组件模式</title>
    <url>/2023/04/04/%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>组件模式：<strong>允许单一的实体跨越多个领域而不会导致这些领域彼此耦合</strong></li>
<li>要点：</li>
</ul>
<ol>
<li>组件模式：在单一实体跨越了多个领域时，为了保持领域之间相互解耦，可以将每部分代码放入各自的组件类中，将实体简化为组件的容器。</li>
<li>Unity引擎在设计中频繁使用了这种设计方法，从而让其易于使用。</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>具体组件类：<strong>定义组件具有的变量和行为</strong></li>
<li>实体类：<strong>保存对所需组件的引用和集合(用于保存组件)</strong></li>
</ol>
<ul>
<li>使用场合：</li>
</ul>
<ol>
<li>有一个涉及了多个领域的类，而你想保持这些领域互相隔离。</li>
<li>一个类正在变大而且越来越难以使用。</li>
<li>想要能定义一系列分享不同能力的类，但是使用接口不足以得到足够的重用部分</li>
</ol>
<ul>
<li>引申与参考</li>
</ul>
<ol>
<li>Unity核心架构中GameObject类完全根据此模式来进行设计。</li>
<li>这种模式与GOF设计模式中的策略模式类似。两种模式都是将对象的行为取出，委派到一个单独的从属对象中。两者的不同点在于：</li>
<li>策略模式中分离出的策略对象通常是无状态的——它封装的是算法，而不是数据。策略模式定义了对象的行为，而不是该对象是什么。</li>
<li>而组件模式就更加复杂。组件经常保存了对象的状态，这有助于确定其真正的身份。但是，其界限往往很模糊。有些情况下组件也许根本没有任何状态。在这种情况下，你可以在不同的容器对象中使用相同的组件实例。这样看来，它的行为确实更像一种策略</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象组件接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tick</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTransform</span> : <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;MyTransform&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInput</span> : <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;MyInput&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Actor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> MyTransform myTransform;</span><br><span class="line">    <span class="keyword">private</span> MyInput myInput;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MyCompoent&gt; compoentList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span>(<span class="params"><span class="built_in">string</span> _name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        myTransform = <span class="keyword">new</span> MyTransform();</span><br><span class="line">        myInput = <span class="keyword">new</span> MyInput();</span><br><span class="line">        compoentList = <span class="keyword">new</span> List&lt;MyCompoent&gt;();</span><br><span class="line">        compoentList.Add(myTransform);</span><br><span class="line">        compoentList.Add(myInput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> compoentList)</span><br><span class="line">            i.Tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Actor player = <span class="keyword">new</span> Actor(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">        <span class="comment">//MyTransform</span></span><br><span class="line">        <span class="comment">//MyInput</span></span><br><span class="line">        player.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/component.html">游戏编程模式 - 组件模式</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#11">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Component%20Pattern">组件模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>空间数据结构</title>
    <url>/2022/08/07/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>在游戏程序中，利用空间数据结构加速计算往往是非常重要的优化思想，空间数据结构可以应用于场景管理、渲染、物理、游戏逻辑等方面。例如，在渲染管线的应用阶段中有粗粒度剔除，就可以使用四叉树、八叉树、<code>BVH</code>树、<code>BSP</code>树、<code>BVH</code>树等</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5%E7%9A%84%E7%B2%97%E7%B2%92%E5%BA%A6%E5%89%94%E9%99%A4.png?raw=true"></p>
<h1 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h1><ul>
<li>四叉树索引的基本思想是将地理空间递归划分为不同层次的树结构。它将已知范围的空间等分成四个相等的子空间，如此递归下去，直至树的层次达到一定深度或者满足某种要求后停止分割</li>
<li>四叉树广泛应用于图像处理、空间数据索引、<code>2D</code>中的快速碰撞检测、存储稀疏数据等</li>
<li>四叉树的结构在空间数据对象分布比较均匀时，具有比较高的空间数据插入和查询效率复杂度<code>O(logN)</code></li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91.png?raw=true"></p>
<ul>
<li>例如使用四叉树对场景物体的静态物体和动态物体进行渲染管理。<a href="https://github.com/KDuoLi/QuadTree">GitHub项目</a></li>
</ul>
<h2 id="松散四叉树"><a href="#松散四叉树" class="headerlink" title="松散四叉树"></a>松散四叉树</h2><ul>
<li>四叉树&#x2F;八叉树的一个问题是，物体有可能在边界处来回，从而导致物体总是在切换节点，从而不得不更新四叉树&#x2F;八叉树。而松散四叉树&#x2F;八叉树正是解决这种边界问题的一种方式：</li>
<li>首先它定义一个节点有入口边界(<code>inner boundary</code>)，出口边界(<code>outerboundary</code>)。</li>
<li>那么如何判定一个物体现在在哪个节点呢？</li>
</ul>
<ol>
<li>若物体还没添加进四叉树&#x2F;八叉树，则检测现在位于哪个节点的入口边界内;</li>
<li>若物体先前已经存在于某个节点，则先检测现在是否越出该节点的出口边界，若越出再检测位于哪个节点的入口边界内。</li>
</ol>
<ul>
<li>在非松散的四叉树&#x2F;八叉树中，入口边界和出口边界是一样的</li>
<li>而松散四叉树&#x2F;八叉树的松散，是指出口边界比入口边界要稍微宽些（各节点的出口边界也会发生部分重叠，松散比较符合这种描述），从而使节点不容易越过出口边界，减少了物体切换节点的次数<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9D%BE%E6%95%A3%E5%9B%9B%E5%8F%89%E6%A0%91.png?raw=true"></li>
</ul>
<h1 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h1><ul>
<li>八叉树是一种用于描述三维空间的树状数据结构</li>
<li>主要用途</li>
</ul>
<ol>
<li>三维计算机图形学中的细节层次渲染</li>
<li>最邻近搜索</li>
<li>三维空间中的高效碰撞检测</li>
<li>稀疏体素八叉树</li>
<li>状态估计<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%8F%89%E6%A0%91.jpg?raw=true"></li>
</ol>
<h2 id="松散八叉树"><a href="#松散八叉树" class="headerlink" title="松散八叉树"></a>松散八叉树</h2><ul>
<li>同四叉树</li>
</ul>
<h1 id="BVH树"><a href="#BVH树" class="headerlink" title="BVH树"></a>BVH树</h1><ul>
<li><p>层次包围盒树（<code>BVH</code>树）是一棵多叉树，用来存储包围盒形状</p>
</li>
<li><p>它的根节点代表一个最大的包围盒，其多个子节点则代表多个子包围盒。</p>
</li>
<li><p>此外为了统一化层次包围盒树的形状，它只能存储同一种包围盒形状。</p>
</li>
<li><p>计算机的包围盒形状有球体&#x2F;<code>AABB</code>&#x2F;<code>OBB</code>&#x2F;<code>k-DOP</code>，常用的层次包围盒树有<code>AABB</code>层次包围盒树和球体树</p>
</li>
<li><p>应用</p>
</li>
</ul>
<ol>
<li>碰撞检测</li>
<li>射线检测&#x2F;挑选几何体</li>
<li>视锥剔除</li>
<li>辅助<code>BSP</code>树构建</li>
</ol>
<h2 id="AABB包围盒树"><a href="#AABB包围盒树" class="headerlink" title="AABB包围盒树"></a>AABB包围盒树</h2><ul>
<li><code>AABB</code>包围盒就是采用一个长方体将物体包裹起来</li>
<li>下图为层次<code>AABB</code>包围盒树。把不同形状粗略用<code>AABB</code>形状围起来看作一个<code>AABB</code>形状（为了统一化形状），然后才建立层次<code>AABB</code>包围盒树</li>
<li>在物理引擎里，由于物理模拟，大部分形状都是会动态更新的，例如位移&#x2F;旋转都会改变形状。于是就又有一种支持动态更新的层次包围盒树，称之为动态层次包围盒树。它的算法核心大概：形状的位移&#x2F;旋转&#x2F;伸缩更新对应的叶节点，然后一级一级更新上面的节点，使它们的包围体包住子节点</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/BVH%E6%A0%91.png?raw=true"></p>
<h2 id="球体包围盒树"><a href="#球体包围盒树" class="headerlink" title="球体包围盒树"></a>球体包围盒树</h2><ul>
<li><p>球体是最容易计算的一类包围盒，而且球体树构造速度可以很快，因此球体树可被用作粗略松散但快速的空间划分结构。</p>
</li>
<li><p>快速构造松散球体树的步骤（以三角形物体为例）：这样生成的球体树是粗糙的，但是其平衡效果并不差，且最重要的是它的构造时间复杂度只有<code>O(NlogN)</code></p>
</li>
</ul>
<ol>
<li>计算出包围所有三角边顶点的最小球体包围盒，作为根节点</li>
<li>以球心为坐标系原点，其坐标系X轴划分出在该X轴左右的三角形，并将这些分别放入左子节点、右子节点中</li>
<li>重复步骤<code>1</code>、<code>2</code>，最后得到一棵球体树</li>
</ol>
<h2 id="OBB包围盒树"><a href="#OBB包围盒树" class="headerlink" title="OBB包围盒树"></a>OBB包围盒树</h2><ul>
<li><code>OBB</code>（<code>Oriented Bounding Box</code>，有向包围盒）比包围球和<code>AABB</code>更加逼近物体，能显著减少包围体的个数</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%90%83%E4%BD%93%E3%80%81AABB%E3%80%81OBB.jpg?raw=true"></p>
<h1 id="BSP树"><a href="#BSP树" class="headerlink" title="BSP树"></a>BSP树</h1><ul>
<li><code>BSP tree</code>是一棵二叉树，译为二维空间分割树</li>
<li><code>BSP tree</code>在<code>3D</code>空间下其每个节点表示一个平面，其代表的平面将当前空间划分为前向和背向两个子空间，分别对应左儿子和右儿子。<code>2D</code>空间下，<code>BSP</code>树每个节点则表示一条边，也可以将<code>2D</code>空间划分成前后两部分<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/BSP%E6%A0%91.jpg?raw=true"></li>
</ul>
<h1 id="k-d树"><a href="#k-d树" class="headerlink" title="k-d树"></a>k-d树</h1><ul>
<li><code>k-d</code>树是一棵二叉树，其每个节点都代表一个 <code>k</code>维坐标点：</li>
</ul>
<ol>
<li>树的每层都是对应一个划分维度（取决于你定义第<code>i</code>层是哪个维度）</li>
<li>树的每个节点代表一个超平面，该超平面垂直于当前划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在其右子树</li>
</ol>
<ul>
<li>实际上，<code>k-d</code>树就是一种特殊形式的<code>BSP</code>树（轴对齐的<code>BSP</code>树）</li>
<li>应用</li>
</ul>
<ol>
<li>划分区域</li>
<li>最近邻静态目标查找<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一种实现方式示例：二维k-d树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KdTreeNode</span>&#123;</span><br><span class="line">    Vector2 position;         <span class="comment">//位置</span></span><br><span class="line">    <span class="type">int</span> dimension;            <span class="comment">//当前所属层的维度</span></span><br><span class="line">    KdTreeNode* children[<span class="number">2</span>];  <span class="comment">//两个子树</span></span><br><span class="line">    <span class="comment">//Data data;              //数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>举例，一棵<code>k-d</code>树（<code>k=2</code>）的结构如图：<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k-d%E6%A0%91(k=2).png?raw=true"></li>
<li>根据第一层划分维度为<code>X</code>，第二层为<code>Y</code>，第三层为<code>X</code>，<br>所以该<code>k-d</code>树（<code>k=2</code>）对应代表划分的空间，看起来应该是这样的：<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k-d%E6%A0%91(k=2).1.png?raw=true"></li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>总的来说，游戏开发最常用的空间数据结构是四叉&#x2F;八叉树、<code>BVH</code>树，而<code>BSP</code>树基本上只能应用于编辑器上，<code>k-d</code>树则几乎没有可以应用的地方<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94%E8%A1%A8.png?raw=true"></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/KillerAery/p/10878367.html#bsp%E6%A0%91-binary-space-partitioning-tree">空间数据结构(四叉树&#x2F;八叉树&#x2F;BVH树&#x2F;BSP树&#x2F;k-d树)</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E5%8F%89%E6%A0%91">wiki - 八叉树</a></li>
<li><a href="https://docs.qq.com/slide/DUGZtZlVtQVBRaFli">1100-渲染管线简介-v4</a></li>
<li><a href="https://blog.codingnow.com/2020/07/culling_space.html">裁剪和空间管理</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>脏标识模式</title>
    <url>/2023/04/04/%E8%84%8F%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>脏标识模式：<strong>将工作延期至需要其结果时才去执行，以避免不必要的工作</strong></li>
<li>要点</li>
</ul>
<ol>
<li>脏标记，就是用来表示被标记的内容是否有被修改过的一个标志位。</li>
<li>脏标识模式：考虑情况，当前有一组原始数据随着时间变化而改变。由这些原始数据计算出目标数据需要耗费一定的计算量。这个时候，可以用一个脏标识，来追踪目前的原始数据是否与之前的原始数据保持一致，而此脏标识会在被标记的原始数据改变时改变。那么，若这个标记没被改变，就可以使用之前缓存的目标数据，不用再重复计算。反之，若此标记已经改变，则需用新的原始数据计算目标数据。</li>
</ol>
<ul>
<li>使用场合：就像其他优化模式一样，此模式会增加代码复杂度。只在有足够大的性能问题时，再考虑使用这一模式。</li>
</ul>
<ol>
<li>当前任务有昂贵的计算开销</li>
<li>当前任务昂贵的同步开销</li>
</ol>
<ul>
<li><p>若满足这两者之一，也就是两者从原始数据转换到目标数据会消耗很多时间，都可以考虑使用脏标记模式来节省开销。</p>
</li>
<li><p>若原始数据的变化速度远高于目标数据的使用速度，此时数据会因为随后的修改而失效，此时就不适合使用脏标记模式</p>
</li>
<li><p>引申与参考</p>
</li>
</ul>
<ol>
<li>脏标记模式在游戏外的领域也是常见的，比如像Angular这种browser-side web框架，其利用赃标记来跟踪浏览器中变动的数据以及需要提交到服务端的数据</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">    <span class="comment">//脏标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> dirty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params">Vector3 _position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        position = _position;</span><br><span class="line">        dirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPosition</span>(<span class="params">Vector3 _position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        position = _position;</span><br><span class="line">        dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetPosition</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dirty)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//模拟重新计算，等到获取数据时再去计算</span></span><br><span class="line">            position += <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(Vector3.zero);</span><br><span class="line">        person.SetPosition(Vector3.up);</span><br><span class="line">        person.SetPosition(Vector3.down);</span><br><span class="line">        <span class="comment">//(100.00, 99.00, 100.00)</span></span><br><span class="line">        Debug.Log(person.GetPosition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://gpp.tkchu.me/dirty-flag.html">游戏编程模式 - 脏标识模式</a></li>
<li><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md#15">《游戏编程模式》全书内容梗概总结</a></li>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/Dirty%20Flag%20Pattern">脏标记模式</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏编程模式</category>
      </categories>
  </entry>
  <entry>
    <title>纹理</title>
    <url>/2022/08/08/%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>纹理（<code>Texture</code>）：是一个图片，一种可供着色器读写的结构化存储形式，存储各种各样的信息，例如颜色信息、高度、纹理通道、法线等，除了具体的存储信息之外，还会包含纹理采样的设置</li>
<li>如下图，一张二维纹理，宽、高、想要存储的信息（该例子是<code>RGBA</code>，所以存储的信息是颜色）。[<code>Height</code>][<code>Width</code>]对应图像上的一个像素点。推断出一维纹理是<code>i=0</code>或者<code>j=0</code>的二维数组，三维纹理可以看作是二维子对象矩形构成的一个四维数组<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86.png?raw=true"></li>
<li>纹理内存大小（字节） &#x3D; 纹理宽度 x 纹理高度 x 像素字节</li>
<li>优点</li>
</ul>
<ol>
<li>减少建模工作量</li>
<li>降低存储空间</li>
<li>加快读取速度</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>降低几何细节</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png?raw=true"></p>
<ul>
<li><p>引入纹理的目的：为了可以使用图像函数或其他数据源来修正模型的表现</p>
</li>
<li><p>纹理如何起作用？需要引入纹理管线，如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.png?raw=true"></p>
</li>
<li><p>假设模型要渲染的点在模型空间上的位置是<code>（-2.3，7.1，88.2）</code>，经投影函数变换后得到一个<code>uv</code>值<code>（0.32，0.29）</code>，而这张纹理的大小是<code>256*256</code>，将上述两值相乘，得到<code>（81.92,74.24）</code>，后续获取一个具体的纹素（纹理图像中的像素）的颜色，就由纹理采样的设置来决定<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BE%8B%E5%AD%90.png?raw=true"></p>
</li>
</ul>
<h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><ul>
<li><p>定义：使用<code>uv</code>坐标将三维物体每个点的颜色信息存储在一张<code>2D</code>的<code>Texture</code>里，即将物体空间坐标点转化为纹理坐标，进而从纹理上获取对应点的值，以增强着色细节的方法<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%841.jpg?raw=true"></p>
</li>
<li><p>步骤如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B.jpg?raw=true"></p>
<h2 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h2></li>
<li><p>定义：从纹理图片中使用纹理坐标采集一个像素颜色的操作</p>
</li>
<li><p>例如在下图中，我们采样<code>（0,1）</code>这个位置的像素，获得了浅蓝色</p>
</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4.png?raw=true"></p>
<ul>
<li>设想一种特殊情况，我们要渲染的物体正面对着我们，刚好画布尺寸与纹理尺寸一致，比如都是 <code>512*512</code>，那么在获取每个 <code>pixel</code> 对应 <code>texel</code> 值时，刚好就能得到整数的纹理坐标，只需要每个 <code>texel</code> 逐个读取即可</li>
<li>但实际中，我们会面临纹理过大或者过小两种情况。分两种情况来讨论：</li>
</ul>
<ol>
<li>纹理分辨率过小，需要放大 (<code>Magnification</code>)</li>
<li>纹理分辨率过大，需要缩小 (<code>Minification</code>)<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E8%BF%87%E5%A4%A7%E3%80%81%E8%BF%87%E5%B0%8F.jpg?raw=true"></li>
</ol>
<h2 id="纹理渲染优化："><a href="#纹理渲染优化：" class="headerlink" title="纹理渲染优化："></a>纹理渲染优化：</h2><ol>
<li><code>CPU</code>方面：1）纹理图集；2）纹理数组</li>
<li><code>GPU</code>方面：1）纹理压缩<h2 id="UV（纹理坐标）"><a href="#UV（纹理坐标）" class="headerlink" title="UV（纹理坐标）"></a>UV（纹理坐标）</h2></li>
</ol>
<ul>
<li>纹理坐标位于纹理空间中。是三维模型<code>XYZ</code>坐标系映射到<code>UV</code>坐标系上的二维图像。<code>U</code>代表水平方向，<code>V</code>代表垂直方向</li>
<li>纹理坐标起始于<code>(0, 0)</code>，也就是纹理图片的左下角，终始于<code>(1, 1)</code>，即纹理图片的右上角<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/UV.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E6%A8%A1%E5%9E%8B%E4%B8%8EUV.png?raw=true"></li>
</ul>
<h2 id="纹理采样设置之Wrap-Mode"><a href="#纹理采样设置之Wrap-Mode" class="headerlink" title="纹理采样设置之Wrap Mode"></a>纹理采样设置之Wrap Mode</h2><ul>
<li>纹理环绕的作用是为了处理<code>UV</code>超出<code>0.0~1.0</code>范围的纹理坐标</li>
<li><code>Wrap Mode</code>决定了<code>UV</code>值在被对应函数映射到<code>0~1</code>范围之外时候的一些表现</li>
<li>在<code>OpenGL</code>中称其为包装模式（<code>Wrapping Model</code>），在<code>DirectX</code>中称其为纹理寻址模式（<code>Texture Addressing Mode</code>）<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E8%AE%BE%E7%BD%AE%E4%B9%8BWrap%20Mode.png?raw=true"><h2 id="纹理采样设置之Filter-Mode"><a href="#纹理采样设置之Filter-Mode" class="headerlink" title="纹理采样设置之Filter Mode"></a>纹理采样设置之Filter Mode</h2></li>
<li>为什么需要纹理过滤：屏幕的一个像素与它在对应的纹素之间可以存在不同类型的对应关系。而同一物体与摄像机的距离不同，会占据不同数目的屏幕像素（例如，当物体非常靠近摄像机，屏幕上的一个像素有可能对应纹理贴图纹素中的一小部分，而当物体距离摄像机很远时，屏幕上的一个像素包含纹理贴图上的很多个纹素），但使用纹理贴图的大小是不变，一个像素通常不直接对应于一个纹理像素。必须应用某种形式的滤波来确定像素的最佳颜色</li>
<li>纹理过滤的作用是将浮点型纹理坐标转换为整数的像素坐标，并对采样结果进行处理</li>
<li><code>Filter Mode</code>决定了当纹理由于变化而产生拉伸的时候，要采用那种滤波模式来调整它自身的表现<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E8%AE%BE%E7%BD%AE%E4%B9%8BFilter%20Mode.png?raw=true"></li>
</ul>
<h1 id="Mipmap（多级渐远纹理）"><a href="#Mipmap（多级渐远纹理）" class="headerlink" title="Mipmap（多级渐远纹理）"></a>Mipmap（多级渐远纹理）</h1><ul>
<li><p><code>Mipmap</code>是一系列纹理，每个纹理都是同一图像的分辨率逐渐降低的表示形式。根据纹理与摄像机的距离，采用不同的<code>leavl</code></p>
</li>
<li><p>工作原理：从纹理的原始图像零级作为金字塔的底部，并将<code>2*2</code>的<code>4</code>个相邻的纹理的的平均值作为下一级的新的纹素值，所以新一级的子纹理是上一级的<code>1/4</code>大，如此反复，最后纹理大小就会变成<code>1*1</code><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/Mipmap.png?raw=true"></p>
</li>
<li><p>优点</p>
</li>
</ul>
<ol>
<li>优化显存带宽，加快渲染速度</li>
<li>降低采样频率，避免了在远距离情况下的采样频率低和数据频率高造成的失真和摩尔纹</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>会占用更大的内存。使用<code>Mipmap</code>比不使用<code>Mipmap</code>大<code>1/3</code></li>
</ol>
<h1 id="纹理图集（TextureAtlas）"><a href="#纹理图集（TextureAtlas）" class="headerlink" title="纹理图集（TextureAtlas）"></a>纹理图集（TextureAtlas）</h1><ul>
<li><p>纹理图集是一系列小纹理图像的集合</p>
</li>
<li><p>优点：</p>
</li>
</ul>
<ol>
<li><p>是采用共同纹理图集的多个静态网格资源可以进行静态合批处理，减少DrawCall调用次数。</p>
</li>
<li><p>是纹理图集可以减少碎纹理过多，因为他们打包在一个图集里，通过压缩可以更有效的利用压缩，降低纹理的内存成本和冗余数据。</p>
</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>美术需要合理规划模型，并且要求模型有相同的材质着色器，或需要制作通道图去区分不同材质。制作和修改成本较高</li>
</ol>
<h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul>
<li>纹理压缩是为了解决<strong>内存</strong>、<strong>带宽</strong>问题，专为在计算机图形渲染系统中存储<strong>纹理</strong>而使用的图像压缩技术</li>
<li>图片格式：是图片文件的存储格式，通常在磁盘、内存中存储和传输文件时使用。例如<code>Jpg</code>（有损不透明）、<code>PNG</code>（无损透明）、<code>GIF</code>、<code>BMP</code>等</li>
<li>纹理格式：是显卡能够直接进行采样（使用纹理坐标获取纹理颜色）的纹理数据格式，通常在向显卡中加载纹理时使用<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png?raw=true"></li>
<li>决定纹理资源大小的因素</li>
</ul>
<ol>
<li>分辨率</li>
<li>格式</li>
<li><code>Mipmap</code></li>
</ol>
<ul>
<li>图片格式与纹理格式的区别</li>
</ul>
<ol>
<li>纹理压缩格式基于块压缩，能够更快读取像素所属字节块进行解压缩以支持随机访问</li>
<li>图片压缩格式基于整张图片进行压缩，像素之间解码过程存在依赖关系，无法直接实现单个像素的解析，图片压缩格式无法被<code>GPU</code>识别，还需要经<code>CPU</code>解压缩成非压缩纹理格式才能被识别，解码后都是<code>RGBA</code>纹理格式</li>
</ol>
<ul>
<li>常见纹理格式如下图<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F.png?raw=true"></li>
</ul>
<h2 id="非压缩格式"><a href="#非压缩格式" class="headerlink" title="非压缩格式"></a>非压缩格式</h2><ul>
<li>以<code>RGBA8888</code>为例，指的是单个像素中每个通道（<code>RGBA</code>）各占<code>8</code>位，用<code>2^8=256</code>种灰度存储颜色信息。一个字节为<code>8</code>位，所以每个像素消耗了<code>4</code>个字节</li>
</ul>
<h2 id="DXTC"><a href="#DXTC" class="headerlink" title="DXTC"></a>DXTC</h2><ul>
<li>基本思想：把<code>4*4</code>的像素块压缩成一个<code>64</code>或<code>128</code>位的数据块</li>
<li>优点</li>
</ul>
<ol>
<li>创建了一个固定大小且独立编码片段，没有共享查找表或其他依赖关系，简化了解码过程</li>
</ol>
<h2 id="ATI1-x2F-2"><a href="#ATI1-x2F-2" class="headerlink" title="ATI1&#x2F;2"></a>ATI1&#x2F;2</h2><ul>
<li><code>ATI1</code>被称为<code>BC4</code>，<code>ATI2</code>被称为<code>BC5</code></li>
</ul>
<h2 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a>ETC</h2><ul>
<li>核心思想：将图像中的颜色和亮度分开存储<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/ETC%E5%8E%9F%E7%90%86.png?raw=true"></li>
<li>特点：把<code>4*4</code>的像素块压缩成一个<code>64</code>位数据块，并将像素单元水平或竖直朝向分为两个区块，每个像素颜色等于基础颜色加上索引指向的亮度范围<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/ETC%E5%8E%8B%E7%BC%A9.png?raw=true"></li>
</ul>
<h3 id="ETC1"><a href="#ETC1" class="headerlink" title="ETC1"></a>ETC1</h3><ul>
<li>优点：所有的<code>android</code>设备支持</li>
<li>缺点：不支持透明通道</li>
</ul>
<h3 id="ETC2"><a href="#ETC2" class="headerlink" title="ETC2"></a>ETC2</h3><ul>
<li>优点：支持透明通道</li>
<li>缺点：部分<code>android</code>设备不支持</li>
</ul>
<h2 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a>ASTC</h2><ul>
<li><code>ASTC</code>是基于块的压缩算法，其数据块大小固定为<code>128</code>位，不同的是块中的像素数量可变</li>
<li>优点：</li>
</ul>
<ol>
<li>可根据不同图片选择不同压缩率的算法</li>
<li>图片不需要为<code>2</code>的幂次</li>
<li>同时支持<code>LDR</code>和<code>HDR</code></li>
<li></li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>解码时间长</li>
<li>兼容性不够完善</li>
</ol>
<h2 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a>PVRTC</h2><ul>
<li>仅支持<code>Iphone</code>、<code>IAD</code>和部分安卓机</li>
<li>不同于基于块的算法，**<code>PVRTC</code>将纹理分为了低频信号和高频信号**。低频信号由两张低分辨率的图像<code>A</code>和<code>B</code>表示，这两张图在两个维度上都缩小了<code>4</code>倍，高频信号则是全分辨率但低精度的调制图像<code>M</code>，<code>M</code>记录了每个像素混合的权重。要解码时，<code>A</code>和<code>B</code>图像经过双线性插值（<code>bilinearly</code>）宽高放大4倍，然后与M图上的权重进行混合。<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/PVRTC%E5%8E%9F%E7%90%86.png?raw=true"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9%E6%80%BB%E7%BB%931.png?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9%E6%80%BB%E7%BB%932.png?raw=true"></p>
<h1 id="Clipmap"><a href="#Clipmap" class="headerlink" title="Clipmap"></a>Clipmap</h1><ul>
<li>基本思想是：设置一个<code>Mipmap</code>大小的上限，超过这个上限的<code>Mipmap</code>会被<code>clip</code>掉，也就是不会加载到内存中<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/Clipmap1.png?raw=true"></li>
<li>当我们的视野发生变化时，我们需要修改被<code>clip</code>的区域，让视野内<code>Mipmap</code>的部分加载<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/Clipmap2.png?raw=true"></li>
</ul>
<h1 id="Virtual-Texture（虚拟纹理）"><a href="#Virtual-Texture（虚拟纹理）" class="headerlink" title="Virtual Texture（虚拟纹理）"></a>Virtual Texture（虚拟纹理）</h1><ul>
<li><code>Virtual Texture</code>，用来解决巨量<code>Texture</code>的加载问题</li>
<li>这个概念取自于<code>Virtual Memory</code>。与虚拟内存类似的是，一个很大的<code>Texture</code>将不会全部加载到内存中，而是根据实际需求将需要的部分加载；与虚拟内存不同的是，它不会阻塞执行，可以使用更高的<code>Mipmap</code>来暂时显示，它对基于<code>block</code>的压缩贴图有很好的支持</li>
<li>基本思路是：将纹理的<code>Mipmap chain</code>分割为相同大小的<code>Tile</code>或<code>Page</code>，这里的纹理是虚纹理，然后通过某种映射，映射到一张内存中存在的纹理，这里的纹理是物理纹理，在游戏视野发生变化的时候，一部分物理纹理会被替换出去，一部分物理纹理会被加载<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/Virtual%20Texture.png?raw=true"></li>
<li>这样的机制不仅仅减少了带宽消耗和内存（显存）消耗，也带来了其它好处。比如有利于合批，而不用因为使用不同的<code>Texture</code>而打断合批，这样可以根据需求来组织几何使得更利于<code>Culling</code>。当然合批的好处是<code>states change</code>变少，<code>LightMap</code>也可以预计算到一张大的<code>Virtual Texture</code>上用来合批</li>
</ul>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><ul>
<li>地址映射在<code>Virtual Texture</code>中是一个很重要的环节，但是如何将一个<code>Virtual Texture</code>的<code>Texel</code>映射到<code>Physical Texture</code>的<code>Texel</code>上，需要适配到高分辨率的<code>Page</code>没有加载的情况，并得到已经加载的对应低分辨率的<code>Page</code>地址</li>
</ul>
<h3 id="四叉树映射"><a href="#四叉树映射" class="headerlink" title="四叉树映射"></a>四叉树映射</h3><ul>
<li>使用四叉树主要是为了和<code>Mipmap</code>对应，也就是每个低<code>MIP</code>的<code>Map</code>会对应有四个高<code>MIP</code>的<code>Map</code>，四叉树中只存储加载的<code>Mipmap</code>信息。这里的对应关系就是每个加载的<code>Virtual Texture</code>的<code>Page</code>对应一个四叉树的节点，具体的计算如下：</li>
<li>这里存在每个四叉树的节点中的内容就是<code>bias</code>和<code>scale</code>，这样就可以将虚拟纹理的地址转换成物理纹理的地址。如果没有找到，也可以用父节点的地址来得到低分辨率。但是这里要找到对应的节点需要搜索这个四叉树，搜索的速度取决于树的高度，也就是<code>Mipmap</code>的层级，在差的低<code>MIP</code>的地址上效率会比较低<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%BA%B9%E7%90%86/%E5%9B%9B%E5%8F%89%E6%A0%91%E6%98%A0%E5%B0%84.png?raw=true"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1></li>
<li><a href="https://docs.qq.com/slide/DUGxGR2FhYVB4bnFj">百人计划 - 纹理介绍</a></li>
<li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/">LearnOpenGL CN - 纹理</a></li>
<li><a href="https://www.2cto.com/kf/201603/493773.html">几种主流贴图压缩算法的实现原理详解</a></li>
<li><a href="https://docs.qq.com/slide/DUUhFaVdHUUhVcGFp">百人计划 - 纹理压缩</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/103838">Mipmap与纹理过滤</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/124601">Unity Mipmap详解</a></li>
<li><a href="https://docs.qq.com/slide/DUW1YdVpuS1R4VWpi">百人计划 - 模型UV</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143377682#:~:text=%E6%97%A2%E7%84%B6%E7%BA%B9%E7%90%86%E6%98%AF%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%82%A3%E4%B9%88%E8%87%AA%E7%84%B6%E5%B0%B1%E6%9C%89%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%8C%20%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7,%E4%BE%BF%E6%98%AF%E4%BB%8E%E7%BA%B9%E7%90%86%E5%9B%BE%E7%89%87%E4%B8%AD%E9%87%87%E9%9B%86%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E9%A2%9C%E8%89%B2%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82%20%E4%BE%8B%E5%A6%82%E5%9C%A8%E4%B8%8B%E5%9B%BE%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E9%87%87%E6%A0%B7%EF%BC%880%2C1%EF%BC%89%E8%BF%99%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%83%8F%E7%B4%A0%EF%BC%8C%E8%8E%B7%E5%BE%97%E4%BA%86%E6%B5%85%E8%93%9D%E8%89%B2%E3%80%82">图形学底层探秘 - 纹理采样、环绕、过滤与Mipmap的那些事</a></li>
<li><a href="https://blog.csdn.net/u013746357/article/details/90723268?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90723268.nonecase&spm=1018.2226.3001.4187">渲染的本质: 纹理过滤(Texture filtering)技术</a></li>
<li><a href="https://www.cnblogs.com/timlly/p/10463467.html">移动游戏性能优化通用技法</a></li>
<li><a href="https://jinligame.github.io/2019/03/10/20190310-Unity%20Image%20Compression/">Unity 图片压缩</a></li>
<li><a href="https://www.cnblogs.com/wczbd/p/15038659.html">[Unity优化]图片压缩格式</a></li>
<li><a href="https://blog.uwa4d.com/archives/optimzation_memory_1.html">性能优化，进无止境-内存篇（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/144332091?utm_id=0">计算机图形学七：纹理映射(Texture Mapping)及Mipmap技术</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/369977849?utm_id=0">图形学基础 - 纹理 - 纹理映射流程</a></li>
<li><a href="https://www.cnblogs.com/KillerAery/p/15106770.html#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84texture-mapping">实时渲染基础（4）纹理（Texture）</a></li>
<li><a href="https://blog.uwa4d.com/archives/USparkle_VirtualTexture.html">浅谈Virtual Texture</a></li>
<li><a href="https://blog.uwa4d.com/archives/Unreal_LargeTerrain.html">基于Unreal引擎的大地形加载研究</a></li>
<li><a href="https://blog.uwa4d.com/archives/TechSharing_120.html">大世界场景优化和加载策略</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372696893">Clipmap 在开放世界中的实战应用</a></li>
<li><a href="https://www.bilibili.com/read/cv15095375?spm_id_from=333.999.0.0">《Unity性能优化》系列课程笔记——第叁节</a></li>
<li>《Unity3D 高级编程：主程手记》</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>碰撞检测算法</title>
    <url>/2022/09/04/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="外接圆碰撞检测"><a href="#外接圆碰撞检测" class="headerlink" title="外接圆碰撞检测"></a>外接圆碰撞检测</h1><ul>
<li>多边形外接圆圆心距离大于两者的半径和(<code>d &gt; R1 + R2</code>)即可<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/%E5%A4%96%E6%8E%A5%E5%9C%86%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.jpg?raw=true"></li>
</ul>
<h1 id="AABB（Axis-Aligned-Bounding-Box）"><a href="#AABB（Axis-Aligned-Bounding-Box）" class="headerlink" title="AABB（Axis Aligned Bounding Box）"></a>AABB（Axis Aligned Bounding Box）</h1><ul>
<li><code>AABB</code>代表的是轴对齐碰撞箱（<code>Axis-aligned Bounding Box</code>），碰撞箱是指与场景基础坐标轴（<code>2D</code>中的是<code>x</code>和<code>y</code>轴）对齐的长方形的碰撞外形。与坐标轴对齐意味着这个长方形没有经过旋转并且它的边线和场景中基础坐标轴平行（例如，左右边线和<code>y</code>轴平行）。这些碰撞箱总是和场景的坐标轴平行，这使得所有的计算都变得更简单。下边是我们用一个<code>AABB</code>包裹一个球对象（物体）</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/AABB%E7%A2%B0%E6%92%9E%E7%A4%BA%E4%BE%8B.png?raw=true"></p>
<ul>
<li>判断碰撞：对于<code>AABB</code>来说很容易判断，因为它们是与坐标轴对齐的。对于每个轴我们要检测两个物体的边界在此轴向是否有重叠。因此我们只是简单地检查两个物体的水平边界是否重合以及垂直边界是否重合。如果水平边界和垂直边界都有重叠那么我们就检测到一次碰撞<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/AABB%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.png?raw=true"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">GLboolean <span class="title">CheckCollision</span><span class="params">(GameObject &amp;one, GameObject &amp;two)</span> <span class="comment">// AABB - AABB collision</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x轴方向碰撞？</span></span><br><span class="line">    <span class="type">bool</span> collisionX = one.Position.x + one.Size.x &gt;= two.Position.x &amp;&amp;</span><br><span class="line">        two.Position.x + two.Size.x &gt;= one.Position.x;</span><br><span class="line">    <span class="comment">// y轴方向碰撞？</span></span><br><span class="line">    <span class="type">bool</span> collisionY = one.Position.y + one.Size.y &gt;= two.Position.y &amp;&amp;</span><br><span class="line">        two.Position.y + two.Size.y &gt;= one.Position.y;</span><br><span class="line">    <span class="comment">// 只有两个轴向都有碰撞时才碰撞</span></span><br><span class="line">    <span class="keyword">return</span> collisionX &amp;&amp; collisionY;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="SAT（Separating-Axis-Theorem）分离轴定理"><a href="#SAT（Separating-Axis-Theorem）分离轴定理" class="headerlink" title="SAT（Separating Axis Theorem）分离轴定理"></a>SAT（Separating Axis Theorem）分离轴定理</h1><ul>
<li>分离轴定理是一项用于检测凸多边形碰撞的技术</li>
<li><code>SAT</code> 从 <strong>分离</strong> 的角度来判断物体间的碰撞</li>
<li>如果两个物体不发生碰撞，则一定存在一条直线，能将两个物体分离，这条能够隔开两个物体的线称为<strong>分离轴</strong>。可以假想有一束<strong>平行光</strong>从不同的角度照射待检测的两个多边形，当有一个合适的角度使得两者的影子没有重叠（投影的幕布于光线垂直），那么分离轴就找到了<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/SAT%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.jpg?raw=true"></li>
</ul>
<h1 id="GJK（Gilbert–Johnson–Keerthi）"><a href="#GJK（Gilbert–Johnson–Keerthi）" class="headerlink" title="GJK（Gilbert–Johnson–Keerthi）"></a>GJK（Gilbert–Johnson–Keerthi）</h1><ul>
<li><code>GJK</code>只适用于<strong>凸多边形</strong>间的碰撞检测</li>
<li><code>GJK</code> 从 重叠 的角度来探索物体间的碰撞</li>
<li>主要思想：<strong>当两个图形发生重叠时，那么在两个图形中一定存在一对点，相减后为原点</strong></li>
<li><code>GJK</code>算法的结论是：如果两个多边形相交，那么这两个多边形构成的闵可夫斯基差集(<code>Minkowski Difference</code>)，必然会包含原点</li>
<li>闵可夫斯基差集：用多边形<code>A</code>的所有点，减去多边形<code>B</code>中所有的点得到的一个点集合。<br><code>A – B = &#123; a – b ∣ a ∈ A , b ∈ B &#125;</code></li>
<li>闵可夫斯基差集的意义在于，得到两个多边形顶点间的坐标分布关系，如果两个多边形相交，那么差集中点会分布在原点四周，也就是说差集会包含原点<br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/GJK%E4%B8%8D%E7%9B%B8%E4%BA%A41.jpg?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/GJK%E4%B8%8D%E7%9B%B8%E4%BA%A42.jpg?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/GJK%E7%9B%B8%E4%BA%A41.jpg?raw=true"><br><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/GJK%E7%9B%B8%E4%BA%A42.jpg?raw=true"></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/449795053">常见的碰撞检测方法</a></li>
<li><a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/05%20Collisions/02%20Collision%20detection/#aabb-">LearnOpenGL CN 碰撞检测</a></li>
<li><a href="https://blog.csdn.net/you_lan_hai/article/details/108293780">物理引擎学习03-GJK碰撞检测算法基础</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2023/04/01/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>解释器模式：<strong>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</strong></p>
</li>
<li><p>解释器模式属于行为型模式</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>抽象表达式(AbstractExpression)：<strong>在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类</strong></li>
<li>终结符表达式(TerminalExpression)：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子</li>
<li>非终结符表达式(NonterminalExpression)：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成</li>
<li>环境类(Context)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/interpreter.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li><strong>易于改变和扩展文法</strong>。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</li>
<li><strong>实现文法较为容易</strong>。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码</li>
<li><strong>增加新的解释表达式较为方便</strong>。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><strong>对于复杂文法难以维护</strong>。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式</li>
<li><strong>执行效率较低</strong>。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一个语言的文法较为简单</li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达</li>
<li>执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(context.input.Length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.input.StartsWith(A()))</span><br><span class="line">        &#123;</span><br><span class="line">            context.output += (Multiplier() * <span class="number">1</span>);</span><br><span class="line">            context.input = context.input.Substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (context.input.StartsWith(B()))</span><br><span class="line">        &#123;</span><br><span class="line">            context.output += (Multiplier() * <span class="number">3</span>);</span><br><span class="line">            context.input = context.input.Substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (context.input.StartsWith(C()))</span><br><span class="line">        &#123;</span><br><span class="line">            context.output += (Multiplier() * <span class="number">5</span>);</span><br><span class="line">            context.input = context.input.Substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            context.output += Multiplier() * context.input.Length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">A</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">B</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">C</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> <span class="title">Multiplier</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">B</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">C</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Multiplier</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">B</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">C</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Multiplier</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">B</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">C</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Multiplier</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShutDownExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">B</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">C</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Multiplier</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> output;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params"><span class="built_in">string</span> _input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        input = _input;</span><br><span class="line">        output = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;ACBAA&quot;</span>;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(s);</span><br><span class="line"></span><br><span class="line">        List&lt;AbstractExpression&gt; list = <span class="keyword">new</span> List&lt;AbstractExpression&gt;();</span><br><span class="line">        list.Add(<span class="keyword">new</span> AExpression());</span><br><span class="line">        list.Add(<span class="keyword">new</span> BExpression());</span><br><span class="line">        list.Add(<span class="keyword">new</span> CExpression());</span><br><span class="line">        list.Add(<span class="keyword">new</span> ShutDownExpression());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            i.Interpret(context);</span><br><span class="line">            <span class="comment">// 1 = 1*1</span></span><br><span class="line">            <span class="comment">// 11 = 1 + 2*5</span></span><br><span class="line">            <span class="comment">// 20 = 11 + 3*3</span></span><br><span class="line">            <span class="comment">// 220 = 20 + 100*2</span></span><br><span class="line">            Debug.Log(context.output);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//220</span></span><br><span class="line">        Debug.Log(context.output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Interpreter%20Pattern">解释器模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346512130">C#设计模式笔记之解释器模式 (Interpreter Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/interpreter-pattern.html">解释器模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2023/04/03/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>组合模式：<strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</strong></li>
<li>组合模式属于结构型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象组件类(Component)：<strong>它可以是接口或抽象类，为叶子组件和容器组件对象声明接口</strong>，在该角色中可以包含所有子类共有行为的声明和实现。在抽象组件类中，定义了访问及管理它的子组件的方法</li>
<li>叶子组件类(Leaf)：在组合模式中，表示叶子节点对象，叶子节点没有子节点，实现了在抽象组件类中定义的行为</li>
<li>容器组件类(Composite)：在组合模式中，表示容器节点对象，容器节点包含子节点，其子节点可以叶子节点，也可以是容器节点，提供了一个集合用于存储子节点，实现了在抽象组件类中定义的行为，包括访问及管理子组件的方法</li>
</ol>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易</li>
<li>客户端调用简单，客户端可以一致的使用组合结构或其中单个对象</li>
<li>定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构</li>
<li>更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/composite.gif?raw=true"></p>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li>
<li>用组合模式实现Unity中游戏物体父子关系的管理</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> myName;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Component&gt; childComponent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myName = name;</span><br><span class="line">        childComponent = <span class="keyword">new</span> List&lt;Component&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AddChild</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">RemoveChild</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">CoutName</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Leaf</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChild</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">RemoveChild</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CoutName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(myName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Composite</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChild</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        childComponent.Add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">RemoveChild</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        childComponent.Remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CoutName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(myName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根节点，容器组件</span></span><br><span class="line">        Composite root = <span class="keyword">new</span> Composite(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line">        <span class="comment">//Leaf_A1、Leaf_A3是叶子组件，Leaf_A2容器组件</span></span><br><span class="line">        Leaf Leaf_A1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf_A1&quot;</span>);</span><br><span class="line">        Composite Leaf_A2 = <span class="keyword">new</span> Composite(<span class="string">&quot;Leaf_A2&quot;</span>);</span><br><span class="line">        Leaf Leaf_A3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf_A3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.AddChild(Leaf_A1);</span><br><span class="line">        root.AddChild(Leaf_A2);</span><br><span class="line">        root.AddChild(Leaf_A3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Leaf_A2_B1、Leaf_A2_B2是叶子组件</span></span><br><span class="line">        Leaf Leaf_A2_B1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf_A2_B1&quot;</span>);</span><br><span class="line">        Leaf Leaf_A2_B2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf_A2_B2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Leaf_A2.AddChild(Leaf_A2_B1);</span><br><span class="line">        Leaf_A2.AddChild(Leaf_A2_B2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//       树形结构如下：</span></span><br><span class="line">        <span class="comment">//          Root</span></span><br><span class="line">        <span class="comment">//         /  |  \</span></span><br><span class="line">        <span class="comment">//        /   |   \</span></span><br><span class="line">        <span class="comment">//       /    |    \</span></span><br><span class="line">        <span class="comment">//  Leaf_A1 Leaf_A2 Leaf_A3</span></span><br><span class="line">        <span class="comment">//          /     \</span></span><br><span class="line">        <span class="comment">//   Leaf_A2_B1  Leaf_A2_B2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度优先遍历</span></span><br><span class="line">        <span class="comment">//Root Leaf_A1 Leaf_A2 Leaf_A2_B1 Leaf_A2_B2 Leaf_A3</span></span><br><span class="line">        DepthFirstSearch(root);</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">&quot;————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        <span class="comment">//Root Leaf_A1 Leaf_A2 Leaf_A3 Leaf_A2_B1 Leaf_A2_B2</span></span><br><span class="line">        BreadthFirstSearch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DepthFirstSearch</span>(<span class="params">Component component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        component.CoutName();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> component.childComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            DepthFirstSearch(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BreadthFirstSearch</span>(<span class="params">Component component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Component&gt; list = <span class="keyword">new</span> List&lt;Component&gt;();</span><br><span class="line">        list.Add(component);</span><br><span class="line">        <span class="keyword">while</span>(list.Count&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> tmp = list[<span class="number">0</span>];</span><br><span class="line">            tmp.CoutName();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> tmp.childComponent)</span><br><span class="line">                list.Add(i);</span><br><span class="line">            list.Remove(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Composite%20Pattern">组合模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346509377">C#设计模式笔记之组合模式（Composite Pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/composite-pattern.html">组合模式</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2023/04/03/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>装饰模式：<strong>动态地将责任附加到对象上</strong>。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。可以在不改变一个对象本身功能的基础上给对象增加额外的新行为</li>
<li>装饰模式属于结构型模式</li>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象构件(Component)：<strong>它是具体构件和抽象装饰类的共同父类</strong>，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件(ConcreteComponent)：<strong>它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法</strong>，装饰器可以给它增加额外的职责（方法）</li>
<li>抽象装饰类(Decorator)：<strong>它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现</strong>。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的</li>
<li>具体装饰类(ConcreteDecorator)：<strong>它是抽象装饰类的子类，负责向构件添加新的职责</strong>。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/decorator.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Display</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体构件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteComponent</span> : <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComponentDecorator</span> : <span class="title">MyCompoent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyCompoent compoent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComponentDecorator</span>(<span class="params">MyCompoent c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        compoent = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        compoent.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpDecorator</span> : <span class="title">ComponentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpDecorator</span>(<span class="params">MyCompoent c</span>) : <span class="title">base</span>(<span class="params">c</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.NewDisplay();</span><br><span class="line">        <span class="keyword">base</span>.Display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewDisplay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;在上面输出：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DownDecorator</span> : <span class="title">ComponentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownDecorator</span>(<span class="params">MyCompoent c</span>) : <span class="title">base</span>(<span class="params">c</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.NewDisplay();</span><br><span class="line">        <span class="keyword">base</span>.Display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewDisplay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;在下面输出：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyCompoent component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        component.Display();</span><br><span class="line"></span><br><span class="line">        UpDecorator upDecorator = <span class="keyword">new</span> UpDecorator(component);</span><br><span class="line">        <span class="comment">//在上面输出：</span></span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        upDecorator.Display();</span><br><span class="line"></span><br><span class="line">        DownDecorator downDecorator = <span class="keyword">new</span> DownDecorator(upDecorator);</span><br><span class="line">        <span class="comment">//在下面输出：</span></span><br><span class="line">        <span class="comment">//在上面输出：</span></span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        downDecorator.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Decorator%20Pattern">装饰模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346510063">C#设计模式笔记之装饰模式（Decorator Pattern）</a></li>
<li><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">装饰器模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2022/09/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>观察者模式属于行为型模式</p>
</li>
<li><p>定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
</li>
<li><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
</li>
<li><p>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作</p>
</li>
<li><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</p>
</li>
<li><p>观察者模式的主要角色如下。</p>
</li>
</ul>
<ol>
<li><p>抽象主题（<code>Subject</code>）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法</p>
</li>
<li><p>具体主题（<code>Concrete Subject</code>）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象</p>
</li>
<li><p>抽象观察者（<code>Observer</code>）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用</p>
</li>
<li><p>具体观察者（<code>Concrete Observer</code>）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态</p>
</li>
</ol>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//抽象主题</span><br><span class="line">public abstract class Subject</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void Raise();</span><br><span class="line">    public abstract void AddListener(Observer observer);</span><br><span class="line">    public abstract void RemoveListener(Observer observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体主题</span><br><span class="line">public class Son : Subject</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;Observer&gt; listeners;</span><br><span class="line"></span><br><span class="line">    public override void Raise()</span><br><span class="line">    &#123;</span><br><span class="line">        if(listeners.Count&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = listeners.Count - 1; i &gt;= 0;--i)</span><br><span class="line">                listeners[i].Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void AddListener(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!listeners.Contains(observer))</span><br><span class="line">        &#123;</span><br><span class="line">            listeners.Add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void RemoveListener(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        if(listeners.Contains(observer))</span><br><span class="line">        &#123;</span><br><span class="line">            listeners.Add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象观察者</span><br><span class="line">public interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    void Update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体观察者</span><br><span class="line">public class Father : Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mother : Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Mother&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Observer father = new Father();</span><br><span class="line">        Observer mother = new Mother();</span><br><span class="line"></span><br><span class="line">        Son son = new Son();</span><br><span class="line">        son.AddListener(father);</span><br><span class="line">        son.AddListener(mother);</span><br><span class="line">        son.Raise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：</li>
</ul>
<ol>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立一套触发机制</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.runoob.com/design-pattern/observer-pattern.html">观察者模式 | 菜鸟教程</a></li>
<li><a href="https://gpp.tkchu.me/observer.html">游戏编程模式 - 观察者模式</a></li>
<li><a href="https://www.cnblogs.com/xuwendong/p/9814417.html">深入理解设计模式（八）：观察者模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2022/07/17/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li>创建型模式：提供了一种在创建对象的同时隐藏创建逻辑的方式，从而将对象的创建与使用分离</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<h2 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h2><ul>
<li>结构性模式：关注类和对象的组合，即如何将类或对象按某种布局组成更大的结构</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li>行为型模式：用于描述类或对象之间怎样通信、协作共同完成任务，以及怎样分配职责</li>
</ul>
<p><img src="https://github.com/KDuoLi/myBlog-Picture/blob/main/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.png?raw=true"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>常用的面向对象设计原则包括<code>7</code>个，这些原则并不是孤立存在的，它们相互依赖，相互补充。</li>
<li>如下</li>
</ul>
<ol>
<li>开闭原则（<code>OCP</code>）</li>
<li>里氏替换原则（<code>LSP</code>）</li>
<li>迪米特原则（<code>LoD</code>)</li>
<li>单一职责原则（<code>SRP</code>）</li>
<li>接口分离原则（<code>ISP</code>）</li>
<li>依赖倒置原则（<code>DIP</code>）</li>
<li>组合&#x2F;聚合复用原则（<code>CARP</code>）</li>
</ol>
<h1 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（<code>OCP</code>）</h1><ul>
<li>开闭原则是指在进行面向对象设计中，设计类或其他程序单位时，应该遵循：<strong>对扩展开放</strong>（<code>open</code>），<strong>对修改关闭</strong>（<code>closed</code>） 的设计原则</li>
<li>作用</li>
</ul>
<ol>
<li>可以提高代码的可复用性</li>
<li>可以提高代码的可维护性</li>
</ol>
<h1 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（<code>LSP</code>）</h1><ul>
<li><p>定义：任何基类可以出现的地方，子类也可以出现。通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。一旦重写父类方法，有可能破坏继承体系，导致子类不能够替换引用基类的地方</p>
</li>
<li><p>总结为以下<code>4</code>点</p>
</li>
</ul>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li>
</ol>
<ul>
<li>作用</li>
</ul>
<ol>
<li>克服了继承中重写父类造成的可复用性变差的缺点</li>
<li>加强程序的健壮性</li>
<li>里氏替换原则是实现开闭原则的重要方式之一</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性</li>
</ol>
<h1 id="迪米特原则（LoD"><a href="#迪米特原则（LoD" class="headerlink" title="迪米特原则（LoD)"></a>迪米特原则（<code>LoD</code>)</h1><ul>
<li>迪米特法则又叫作最少知识原则，一个软件的实体应当尽可能的减少和其他实体发生相互作用，即当设计实现一个类时，这个类应该越少使用到其它类提供的功能越好，尽量不要与其他类互相作用，减少类之间的耦合度</li>
<li>优点</li>
</ul>
<ol>
<li>降低类之间的耦合，提高了模块的相对独立性</li>
<li>由于类之间的耦合度降低，从而提高了类的可复用率和系统的扩展性</li>
</ol>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><ul>
<li>单一职责原则又称单一功能原则，它规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。核心是类的职责要单一，不能将太多的职责放在一个类中，应该只负责一类行为</li>
<li>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，存在以下缺点</li>
</ul>
<ol>
<li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力</li>
<li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费</li>
</ol>
<ul>
<li>优点</li>
</ul>
<ol>
<li>降低类的复杂性，类的职责清晰明确，提高了类的内聚性</li>
<li>提高类的可读性和维护性</li>
<li>提高系统的可维护性。可读性提高</li>
<li>变更引起的风险降低</li>
</ol>
<h1 id="接口分离原则（ISP）"><a href="#接口分离原则（ISP）" class="headerlink" title="接口分离原则（ISP）"></a>接口分离原则（<code>ISP</code>）</h1><ul>
<li>接口隔离原则要求尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。即客户端不应该被迫依赖于它不使用的方法、一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的</li>
</ul>
<ol>
<li>单一职责原则注重的是职责；而接口隔离原则注重的是对接口依赖的隔离</li>
<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建</li>
</ol>
<ul>
<li>做法</li>
</ul>
<ol>
<li><p>一个类对一个类的依赖应该建立在最小的接口上</p>
</li>
<li><p>建立单一接口，不要建立庞大臃肿的接口</p>
</li>
<li><p>尽量细化接口，接口中的方法尽量少</p>
</li>
</ol>
<ul>
<li>优点</li>
</ul>
<ol>
<li>符合高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性</li>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性</li>
</ol>
<h1 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（<code>DIP</code>）</h1><ul>
<li>依赖倒置也称依赖注入</li>
<li>依赖倒置原定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。核心思想是要面向接口编程，不要面向实现编程</li>
<li>依赖倒置是实现控制反转（IOC）的一种方式，控制反转是一种设计思想</li>
<li><strong>如果一个类A的功能实现需要借助于类B，那么就称类B是类A的依赖</strong>。如果在类A的内部去实例化类B，那么两者之间会出现较高的<strong>耦合</strong>，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制反转（IOC Inversion Of Control），<strong>即类A不控制类B的创建和销毁，类A仅使用类B，那么B的控制权交给类A之外处理</strong></li>
<li><strong>使用依赖注入，可以将类与其依赖对象的创建过程分离开来，使得类不再依赖具体的依赖对象实现，而是依赖于抽象的接口或基类</strong></li>
<li><strong>不使用依赖注入时，类通常需要自己创建或获取依赖对象，这就使得代码具有高度的耦合性</strong>。如果需要更改依赖对象或增加新的依赖对象，就必须修改该类的代码。这样的代码不利于维护和扩展，而且会增加代码的复杂性</li>
<li>有三种方法实现：</li>
</ul>
<ol>
<li>通过A的接口，把B传入；</li>
<li>通过A的构造，把B传入；</li>
<li>通过设置A的属性，把B传入；</li>
</ol>
<ul>
<li>优点</li>
</ul>
<ol>
<li>采用依赖倒置原则可以减少类间的耦合性</li>
<li>提高系统的稳定性</li>
<li>降低并行开发引起的风险</li>
<li>提高代码的可读性和可维护性</li>
</ol>
<ul>
<li>如下不使用依赖倒置原则的代码。<code>WeaponController</code>的依赖是<code>SG</code>和<code>AG</code>。<code>WeaponController</code>控制武器开火，如果要添加武器，那么就必须在<code>WeaponController</code>中添加，耦合度过高</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SG</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AR</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeaponController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SGFire</span>(<span class="params">SG sg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sg.Fire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ARFire</span>(<span class="params">AR ar</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ar.Fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如下使用依赖倒置原则的代码。通过接口传入。<code>WeaponController</code>的依赖是<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFire</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SG</span> : <span class="title">IFire</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AR</span> : <span class="title">IFire</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeaponController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WeaponFire</span>(<span class="params">IFire <span class="keyword">if</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>.Fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">IFire if1 = <span class="keyword">new</span> SG();</span><br><span class="line"><span class="keyword">new</span> WeaponController().WeaponFire(if1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="组合-x2F-聚合复用原则（CARP）"><a href="#组合-x2F-聚合复用原则（CARP）" class="headerlink" title="组合&#x2F;聚合复用原则（CARP）"></a>组合&#x2F;聚合复用原则（<code>CARP</code>）</h1><ul>
<li><p>组合&#x2F;聚合复用原则要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</p>
</li>
<li><p>优点</p>
</li>
</ul>
<ol>
<li>可以使系统更加灵活，类与类之间的耦合度降低</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/qq_34760445/article/details/82931002">面向对象设计的七大设计原则详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1981857">设计原则：面向对象设计原则详解</a></li>
<li><a href="http://c.biancheng.net/view/1317.html">软件设计模式概述</a></li>
<li><a href="https://blog.csdn.net/m0_37741420/article/details/106169752">设计模式（一）设计模式的分类与区别</a></li>
<li><a href="https://www.cnblogs.com/xibei/p/12362992.html#h-1">帮你整理了一份设计模式速查手册</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33492169">浅谈控制反转与依赖注入</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1504901">控制反转-Ioc之Unity</a></li>
<li><a href="https://www.zhihu.com/question/32108444/answer/220819349">如何用最简单的方式解释依赖注入？依赖注入是如何实现解耦的?</a></li>
</ul>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2023/04/02/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>适配器模式：<strong>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器</strong></p>
</li>
<li><p>适配器模式属于结构型模式</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>目标抽象类(Target)：<strong>目标抽象类定义客户所需接口</strong>，可以是一个抽象类或接口，也可以是具体类。</li>
<li>适配器类(Adapter)：<strong>适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心</strong>，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系</li>
<li>适配者类(Adaptee)：<strong>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配</strong>，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/adapter.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都非常好，在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHead</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charge</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Iphone</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IphoneCharge</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Iphone正在充电：<span class="subst">&#123;num&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IphoneAdapter</span> : <span class="title">IHead</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Iphone iphone;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IphoneAdapter</span>(<span class="params">Iphone _iphone,<span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.iphone = _iphone;</span><br><span class="line">        <span class="keyword">this</span>.num = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charge</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        iphone?.IphoneCharge(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IphoneAdapter iphoneAdapter = <span class="keyword">new</span> IphoneAdapter(<span class="keyword">new</span> Iphone(), <span class="number">50</span>);</span><br><span class="line">        <span class="comment">//Iphone正在充电：50</span></span><br><span class="line">        iphoneAdapter.Charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Adapter%20Pattern">适配器模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346509882">C#设计模式笔记之适配器模式 (Adapter Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/adapter-pattern.html">适配器模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2023/03/27/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</li>
<li>责任链模式是一种行为型模式</li>
<li>责任链模式包含以下主要角色：</li>
</ul>
<ol>
<li>抽象处理类。主要定义用于处理请求的接口，（可选）实现后续链接</li>
<li>具体处理类。主要作用是处理请求和访问其继任者</li>
<li>客户端（请求者）：向链上的 ConcreteHandler 对象发起请求</li>
</ol>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>方便增加新的请求处理类</li>
<li>降低耦合度。它将请求的发送者和接受者解耦</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>不能保证请求一定被接收</li>
</ol>
<ul>
<li>模式适用场景：</li>
</ul>
<ol>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求</li>
<li>游戏开发中的关卡设计，就可以采用职责链模式</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/chain.gif?raw=true"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//抽象处理类</span><br><span class="line">public abstract class AbstractLogger</span><br><span class="line">&#123;</span><br><span class="line">    //责任链中的下一个元素</span><br><span class="line">    protected AbstractLogger nextLogger;</span><br><span class="line">    //设置职责链的下一个元素</span><br><span class="line">    public abstract void SetNextLogger(AbstractLogger nextLogger);</span><br><span class="line">    public abstract void Handle(int sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体处理类</span><br><span class="line">public class ConsoleLogger : AbstractLogger</span><br><span class="line">&#123;</span><br><span class="line">    public override void SetNextLogger(AbstractLogger abstractLogger)</span><br><span class="line">    &#123;</span><br><span class="line">        nextLogger = abstractLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Handle(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sum&lt;10)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log($&quot;ConsoleLogger：sum&lt;10&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nextLogger?.Handle(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WarningLogger : AbstractLogger</span><br><span class="line">&#123;</span><br><span class="line">    public override void SetNextLogger(AbstractLogger abstractLogger)</span><br><span class="line">    &#123;</span><br><span class="line">        nextLogger = abstractLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Handle(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sum&lt;100)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log($&quot;WarningLogger：sum&lt;100&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nextLogger?.Handle(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorleLogger : AbstractLogger</span><br><span class="line">&#123;</span><br><span class="line">    public override void SetNextLogger(AbstractLogger abstractLogger)</span><br><span class="line">    &#123;</span><br><span class="line">        nextLogger = abstractLogger;</span><br><span class="line">    &#125;</span><br><span class="line">    public override void Handle(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log($&quot;ErrorleLogger：sum=&#123;sum&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        ConsoleLogger consoleLogger = new ConsoleLogger();</span><br><span class="line">        WarningLogger warningLogger = new WarningLogger();</span><br><span class="line">        ErrorleLogger errorleLogger = new ErrorleLogger();</span><br><span class="line"></span><br><span class="line">        consoleLogger.SetNextLogger(warningLogger);</span><br><span class="line">        warningLogger.SetNextLogger(errorleLogger);</span><br><span class="line"></span><br><span class="line">        //ConsoleLogger：sum&lt;10</span><br><span class="line">        consoleLogger.Handle(5);</span><br><span class="line">        //WarningLogger：sum&lt;100</span><br><span class="line">        consoleLogger.Handle(50);</span><br><span class="line">        //ErrorleLogger：sum=500</span><br><span class="line">        consoleLogger.Handle(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Chain%20of%20Responsibility%20Pattern">Chain of Responsibility Pattern 责任链模式</a></li>
<li><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">责任链模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511346">C#设计模式笔记之职责链模式 (Chain of Responsibility Pattern)</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2023/04/01/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>访问者模式：<strong>提供一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</strong></p>
</li>
<li><p>访问者模式属于行为型模式</p>
</li>
<li><p>主要角色如下：</p>
</li>
</ul>
<ol>
<li>抽象访问者（Vistor）：<strong>抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作</strong>，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作</li>
<li>具体访问者（ConcreteVisitor）：<strong>具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素</strong></li>
<li>抽象元素（Element）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数</li>
<li>具体元素（ConcreteElement）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作</li>
<li>对象结构（ObjectStructure）：<strong>对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法</strong>。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象</li>
</ol>
<p><img src="https://github.com/QianMo/Unity-Design-Pattern/blob/master/UML_Picture/visitor.gif?raw=true"></p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li><strong>增加新的访问操作很方便</strong>。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”</li>
<li><strong>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中</strong>。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><strong>增加新的元素类很困难</strong>。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求</li>
<li><strong>坏封装破</strong>。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
<li>一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">Element e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteVisitor1</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">Element e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;该元素值为<span class="subst">&#123;e.num&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteVisitor2</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">Element e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;该元素的名字为<span class="subst">&#123;e.name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteElement</span> : <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteElement</span>(<span class="params"><span class="built_in">int</span> n,<span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = n;</span><br><span class="line">        <span class="keyword">this</span>.name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.Visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Element&gt; list = <span class="keyword">new</span> List&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> e <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            e.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        list.Add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        list.Remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        objectStructure.AddElement(<span class="keyword">new</span> ConcreteElement(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        objectStructure.AddElement(<span class="keyword">new</span> ConcreteElement(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        objectStructure.AddElement(<span class="keyword">new</span> ConcreteElement(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 2 3</span></span><br><span class="line">        objectStructure.Accept(<span class="keyword">new</span> ConcreteVisitor1());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A B C</span></span><br><span class="line">        objectStructure.Accept(<span class="keyword">new</span> ConcreteVisitor2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Visitor%20Pattern">访问者模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346511627">C#设计模式笔记之访问者模式 (Visitor Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/visitor-pattern.html">访问者模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2023/03/31/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>迭代器模式：<strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示</strong></li>
<li>迭代器模式属于行为型模式</li>
<li>优点：</li>
</ul>
<ol>
<li>它支持以不同的方式遍历一个聚合对象</li>
<li>在同一个聚合上可以有多个遍历</li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li>
</ol>
<ul>
<li>适用场景：</li>
</ul>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示</li>
<li>需要为聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口</li>
</ol>
<ul>
<li>主要角色如下：</li>
</ul>
<ol>
<li>抽象迭代器：定义用于访问和遍历元素的接口</li>
<li>具体迭代器：实现访问和遍历元素的接口</li>
<li>抽象集合：定义用于创建迭代器对象的接口</li>
<li>具体集合：实现迭代器创建接口以返回正确的具体迭代器的实例</li>
</ol>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbstractIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    Item Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteIterator</span> : <span class="title">AbstractIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Item Current =&gt; items[_currentIndex];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span>(<span class="params">List&lt;Item&gt; list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_currentIndex+<span class="number">1</span>&lt;items.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_currentIndex;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_currentIndex!=<span class="number">-1</span>)</span><br><span class="line">            _currentIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbstractCollection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">AbstractIterator <span class="title">CreateIrerator</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collection</span> : <span class="title">AbstractCollection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Item&gt; list = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractIterator <span class="title">CreateIrerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params">Item item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        list.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Collection collection = <span class="keyword">new</span> Collection();</span><br><span class="line">        collection.AddItem(<span class="keyword">new</span> Item(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        collection.AddItem(<span class="keyword">new</span> Item(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        collection.AddItem(<span class="keyword">new</span> Item(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">        AbstractIterator iterator = collection.CreateIrerator();</span><br><span class="line">        <span class="comment">//a b c</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.MoveNext())</span><br><span class="line">            Debug.Log(iterator.Current.name);</span><br><span class="line">        iterator.Reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Iterator%20Pattern">迭代器模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346512022">C#设计模式笔记之迭代器模式 (Iterator Pattern)</a></li>
<li><a href="https://www.runoob.com/design-pattern/iterator-pattern.html">迭代器模式 | 菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
